var tipuesearch = {"pages":[{"title":" 3D-PDR ","text":"3D-PDR 如果你的工程有单独的源代码目录，例如 src/ src_dir: src 如果有预处理/宏，或 include 目录，把它们加进来（按需改） include_dir: . Developer Info your-name","tags":"home","url":"index.html"},{"title":"pdr_excit – 3D-PDR ","text":"type, public :: pdr_excit Inherited by type~~pdr_excit~~InheritedByGraph type~pdr_excit pdr_excit type~pdr_node pdr_node type~pdr_node->type~pdr_excit coolant Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial real(kind=RK), public, pointer :: pop (:)","tags":"","url":"type/pdr_excit.html"},{"title":"pdr_node – 3D-PDR ","text":"type, public :: pdr_node Inherits type~~pdr_node~~InheritsGraph type~pdr_node pdr_node type~pdr_excit pdr_excit type~pdr_node->type~pdr_excit coolant Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer, public :: etype real(kind=RK), public :: x real(kind=RK), public :: y real(kind=RK), public :: z real(kind=RK), public :: vx real(kind=RK), public :: vy real(kind=RK), public :: vz real(kind=RK), public :: Tgas real(kind=RK), public :: Tdust real(kind=RK), public :: rho real(kind=RK), public :: UVfield real(kind=RK), public :: totalcooling real(kind=RK), public, pointer :: AV (:) real(kind=RK), public, pointer :: abundance (:) real(kind=RK), public, pointer :: cooling (:) real(kind=RK), public, pointer :: heating (:) type( pdr_excit ), public, allocatable :: coolant (:) real(kind=RK), public :: zetalocal","tags":"","url":"type/pdr_node.html"},{"title":"coolant_node – 3D-PDR ","text":"type, public :: coolant_node Components Type Visibility Attributes Name Initial real(kind=dp), public, pointer :: COEFF (:) real(kind=dp), public, pointer :: ENERGIES (:) real(kind=dp), public, pointer :: WEIGHTS (:) real(kind=dp), public, pointer :: A_COEFFS (:,:) real(kind=dp), public, pointer :: B_COEFFS (:,:) real(kind=dp), public, pointer :: C_COEFFS (:,:) real(kind=dp), public, pointer :: FREQUENCIES (:,:) real(kind=dp), public, pointer :: TEMPERATURES (:,:) real(kind=dp), public, pointer :: HP_COL (:,:,:) real(kind=dp), public, pointer :: H_COL (:,:,:) real(kind=dp), public, pointer :: EL_COL (:,:,:) real(kind=dp), public, pointer :: HE_COL (:,:,:) real(kind=dp), public, pointer :: H2_COL (:,:,:) real(kind=dp), public, pointer :: PH2_COL (:,:,:) real(kind=dp), public, pointer :: OH2_COL (:,:,:) real(kind=dp), public :: molweight integer, public :: cnlev integer, public :: cntemp integer, public :: cspec character(len=10), public :: cname integer, public :: incr real, public :: percentage","tags":"","url":"type/coolant_node.html"},{"title":"cpop_node – 3D-PDR ","text":"type, public :: cpop_node Components Type Visibility Attributes Name Initial real(kind=dp), public, pointer :: evalpop (:,:,:)","tags":"","url":"type/cpop_node.html"},{"title":"pdr_excit – 3D-PDR ","text":"type, public :: pdr_excit Inherited by type~~pdr_excit~2~~InheritedByGraph type~pdr_excit~2 pdr_excit type~pdr_node~2 pdr_node type~pdr_node~2->type~pdr_excit~2 coolant Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial real(kind=dp), public, pointer :: pop (:) real(kind=dp), public, pointer :: line (:,:) real(kind=dp), public, pointer :: solution (:) real(kind=dp), public, pointer :: relativechange (:) logical, public :: isconverged","tags":"","url":"type/pdr_excit~2.html"},{"title":"pdr_node – 3D-PDR ","text":"type, public :: pdr_node Inherits type~~pdr_node~2~~InheritsGraph type~pdr_node~2 pdr_node type~pdr_excit~2 pdr_excit type~pdr_node~2->type~pdr_excit~2 coolant Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer(kind=i4b), public, pointer :: epray (:) integer(kind=i4b), public, pointer :: projected (:,:) real(kind=dp), public, pointer :: length (:,:) integer(kind=i4b), public, pointer :: raytype (:) real(kind=dp), public, pointer :: epoint (:,:,:) real(kind=dp), public, pointer :: AV (:) real(kind=dp), public, pointer :: rad_surface (:) real(kind=dp), public, pointer :: abundance (:) real(kind=dp), public, pointer :: cooling (:) real(kind=dp), public, pointer :: heating (:) real(kind=dp), public, pointer :: column_NH2 (:) real(kind=dp), public, pointer :: column_NHD (:) real(kind=dp), public, pointer :: column_NCO (:) real(kind=dp), public, pointer :: column_NC (:) real(kind=dp), public, pointer :: column_NS (:) real(kind=dp), public :: totalcooling type( pdr_excit ), public, allocatable :: coolant (:) real(kind=dp), public :: UVfield real(kind=dp), public :: zetalocal real(kind=dp), public :: rho real(kind=dp), public :: smoo real(kind=dp), public :: x real(kind=dp), public :: y real(kind=dp), public :: z integer(kind=i4b), public :: etype real(kind=dp), public :: Tdust real(kind=dp), public :: nTgas real(kind=dp), public :: Tgas real(kind=dp), public, pointer :: solution (:,:) logical, public :: levelconverged character(len=1), public :: previouschange","tags":"","url":"type/pdr_node~2.html"},{"title":"box – 3D-PDR ","text":"type, public :: box Components Type Visibility Attributes Name Initial real(kind=RK), public :: min (3) real(kind=RK), public :: max (3)","tags":"","url":"type/box.html"},{"title":"HEALPix_ray – 3D-PDR ","text":"type, public :: HEALPix_ray Components Type Visibility Attributes Name Initial integer, public :: eval real(kind=RK), public :: length real(kind=RK), public :: origin (3) real(kind=RK), public :: angle (2)","tags":"","url":"type/healpix_ray.html"},{"title":"box – 3D-PDR ","text":"type, public :: box Components Type Visibility Attributes Name Initial real(kind=RK), public :: min (3) real(kind=RK), public :: max (3)","tags":"","url":"type/box~2.html"},{"title":"HEALPix_ray – 3D-PDR ","text":"type, public :: HEALPix_ray Components Type Visibility Attributes Name Initial integer, public :: eval real(kind=RK), public :: length real(kind=RK), public :: origin (3) real(kind=RK), public :: angle (2)","tags":"","url":"type/healpix_ray~2.html"},{"title":"READINPUT – 3D-PDR","text":"subroutine READINPUT(FILENAME, NLEV, NTEMP, ENERGIES, WEIGHTS, A_COEFFS, B_COEFFS, FREQUENCIES, TEMPERATURES, H_COL, HP_COL, EL_COL, HE_COL, H2_COL, PH2_COL, OH2_COL) Uses healpix_types proc~~readinput~~UsesGraph proc~readinput READINPUT module~healpix_types~2 healpix_types proc~readinput->module~healpix_types~2 module~definitions definitions module~healpix_types~2->module~definitions Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FILENAME integer(kind=I4B), intent(in) :: NLEV integer(kind=I4B), intent(in) :: NTEMP real(kind=dp), intent(out) :: ENERGIES (1:NLEV) real(kind=dp), intent(out) :: WEIGHTS (1:NLEV) real(kind=dp), intent(out) :: A_COEFFS (1:NLEV,1:NLEV) real(kind=dp), intent(out) :: B_COEFFS (1:NLEV,1:NLEV) real(kind=dp), intent(out) :: FREQUENCIES (1:NLEV,1:NLEV) real(kind=dp), intent(out) :: TEMPERATURES (1:7,1:NTEMP) real(kind=dp), intent(out) :: H_COL (1:NLEV,1:NLEV,1:NTEMP) real(kind=dp), intent(out) :: HP_COL (1:NLEV,1:NLEV,1:NTEMP) real(kind=dp), intent(out) :: EL_COL (1:NLEV,1:NLEV,1:NTEMP) real(kind=dp), intent(out) :: HE_COL (1:NLEV,1:NLEV,1:NTEMP) real(kind=dp), intent(out) :: H2_COL (1:NLEV,1:NLEV,1:NTEMP) real(kind=dp), intent(out) :: PH2_COL (1:NLEV,1:NLEV,1:NTEMP) real(kind=dp), intent(out) :: OH2_COL (1:NLEV,1:NLEV,1:NTEMP)","tags":"","url":"proc/readinput.html"},{"title":"writeparams – 3D-PDR","text":"subroutine writeparams() Uses healpix_types maincode_module global_module definitions proc~~writeparams~~UsesGraph proc~writeparams writeparams module~definitions definitions proc~writeparams->module~definitions module~global_module global_module proc~writeparams->module~global_module module~healpix_types~2 healpix_types proc~writeparams->module~healpix_types~2 module~maincode_module maincode_module proc~writeparams->module~maincode_module module~global_module->module~definitions module~global_module->module~healpix_types~2 iso_c_binding iso_c_binding module~global_module->iso_c_binding module~healpix_types~2->module~definitions module~maincode_module->module~definitions module~maincode_module->module~healpix_types~2 module~maincode_module->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments None","tags":"","url":"proc/writeparams.html"},{"title":"writeoutputs – 3D-PDR","text":"subroutine writeoutputs() Uses healpix_types maincode_module global_module proc~~writeoutputs~~UsesGraph proc~writeoutputs writeoutputs module~global_module global_module proc~writeoutputs->module~global_module module~healpix_types~2 healpix_types proc~writeoutputs->module~healpix_types~2 module~maincode_module maincode_module proc~writeoutputs->module~maincode_module module~global_module->module~healpix_types~2 iso_c_binding iso_c_binding module~global_module->iso_c_binding module~definitions definitions module~global_module->module~definitions module~healpix_types~2->module~definitions module~maincode_module->module~healpix_types~2 module~maincode_module->iso_c_binding module~maincode_module->module~definitions Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments None","tags":"","url":"proc/writeoutputs.html"},{"title":"CALCULATE_REACTION_RATES – 3D-PDR","text":"subroutine CALCULATE_REACTION_RATES(TEMPERATURE, DUST_TEMPERATURE, NRAYS, RAD_SURFACE, AV, COLUMN_NH2, COLUMN_NHD, COLUMN_NCO, COLUMN_NC, COLUMN_NS, NREAC, REACTANT, PRODUCT, ALPHA, BETA, GAMMA, rate, RTMIN, RTMAX, DUPLICATE, NSPEC, NRGR, NRH2, NRHD, NRCO, NRCI, NRSI, nelectron, density, ZETALOCAL) Uses healpix_types maincode_module global_module definitions functions_module proc~~calculate_reaction_rates~~UsesGraph proc~calculate_reaction_rates CALCULATE_REACTION_RATES module~definitions definitions proc~calculate_reaction_rates->module~definitions module~functions_module functions_module proc~calculate_reaction_rates->module~functions_module module~global_module global_module proc~calculate_reaction_rates->module~global_module module~healpix_types~2 healpix_types proc~calculate_reaction_rates->module~healpix_types~2 module~maincode_module maincode_module proc~calculate_reaction_rates->module~maincode_module module~functions_module->module~definitions module~functions_module->module~healpix_types~2 module~global_module->module~definitions module~global_module->module~healpix_types~2 iso_c_binding iso_c_binding module~global_module->iso_c_binding module~healpix_types~2->module~definitions module~maincode_module->module~definitions module~maincode_module->module~healpix_types~2 module~maincode_module->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: TEMPERATURE real(kind=dp), intent(in) :: DUST_TEMPERATURE integer(kind=i4b), intent(in) :: NRAYS real(kind=dp), intent(in) :: RAD_SURFACE (0:nrays-1) real(kind=dp), intent(in) :: AV (0:nrays-1) real(kind=dp), intent(in) :: COLUMN_NH2 (0:nrays-1) real(kind=dp), intent(in) :: COLUMN_NHD (0:nrays-1) real(kind=dp), intent(in) :: COLUMN_NCO (0:nrays-1) real(kind=dp), intent(in) :: COLUMN_NC (0:nrays-1) real(kind=dp), intent(in) :: COLUMN_NS (0:nrays-1) integer(kind=i4b), intent(in) :: NREAC character(len=10), intent(in) :: REACTANT (1:nreac,1:3) character(len=10), intent(in) :: PRODUCT (1:nreac,1:4) real(kind=dp), intent(in) :: ALPHA (1:nreac) real(kind=dp), intent(in) :: BETA (1:nreac) real(kind=dp), intent(in) :: GAMMA (1:nreac) real(kind=dp), intent(out) :: rate (1:nreac) real(kind=dp), intent(in) :: RTMIN (1:nreac) real(kind=dp), intent(in) :: RTMAX (1:nreac) integer(kind=i4b), intent(in) :: DUPLICATE (1:nreac) integer(kind=i4b), intent(in) :: NSPEC integer(kind=i4b), intent(out) :: NRGR integer(kind=i4b), intent(out) :: NRH2 integer(kind=i4b), intent(out) :: NRHD integer(kind=i4b), intent(out) :: NRCO integer(kind=i4b), intent(out) :: NRCI integer(kind=i4b), intent(out) :: NRSI real(kind=dp), intent(in) :: nelectron real(kind=dp), intent(in) :: density real(kind=dp), intent(in) :: ZETALOCAL Calls proc~~calculate_reaction_rates~~CallsGraph proc~calculate_reaction_rates CALCULATE_REACTION_RATES interface~cipdrate CIPDRATE proc~calculate_reaction_rates->interface~cipdrate interface~copdrate COPDRATE proc~calculate_reaction_rates->interface~copdrate interface~h2pdrate H2PDRATE proc~calculate_reaction_rates->interface~h2pdrate interface~sipdrate SIPDRATE proc~calculate_reaction_rates->interface~sipdrate Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/calculate_reaction_rates.html"},{"title":"H2_FORMATION_RATE – 3D-PDR","text":"function H2_FORMATION_RATE(GAS_TEMPERATURE, GRAIN_TEMPERATURE) result(RATE) Uses healpix_types global_module definitions proc~~h2_formation_rate~~UsesGraph proc~h2_formation_rate H2_FORMATION_RATE module~definitions definitions proc~h2_formation_rate->module~definitions module~global_module global_module proc~h2_formation_rate->module~global_module module~healpix_types~2 healpix_types proc~h2_formation_rate->module~healpix_types~2 module~global_module->module~definitions module~global_module->module~healpix_types~2 iso_c_binding iso_c_binding module~global_module->iso_c_binding module~healpix_types~2->module~definitions Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. $!  Use the tradional rate, with a simple temperature dependence based on the\n$!  thermal velocity of the H atoms in the gas and neglecting any temperature\n$!  dependency of the formation and sticking efficiencies\n$   RATE=3.0D-18*SQRT(GAS_TEMPERATURE) $!  Use the treatment of de Jong (1977, A&A, 55, 137, p140 right column).\n$!  The second exponential dependence on the gas temperature reduces the\n$!  efficiency at high temperatures and so prevents runaway H2 formation\n$!  heating at high temperatures:\n$!\n$!  k_H2 = 3E-18 * T&#94;0.5 * exp(-T/1000)   [cm3/s]\n$!\n$   RATE=3.0D-18 SQRT(GAS_TEMPERATURE) EXP(-(GAS_TEMPERATURE/1.0D3)) $!  Use the treatment of Tielens & Hollenbach (1985, ApJ, 291, 722, eqn 4)\n$   RATE=0.5D0 THERMAL_VELOCITY TOTAL_CROSS_SECTION*STICKING_COEFFICIENT $!  Use the expression given by Markus Rollig during the February 2012 Leiden workshop\n$   RATE=0.5D0 THERMAL_VELOCITY &\n$      & (SILICATE_CROSS_SECTION/((1.0D0 + 6.998D24/EXP(1.5 SILICATE_E_HC/GRAIN_TEMPERATURE)) &\n$      & (1.0D0 + 1.0D0/(EXP(SILICATE_E_HP/GRAIN_TEMPERATURE) &\n$      & (0.427D0/EXP((SILICATE_E_HP-SILICATE_E_S)/GRAIN_TEMPERATURE) + 2.5336D-14 SQRT(GRAIN_TEMPERATURE))))) &\n$      & + GRAPHITE_CROSS_SECTION/((1.0D0 + 4.610D24/EXP(1.5 GRAPHITE_E_HC/GRAIN_TEMPERATURE)) &\n$      & (1.0D0 + 1.0D0/(EXP(GRAPHITE_E_HP/GRAIN_TEMPERATURE) &\n$      & (0.539D0/EXP((GRAPHITE_E_HP-GRAPHITE_E_S)/GRAIN_TEMPERATURE) + 5.6334D-14 SQRT(GRAIN_TEMPERATURE)))))) &\n$      & *STICKING_COEFFICIENT Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: GAS_TEMPERATURE real(kind=DP), intent(in) :: GRAIN_TEMPERATURE Return Value real(kind=DP)","tags":"","url":"proc/h2_formation_rate.html"},{"title":"writeoutputs – 3D-PDR","text":"subroutine writeoutputs() Uses healpix_types hdf5 maincode_module global_module proc~~writeoutputs~2~~UsesGraph proc~writeoutputs~2 writeoutputs hdf5 hdf5 proc~writeoutputs~2->hdf5 module~global_module global_module proc~writeoutputs~2->module~global_module module~healpix_types~2 healpix_types proc~writeoutputs~2->module~healpix_types~2 module~maincode_module maincode_module proc~writeoutputs~2->module~maincode_module module~global_module->module~healpix_types~2 iso_c_binding iso_c_binding module~global_module->iso_c_binding module~definitions definitions module~global_module->module~definitions module~healpix_types~2->module~definitions module~maincode_module->module~healpix_types~2 module~maincode_module->iso_c_binding module~maincode_module->module~definitions Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments None Calls proc~~writeoutputs~2~~CallsGraph proc~writeoutputs~2 writeoutputs h5dclose_f h5dclose_f proc~writeoutputs~2->h5dclose_f h5dcreate_f h5dcreate_f proc~writeoutputs~2->h5dcreate_f h5dwrite_f h5dwrite_f proc~writeoutputs~2->h5dwrite_f h5fclose_f h5fclose_f proc~writeoutputs~2->h5fclose_f h5fcreate_f h5fcreate_f proc~writeoutputs~2->h5fcreate_f h5open_f h5open_f proc~writeoutputs~2->h5open_f h5screate_simple_f h5screate_simple_f proc~writeoutputs~2->h5screate_simple_f h5tcopy_f h5tcopy_f proc~writeoutputs~2->h5tcopy_f h5tset_size_f h5tset_size_f proc~writeoutputs~2->h5tset_size_f Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/writeoutputs~2.html"},{"title":"calc_CRattenuation – 3D-PDR","text":"subroutine calc_CRattenuation() Uses healpix_types maincode_module global_module proc~~calc_crattenuation~~UsesGraph proc~calc_crattenuation calc_CRattenuation module~global_module global_module proc~calc_crattenuation->module~global_module module~healpix_types~2 healpix_types proc~calc_crattenuation->module~healpix_types~2 module~maincode_module maincode_module proc~calc_crattenuation->module~maincode_module module~global_module->module~healpix_types~2 iso_c_binding iso_c_binding module~global_module->iso_c_binding module~definitions definitions module~global_module->module~definitions module~healpix_types~2->module~definitions module~maincode_module->module~healpix_types~2 module~maincode_module->iso_c_binding module~maincode_module->module~definitions Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments None","tags":"","url":"proc/calc_crattenuation.html"},{"title":"read_command_line – 3D-PDR","text":"subroutine read_command_line() Uses maincode_module definitions proc~~read_command_line~~UsesGraph proc~read_command_line read_command_line module~definitions definitions proc~read_command_line->module~definitions module~maincode_module maincode_module proc~read_command_line->module~maincode_module module~maincode_module->module~definitions iso_c_binding iso_c_binding module~maincode_module->iso_c_binding module~healpix_types~2 healpix_types module~maincode_module->module~healpix_types~2 module~healpix_types~2->module~definitions Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments None","tags":"","url":"proc/read_command_line.html"},{"title":"allocations – 3D-PDR","text":"subroutine allocations() Uses healpix_types maincode_module global_module uclpdr_module proc~~allocations~~UsesGraph proc~allocations allocations module~global_module global_module proc~allocations->module~global_module module~healpix_types~2 healpix_types proc~allocations->module~healpix_types~2 module~maincode_module maincode_module proc~allocations->module~maincode_module module~uclpdr_module uclpdr_module proc~allocations->module~uclpdr_module module~global_module->module~healpix_types~2 iso_c_binding iso_c_binding module~global_module->iso_c_binding module~definitions definitions module~global_module->module~definitions module~healpix_types~2->module~definitions module~maincode_module->module~healpix_types~2 module~maincode_module->iso_c_binding module~maincode_module->module~definitions module~uclpdr_module->module~healpix_types~2 module~uclpdr_module->module~definitions Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments None","tags":"","url":"proc/allocations.html"},{"title":"CALCULATE_LTE_POPULATIONS – 3D-PDR","text":"subroutine CALCULATE_LTE_POPULATIONS(NLEV, LEVEL_POP, ENERGIES, WEIGHTS, PARTITION_FUNCTION, DENSITY, TEMPERATURE) Uses healpix_types proc~~calculate_lte_populations~~UsesGraph proc~calculate_lte_populations CALCULATE_LTE_POPULATIONS module~healpix_types~2 healpix_types proc~calculate_lte_populations->module~healpix_types~2 module~definitions definitions module~healpix_types~2->module~definitions Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: NLEV real(kind=DP), intent(out) :: LEVEL_POP (1:NLEV) real(kind=DP), intent(in) :: ENERGIES (1:NLEV) real(kind=DP), intent(in) :: WEIGHTS (1:NLEV) real(kind=DP), intent(in) :: PARTITION_FUNCTION real(kind=DP), intent(in) :: DENSITY real(kind=DP), intent(in) :: TEMPERATURE","tags":"","url":"proc/calculate_lte_populations.html"},{"title":"calc_columndens – 3D-PDR","text":"subroutine calc_columndens() Uses healpix_types m_Ray_box maincode_module global_module proc~~calc_columndens~~UsesGraph proc~calc_columndens calc_columndens module~global_module global_module proc~calc_columndens->module~global_module module~healpix_types~2 healpix_types proc~calc_columndens->module~healpix_types~2 module~m_ray_box m_Ray_box proc~calc_columndens->module~m_ray_box module~maincode_module maincode_module proc~calc_columndens->module~maincode_module module~global_module->module~healpix_types~2 iso_c_binding iso_c_binding module~global_module->iso_c_binding module~definitions definitions module~global_module->module~definitions module~healpix_types~2->module~definitions module~m_mesh m_Mesh module~m_ray_box->module~m_mesh module~maincode_module->module~healpix_types~2 module~maincode_module->iso_c_binding module~maincode_module->module~definitions Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments None","tags":"","url":"proc/calc_columndens.html"},{"title":"H2PDRATE – 3D-PDR","text":"function H2PDRATE(k0, g0, av, nh2) Uses healpix_types maincode_module definitions proc~~h2pdrate~~UsesGraph proc~h2pdrate H2PDRATE module~definitions definitions proc~h2pdrate->module~definitions module~healpix_types~2 healpix_types proc~h2pdrate->module~healpix_types~2 module~maincode_module maincode_module proc~h2pdrate->module~maincode_module module~healpix_types~2->module~definitions module~maincode_module->module~definitions module~maincode_module->module~healpix_types~2 iso_c_binding iso_c_binding module~maincode_module->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. C      DOUBLE PRECISION DOPW,RADW\nC      DOUBLE PRECISION H2SHIELD1 Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: k0 real(kind=dp), intent(in) :: g0 real(kind=dp), intent(in) :: av real(kind=dp), intent(in) :: nh2 Return Value real(kind=dp)","tags":"","url":"proc/h2pdrate.html"},{"title":"COPDRATE – 3D-PDR","text":"function COPDRATE(k0, g0, av, nco, nh2) result(copdrate) Uses healpix_types definitions proc~~copdrate~~UsesGraph proc~copdrate COPDRATE module~definitions definitions proc~copdrate->module~definitions module~healpix_types~2 healpix_types proc~copdrate->module~healpix_types~2 module~healpix_types~2->module~definitions Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: k0 real(kind=dp), intent(in) :: g0 real(kind=dp), intent(in) :: av real(kind=dp), intent(in) :: nco real(kind=dp), intent(in) :: nh2 Return Value real(kind=dp)","tags":"","url":"proc/copdrate.html"},{"title":"CIPDRATE – 3D-PDR","text":"function CIPDRATE(K0, G0, AV, KAV, NCI, nh2, TGAS) result(cipdrate) Uses healpix_types definitions proc~~cipdrate~~UsesGraph proc~cipdrate CIPDRATE module~definitions definitions proc~cipdrate->module~definitions module~healpix_types~2 healpix_types proc~cipdrate->module~healpix_types~2 module~healpix_types~2->module~definitions Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: K0 real(kind=dp), intent(in) :: G0 real(kind=dp), intent(in) :: AV real(kind=dp), intent(in) :: KAV real(kind=dp), intent(in) :: NCI real(kind=dp), intent(in) :: nh2 real(kind=dp), intent(in) :: TGAS Return Value real(kind=dp)","tags":"","url":"proc/cipdrate.html"},{"title":"SIPDRATE – 3D-PDR","text":"function SIPDRATE(K0, G0, AV, KAV) result(sipdrate) Uses healpix_types definitions proc~~sipdrate~~UsesGraph proc~sipdrate SIPDRATE module~definitions definitions proc~sipdrate->module~definitions module~healpix_types~2 healpix_types proc~sipdrate->module~healpix_types~2 module~healpix_types~2->module~definitions Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: K0 real(kind=dp), intent(in) :: G0 real(kind=dp), intent(in) :: AV real(kind=dp), intent(in) :: KAV Return Value real(kind=dp)","tags":"","url":"proc/sipdrate.html"},{"title":"H2SHIELD1 – 3D-PDR","text":"function H2SHIELD1(nh2, DOPW, RADW) result(h2shield1) Uses healpix_types definitions proc~~h2shield1~~UsesGraph proc~h2shield1 H2SHIELD1 module~definitions definitions proc~h2shield1->module~definitions module~healpix_types~2 healpix_types proc~h2shield1->module~healpix_types~2 module~healpix_types~2->module~definitions Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: nh2 real(kind=dp), intent(in) :: DOPW real(kind=dp), intent(in) :: RADW Return Value real(kind=dp)","tags":"","url":"proc/h2shield1.html"},{"title":"H2SHIELD2 – 3D-PDR","text":"function H2SHIELD2(nh2) result(h2shield2) Uses healpix_types definitions uclpdr_module proc~~h2shield2~~UsesGraph proc~h2shield2 H2SHIELD2 module~definitions definitions proc~h2shield2->module~definitions module~healpix_types~2 healpix_types proc~h2shield2->module~healpix_types~2 module~uclpdr_module uclpdr_module proc~h2shield2->module~uclpdr_module module~healpix_types~2->module~definitions module~uclpdr_module->module~definitions module~uclpdr_module->module~healpix_types~2 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: nh2 Return Value real(kind=dp) Calls proc~~h2shield2~~CallsGraph proc~h2shield2 H2SHIELD2 spline spline proc~h2shield2->spline splint splint proc~h2shield2->splint Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/h2shield2.html"},{"title":"COSHIELD – 3D-PDR","text":"function COSHIELD(nco, nh2) Uses healpix_types definitions uclpdr_module proc~~coshield~~UsesGraph proc~coshield COSHIELD module~definitions definitions proc~coshield->module~definitions module~healpix_types~2 healpix_types proc~coshield->module~healpix_types~2 module~uclpdr_module uclpdr_module proc~coshield->module~uclpdr_module module~healpix_types~2->module~definitions module~uclpdr_module->module~definitions module~uclpdr_module->module~healpix_types~2 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: nco real(kind=dp), intent(in) :: nh2 Return Value real(kind=dp) Calls proc~~coshield~~CallsGraph proc~coshield COSHIELD splie2 splie2 proc~coshield->splie2 splin2 splin2 proc~coshield->splin2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/coshield.html"},{"title":"SCATTER – 3D-PDR","text":"function SCATTER(AV, LAMBDA) result(scatter) Uses healpix_types definitions proc~~scatter~~UsesGraph proc~scatter SCATTER module~definitions definitions proc~scatter->module~definitions module~healpix_types~2 healpix_types proc~scatter->module~healpix_types~2 module~healpix_types~2->module~definitions Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: AV real(kind=dp), intent(in) :: LAMBDA Return Value real(kind=dp)","tags":"","url":"proc/scatter.html"},{"title":"XLAMBDA – 3D-PDR","text":"function XLAMBDA(lambda) result(xlambda) Uses healpix_types definitions uclpdr_module proc~~xlambda~~UsesGraph proc~xlambda XLAMBDA module~definitions definitions proc~xlambda->module~definitions module~healpix_types~2 healpix_types proc~xlambda->module~healpix_types~2 module~uclpdr_module uclpdr_module proc~xlambda->module~uclpdr_module module~healpix_types~2->module~definitions module~uclpdr_module->module~definitions module~uclpdr_module->module~healpix_types~2 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: lambda Return Value real(kind=dp) Calls proc~~xlambda~~CallsGraph proc~xlambda XLAMBDA spline spline proc~xlambda->spline splint splint proc~xlambda->splint Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/xlambda.html"},{"title":"LBAR – 3D-PDR","text":"function LBAR(nco, nh2) result(lbar) Uses healpix_types definitions proc~~lbar~~UsesGraph proc~lbar LBAR module~definitions definitions proc~lbar->module~definitions module~healpix_types~2 healpix_types proc~lbar->module~healpix_types~2 module~healpix_types~2->module~definitions Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: nco real(kind=dp), intent(in) :: nh2 Return Value real(kind=dp)","tags":"","url":"proc/lbar.html"},{"title":"escape_probability – 3D-PDR","text":"subroutine escape_probability(transition, dust_temperature, nrays, nlev, A_COEFFS, B_COEFFS, C_COEFFS, frequencies, s_evalpop, maxpoints, Tguess, v_turb, s_jjr, s_pop, s_evalpoint, weights, cooling_rate, line, density, metallicity, molmass) Uses healpix_types maincode_module m_Ray_box healpix_module definitions m_Mesh proc~~escape_probability~~UsesGraph proc~escape_probability escape_probability module~definitions definitions proc~escape_probability->module~definitions module~healpix_module healpix_module proc~escape_probability->module~healpix_module module~healpix_types~2 healpix_types proc~escape_probability->module~healpix_types~2 module~m_mesh m_Mesh proc~escape_probability->module~m_mesh module~m_ray_box m_Ray_box proc~escape_probability->module~m_ray_box module~maincode_module maincode_module proc~escape_probability->module~maincode_module module~healpix_module->module~definitions module~healpix_module->module~healpix_types~2 module~healpix_types~2->module~definitions module~m_ray_box->module~m_mesh module~maincode_module->module~definitions module~maincode_module->module~healpix_types~2 iso_c_binding iso_c_binding module~maincode_module->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: transition (1:nlev,1:nlev) real(kind=dp), intent(in) :: dust_temperature integer(kind=i4b), intent(in) :: nrays integer(kind=i4b), intent(in) :: nlev real(kind=dp), intent(in) :: A_COEFFS (1:nlev,1:nlev) real(kind=dp), intent(in) :: B_COEFFS (1:nlev,1:nlev) real(kind=dp), intent(in) :: C_COEFFS (1:nlev,1:nlev) real(kind=dp), intent(in) :: frequencies (1:nlev,1:nlev) real(kind=dp), intent(in) :: s_evalpop (0:nrays-1,0:maxpoints,1:nlev) integer(kind=i4b), intent(in) :: maxpoints real(kind=dp), intent(in) :: Tguess real(kind=dp), intent(in) :: v_turb integer(kind=i4b), intent(in) :: s_jjr (0:nrays-1) real(kind=dp), intent(in) :: s_pop (1:nlev) real(kind=dp), intent(in) :: s_evalpoint (1:3,0:nrays-1,0:maxpoints) real(kind=dp), intent(in) :: weights (1:nlev) real(kind=dp), intent(out) :: cooling_rate real(kind=dp), intent(out) :: line (1:nlev,1:nlev) real(kind=dp), intent(in) :: density real(kind=dp), intent(in) :: metallicity real(kind=dp), intent(in) :: molmass","tags":"","url":"proc/escape_probability.html"},{"title":"mk_xy2pix – 3D-PDR","text":"subroutine mk_xy2pix() Uses healpix_types healpix_module definitions proc~~mk_xy2pix~~UsesGraph proc~mk_xy2pix mk_xy2pix module~definitions definitions proc~mk_xy2pix->module~definitions module~healpix_module healpix_module proc~mk_xy2pix->module~healpix_module module~healpix_types~2 healpix_types proc~mk_xy2pix->module~healpix_types~2 module~healpix_module->module~definitions module~healpix_module->module~healpix_types~2 module~healpix_types~2->module~definitions Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments None","tags":"","url":"proc/mk_xy2pix.html"},{"title":"pix2vec_nest – 3D-PDR","text":"subroutine pix2vec_nest(nside, ipix, pix2x, pix2y, vector, vertex) Uses healpix_types healpix_module definitions proc~~pix2vec_nest~~UsesGraph proc~pix2vec_nest pix2vec_nest module~definitions definitions proc~pix2vec_nest->module~definitions module~healpix_module healpix_module proc~pix2vec_nest->module~healpix_module module~healpix_types~2 healpix_types proc~pix2vec_nest->module~healpix_types~2 module~healpix_module->module~definitions module~healpix_module->module~healpix_types~2 module~healpix_types~2->module~definitions Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: nside integer(kind=I4B), intent(in) :: ipix integer(kind=i4b), intent(in) :: pix2x (0:1023) integer(kind=i4b), intent(in) :: pix2y (0:1023) real(kind=DP), intent(out) :: vector (1:3) real(kind=DP), intent(out) :: vertex (1:3,1:4) Calls proc~~pix2vec_nest~~CallsGraph proc~pix2vec_nest pix2vec_nest mk_pix2xy mk_pix2xy proc~pix2vec_nest->mk_pix2xy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/pix2vec_nest.html"},{"title":"mk_pix2xy – 3D-PDR","text":"subroutine mk_pix2xy() Uses healpix_types healpix_module definitions proc~~mk_pix2xy~~UsesGraph proc~mk_pix2xy mk_pix2xy module~definitions definitions proc~mk_pix2xy->module~definitions module~healpix_module healpix_module proc~mk_pix2xy->module~healpix_module module~healpix_types~2 healpix_types proc~mk_pix2xy->module~healpix_types~2 module~healpix_module->module~definitions module~healpix_module->module~healpix_types~2 module~healpix_types~2->module~definitions Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments None","tags":"","url":"proc/mk_pix2xy.html"},{"title":"vec2ang – 3D-PDR","text":"subroutine vec2ang(rvec, theta, phi) Uses healpix_types definitions proc~~vec2ang~~UsesGraph proc~vec2ang vec2ang module~definitions definitions proc~vec2ang->module~definitions module~healpix_types~2 healpix_types proc~vec2ang->module~healpix_types~2 module~healpix_types~2->module~definitions Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: rvec (1:3) real(kind=DP), intent(out) :: theta real(kind=DP), intent(out) :: phi","tags":"","url":"proc/vec2ang.html"},{"title":"ang2pix_nest_id – 3D-PDR","text":"subroutine ang2pix_nest_id(nside, theta, phi, ipix) Uses healpix_types healpix_module definitions proc~~ang2pix_nest_id~~UsesGraph proc~ang2pix_nest_id ang2pix_nest_id module~definitions definitions proc~ang2pix_nest_id->module~definitions module~healpix_module healpix_module proc~ang2pix_nest_id->module~healpix_module module~healpix_types~2 healpix_types proc~ang2pix_nest_id->module~healpix_types~2 module~healpix_module->module~definitions module~healpix_module->module~healpix_types~2 module~healpix_types~2->module~definitions Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: nside real(kind=DP), intent(in) :: theta real(kind=DP), intent(in) :: phi integer(kind=I4B), intent(out) :: ipix Calls proc~~ang2pix_nest_id~~CallsGraph proc~ang2pix_nest_id ang2pix_nest_id mk_xy2pix mk_xy2pix proc~ang2pix_nest_id->mk_xy2pix Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/ang2pix_nest_id.html"},{"title":"pix2ang_nest – 3D-PDR","text":"subroutine pix2ang_nest(nside, ipix, theta, phi) Uses healpix_types healpix_module definitions proc~~pix2ang_nest~~UsesGraph proc~pix2ang_nest pix2ang_nest module~definitions definitions proc~pix2ang_nest->module~definitions module~healpix_module healpix_module proc~pix2ang_nest->module~healpix_module module~healpix_types~2 healpix_types proc~pix2ang_nest->module~healpix_types~2 module~healpix_module->module~definitions module~healpix_module->module~healpix_types~2 module~healpix_types~2->module~definitions Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: nside integer(kind=MKD), intent(in) :: ipix real(kind=DP), intent(out) :: theta real(kind=DP), intent(out) :: phi Calls proc~~pix2ang_nest~~CallsGraph proc~pix2ang_nest pix2ang_nest mk_pix2xy mk_pix2xy proc~pix2ang_nest->mk_pix2xy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/pix2ang_nest.html"},{"title":"ANALYSE_CHEMISTRY – 3D-PDR","text":"subroutine ANALYSE_CHEMISTRY(GRIDPOINT, TIME, DENSITY, TEMPERATURE, NRAYS, AV, NSPEC, SPECIES, ABUNDANCE, NREAC, REACTANT, PRODUCT, RATE) Uses healpix_types global_module definitions proc~~analyse_chemistry~~UsesGraph proc~analyse_chemistry ANALYSE_CHEMISTRY module~definitions definitions proc~analyse_chemistry->module~definitions module~global_module global_module proc~analyse_chemistry->module~global_module module~healpix_types~2 healpix_types proc~analyse_chemistry->module~healpix_types~2 module~global_module->module~definitions module~global_module->module~healpix_types~2 iso_c_binding iso_c_binding module~global_module->iso_c_binding module~healpix_types~2->module~definitions Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: GRIDPOINT real(kind=DP), intent(in) :: TIME real(kind=DP), intent(in) :: DENSITY real(kind=DP), intent(in) :: TEMPERATURE integer(kind=I4B), intent(in) :: NRAYS real(kind=DP), intent(in) :: AV integer(kind=I4B), intent(in) :: NSPEC character(len=10), intent(in) :: SPECIES (1:NSPEC) real(kind=DP), intent(in) :: ABUNDANCE (1:NSPEC) integer(kind=I4B), intent(in) :: NREAC character(len=10), intent(in) :: REACTANT (1:NREAC,1:3) character(len=10), intent(in) :: PRODUCT (1:NREAC,1:4) real(kind=DP), intent(in) :: RATE (1:NREAC) Calls proc~~analyse_chemistry~~CallsGraph proc~analyse_chemistry ANALYSE_CHEMISTRY 80 80 proc~analyse_chemistry->80 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/analyse_chemistry.html"},{"title":"CALCULATE_PARTITION_FUNCTION – 3D-PDR","text":"subroutine CALCULATE_PARTITION_FUNCTION(PARTITION_FUNCTION, NLEV, ENERGIES, WEIGHTS, TEMPERATURE) Uses healpix_types proc~~calculate_partition_function~~UsesGraph proc~calculate_partition_function CALCULATE_PARTITION_FUNCTION module~healpix_types~2 healpix_types proc~calculate_partition_function->module~healpix_types~2 module~definitions definitions module~healpix_types~2->module~definitions Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(out) :: PARTITION_FUNCTION integer(kind=I4B), intent(in) :: NLEV real(kind=DP), intent(in) :: ENERGIES (1:NLEV) real(kind=DP), intent(in) :: WEIGHTS (1:NLEV) real(kind=DP), intent(in) :: TEMPERATURE","tags":"","url":"proc/calculate_partition_function.html"},{"title":"heapsort – 3D-PDR","text":"subroutine heapsort(pp_pot, plist, rlist) Uses healpix_types definitions proc~~heapsort~~UsesGraph proc~heapsort heapsort module~definitions definitions proc~heapsort->module~definitions module~healpix_types~2 healpix_types proc~heapsort->module~healpix_types~2 module~healpix_types~2->module~definitions Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=i4b), intent(in) :: pp_pot integer(kind=i4b), intent(inout), dimension(1:pp_pot+1) :: plist real(kind=dp), intent(inout), dimension(0:pp_pot+1) :: rlist","tags":"","url":"proc/heapsort.html"},{"title":"READ_SPECIES – 3D-PDR","text":"subroutine READ_SPECIES(NSPEC, SPECIES, ABUNDANCE, MASS) Uses healpix_types global_module definitions maincode_module proc~~read_species~~UsesGraph proc~read_species READ_SPECIES module~definitions definitions proc~read_species->module~definitions module~global_module global_module proc~read_species->module~global_module module~healpix_types~2 healpix_types proc~read_species->module~healpix_types~2 module~maincode_module maincode_module proc~read_species->module~maincode_module module~global_module->module~definitions module~global_module->module~healpix_types~2 iso_c_binding iso_c_binding module~global_module->iso_c_binding module~healpix_types~2->module~definitions module~maincode_module->module~definitions module~maincode_module->module~healpix_types~2 module~maincode_module->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=i4b), intent(in) :: NSPEC character(len=10), intent(out) :: SPECIES (1:nspec) real(kind=dp), intent(out) :: ABUNDANCE (1:nspec) real(kind=dp), intent(out) :: MASS (1:nspec)","tags":"","url":"proc/read_species.html"},{"title":"initialization – 3D-PDR","text":"subroutine initialization() Uses maincode_module proc~~initialization~~UsesGraph proc~initialization initialization module~maincode_module maincode_module proc~initialization->module~maincode_module iso_c_binding iso_c_binding module~maincode_module->iso_c_binding module~definitions definitions module~maincode_module->module~definitions module~healpix_types~2 healpix_types module~maincode_module->module~healpix_types~2 module~healpix_types~2->module~definitions Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments None","tags":"","url":"proc/initialization.html"},{"title":"CALCULATE_DUST_TEMPERATURES – 3D-PDR","text":"subroutine CALCULATE_DUST_TEMPERATURES() Uses healpix_types maincode_module proc~~calculate_dust_temperatures~~UsesGraph proc~calculate_dust_temperatures CALCULATE_DUST_TEMPERATURES module~healpix_types~2 healpix_types proc~calculate_dust_temperatures->module~healpix_types~2 module~maincode_module maincode_module proc~calculate_dust_temperatures->module~maincode_module module~definitions definitions module~healpix_types~2->module~definitions module~maincode_module->module~healpix_types~2 iso_c_binding iso_c_binding module~maincode_module->iso_c_binding module~maincode_module->module~definitions Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments None","tags":"","url":"proc/calculate_dust_temperatures.html"},{"title":"checkconvergence – 3D-PDR","text":"subroutine checkconvergence() Uses healpix_types maincode_module global_module proc~~checkconvergence~~UsesGraph proc~checkconvergence checkconvergence module~global_module global_module proc~checkconvergence->module~global_module module~healpix_types~2 healpix_types proc~checkconvergence->module~healpix_types~2 module~maincode_module maincode_module proc~checkconvergence->module~maincode_module module~global_module->module~healpix_types~2 iso_c_binding iso_c_binding module~global_module->iso_c_binding module~definitions definitions module~global_module->module~definitions module~healpix_types~2->module~definitions module~maincode_module->module~healpix_types~2 module~maincode_module->iso_c_binding module~maincode_module->module~definitions Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments None","tags":"","url":"proc/checkconvergence.html"},{"title":"SPLIE2 – 3D-PDR","text":"subroutine SPLIE2(X1A, X2A, YA, M, N, Y2A) Uses healpix_types definitions proc~~splie2~~UsesGraph proc~splie2 SPLIE2 module~definitions definitions proc~splie2->module~definitions module~healpix_types~2 healpix_types proc~splie2->module~healpix_types~2 module~healpix_types~2->module~definitions Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: X1A (1:M) real(kind=DP), intent(in) :: X2A (1:N) real(kind=DP), intent(in) :: YA (1:M,1:N) integer(kind=I4B), intent(in) :: M integer(kind=I4B), intent(in) :: N real(kind=DP), intent(out) :: Y2A (1:M,1:N) Calls proc~~splie2~~CallsGraph proc~splie2 SPLIE2 spline spline proc~splie2->spline Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/splie2.html"},{"title":"SPLINE – 3D-PDR","text":"subroutine SPLINE(X, Y, N, YP1, YPN, Y2) Uses healpix_types definitions proc~~spline~~UsesGraph proc~spline SPLINE module~definitions definitions proc~spline->module~definitions module~healpix_types~2 healpix_types proc~spline->module~healpix_types~2 module~healpix_types~2->module~definitions Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: X (1:N) real(kind=DP), intent(in) :: Y (1:N) integer(kind=I4B), intent(in) :: N real(kind=DP), intent(in) :: YP1 real(kind=DP), intent(in) :: YPN real(kind=DP), intent(out) :: Y2 (1:N)","tags":"","url":"proc/spline.html"},{"title":"SPLIN2 – 3D-PDR","text":"subroutine SPLIN2(X1A, X2A, YA, Y2A, M, N, X1, X2, Y) Uses healpix_types definitions proc~~splin2~~UsesGraph proc~splin2 SPLIN2 module~definitions definitions proc~splin2->module~definitions module~healpix_types~2 healpix_types proc~splin2->module~healpix_types~2 module~healpix_types~2->module~definitions Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: X1A (1:M) real(kind=DP), intent(in) :: X2A (1:N) real(kind=DP), intent(in) :: YA (1:M,1:N) real(kind=DP), intent(in) :: Y2A (1:M,1:N) integer(kind=I4B), intent(in) :: M integer(kind=I4B), intent(in) :: N real(kind=DP), intent(in) :: X1 real(kind=DP), intent(in) :: X2 real(kind=DP), intent(out) :: Y Calls proc~~splin2~~CallsGraph proc~splin2 SPLIN2 spline spline proc~splin2->spline splint splint proc~splin2->splint Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/splin2.html"},{"title":"SPLINT – 3D-PDR","text":"subroutine SPLINT(XA, YA, Y2A, N, X, Y) Uses healpix_types definitions proc~~splint~~UsesGraph proc~splint SPLINT module~definitions definitions proc~splint->module~definitions module~healpix_types~2 healpix_types proc~splint->module~healpix_types~2 module~healpix_types~2->module~definitions Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: XA (1:N) real(kind=DP), intent(in) :: YA (1:N) real(kind=DP), intent(in) :: Y2A (1:N) integer(kind=I4B), intent(in) :: N real(kind=DP), intent(in) :: X real(kind=DP), intent(out) :: Y","tags":"","url":"proc/splint.html"},{"title":"evaluation_points – 3D-PDR","text":"subroutine evaluation_points() Uses healpix_types maincode_module m_Ray_box healpix_module definitions m_Mesh proc~~evaluation_points~~UsesGraph proc~evaluation_points evaluation_points module~definitions definitions proc~evaluation_points->module~definitions module~healpix_module healpix_module proc~evaluation_points->module~healpix_module module~healpix_types~2 healpix_types proc~evaluation_points->module~healpix_types~2 module~m_mesh m_Mesh proc~evaluation_points->module~m_mesh module~m_ray_box m_Ray_box proc~evaluation_points->module~m_ray_box module~maincode_module maincode_module proc~evaluation_points->module~maincode_module module~healpix_module->module~definitions module~healpix_module->module~healpix_types~2 module~healpix_types~2->module~definitions module~m_ray_box->module~m_mesh module~maincode_module->module~definitions module~maincode_module->module~healpix_types~2 iso_c_binding iso_c_binding module~maincode_module->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments None Calls proc~~evaluation_points~~CallsGraph proc~evaluation_points evaluation_points ang2pix_nest_id ang2pix_nest_id proc~evaluation_points->ang2pix_nest_id heapsort heapsort proc~evaluation_points->heapsort vec2ang vec2ang proc~evaluation_points->vec2ang Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/evaluation_points.html"},{"title":"READ_RATES – 3D-PDR","text":"subroutine READ_RATES(NREAC, REAC, PROD, ALPHA, BETA, GAMMA, RATE, DUPLICATE, RTMIN, RTMAX) Uses healpix_types global_module definitions proc~~read_rates~~UsesGraph proc~read_rates READ_RATES module~definitions definitions proc~read_rates->module~definitions module~global_module global_module proc~read_rates->module~global_module module~healpix_types~2 healpix_types proc~read_rates->module~healpix_types~2 module~global_module->module~definitions module~global_module->module~healpix_types~2 iso_c_binding iso_c_binding module~global_module->iso_c_binding module~healpix_types~2->module~definitions Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=i4b), intent(in) :: NREAC character(len=10), intent(out) :: REAC (1:nreac,1:3) character(len=10), intent(out) :: PROD (1:nreac,1:4) real(kind=dp), intent(out) :: ALPHA (1:nreac) real(kind=dp), intent(out) :: BETA (1:nreac) real(kind=dp), intent(out) :: GAMMA (1:nreac) real(kind=dp), intent(out) :: RATE (1:nreac) integer(kind=i4b), intent(out) :: DUPLICATE (1:nreac) real(kind=dp), intent(out) :: RTMIN (1:nreac) real(kind=dp), intent(out) :: RTMAX (1:nreac)","tags":"","url":"proc/read_rates.html"},{"title":"coolingfunctions – 3D-PDR","text":"subroutine coolingfunctions() Uses healpix_types m_Ray_box maincode_module global_module proc~~coolingfunctions~~UsesGraph proc~coolingfunctions coolingfunctions module~global_module global_module proc~coolingfunctions->module~global_module module~healpix_types~2 healpix_types proc~coolingfunctions->module~healpix_types~2 module~m_ray_box m_Ray_box proc~coolingfunctions->module~m_ray_box module~maincode_module maincode_module proc~coolingfunctions->module~maincode_module module~global_module->module~healpix_types~2 iso_c_binding iso_c_binding module~global_module->iso_c_binding module~definitions definitions module~global_module->module~definitions module~healpix_types~2->module~definitions module~m_mesh m_Mesh module~m_ray_box->module~m_mesh module~maincode_module->module~healpix_types~2 module~maincode_module->iso_c_binding module~maincode_module->module~definitions Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments None Calls proc~~coolingfunctions~~CallsGraph proc~coolingfunctions coolingfunctions escape_probability escape_probability proc~coolingfunctions->escape_probability find_ccoeff find_ccoeff proc~coolingfunctions->find_ccoeff solvlevpop solvlevpop proc~coolingfunctions->solvlevpop Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/coolingfunctions.html"},{"title":"chemicaliterations – 3D-PDR","text":"subroutine chemicaliterations(iw, ichem) Uses healpix_types maincode_module global_module maincode_local proc~~chemicaliterations~~UsesGraph proc~chemicaliterations chemicaliterations module~global_module global_module proc~chemicaliterations->module~global_module module~healpix_types~2 healpix_types proc~chemicaliterations->module~healpix_types~2 module~maincode_local maincode_local proc~chemicaliterations->module~maincode_local module~maincode_module maincode_module proc~chemicaliterations->module~maincode_module module~global_module->module~healpix_types~2 iso_c_binding iso_c_binding module~global_module->iso_c_binding module~definitions definitions module~global_module->module~definitions module~healpix_types~2->module~definitions module~maincode_local->module~healpix_types~2 module~maincode_local->module~definitions module~maincode_module->module~healpix_types~2 module~maincode_module->iso_c_binding module~maincode_module->module~definitions Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name integer, intent(in) :: iw integer, intent(in) :: ichem Calls proc~~chemicaliterations~~CallsGraph proc~chemicaliterations chemicaliterations calc_columndens calc_columndens proc~chemicaliterations->calc_columndens calculate_abundances calculate_abundances proc~chemicaliterations->calculate_abundances calculate_lte_populations calculate_lte_populations proc~chemicaliterations->calculate_lte_populations calculate_partition_function calculate_partition_function proc~chemicaliterations->calculate_partition_function calculate_reaction_rates calculate_reaction_rates proc~chemicaliterations->calculate_reaction_rates Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/chemicaliterations.html"},{"title":"changetemperature – 3D-PDR","text":"subroutine changetemperature() Uses global_module maincode_module maincode_local proc~~changetemperature~~UsesGraph proc~changetemperature changetemperature module~global_module global_module proc~changetemperature->module~global_module module~maincode_local maincode_local proc~changetemperature->module~maincode_local module~maincode_module maincode_module proc~changetemperature->module~maincode_module iso_c_binding iso_c_binding module~global_module->iso_c_binding module~definitions definitions module~global_module->module~definitions module~healpix_types~2 healpix_types module~global_module->module~healpix_types~2 module~maincode_local->module~definitions module~maincode_local->module~healpix_types~2 module~maincode_module->iso_c_binding module~maincode_module->module~definitions module~maincode_module->module~healpix_types~2 module~healpix_types~2->module~definitions Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments None Calls proc~~changetemperature~~CallsGraph proc~changetemperature changetemperature calc_heating calc_heating proc~changetemperature->calc_heating calculate_reaction_rates calculate_reaction_rates proc~changetemperature->calculate_reaction_rates Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/changetemperature.html"},{"title":"readparams – 3D-PDR","text":"subroutine readparams() Uses healpix_types maincode_module global_module m_Mesh definitions chemistry_module proc~~readparams~~UsesGraph proc~readparams readparams module~chemistry_module chemistry_module proc~readparams->module~chemistry_module module~definitions definitions proc~readparams->module~definitions module~global_module global_module proc~readparams->module~global_module module~healpix_types~2 healpix_types proc~readparams->module~healpix_types~2 module~m_mesh m_Mesh proc~readparams->module~m_mesh module~maincode_module maincode_module proc~readparams->module~maincode_module module~chemistry_module->module~healpix_types~2 iso_c_binding iso_c_binding module~chemistry_module->iso_c_binding module~global_module->module~definitions module~global_module->module~healpix_types~2 module~global_module->iso_c_binding module~healpix_types~2->module~definitions module~maincode_module->module~definitions module~maincode_module->module~healpix_types~2 module~maincode_module->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments None","tags":"","url":"proc/readparams.html"},{"title":"readdensity – 3D-PDR","text":"subroutine readdensity() Uses healpix_types maincode_module m_Ray_box global_module healpix_module definitions m_Mesh chemistry_module maincode_local proc~~readdensity~~UsesGraph proc~readdensity readdensity module~chemistry_module chemistry_module proc~readdensity->module~chemistry_module module~definitions definitions proc~readdensity->module~definitions module~global_module global_module proc~readdensity->module~global_module module~healpix_module healpix_module proc~readdensity->module~healpix_module module~healpix_types~2 healpix_types proc~readdensity->module~healpix_types~2 module~m_mesh m_Mesh proc~readdensity->module~m_mesh module~m_ray_box m_Ray_box proc~readdensity->module~m_ray_box module~maincode_local maincode_local proc~readdensity->module~maincode_local module~maincode_module maincode_module proc~readdensity->module~maincode_module module~chemistry_module->module~healpix_types~2 iso_c_binding iso_c_binding module~chemistry_module->iso_c_binding module~global_module->module~definitions module~global_module->module~healpix_types~2 module~global_module->iso_c_binding module~healpix_module->module~definitions module~healpix_module->module~healpix_types~2 module~healpix_types~2->module~definitions module~m_ray_box->module~m_mesh module~maincode_local->module~definitions module~maincode_local->module~healpix_types~2 module~maincode_module->module~definitions module~maincode_module->module~healpix_types~2 module~maincode_module->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments None","tags":"","url":"proc/readdensity.html"},{"title":"logo – 3D-PDR","text":"subroutine logo() Arguments None","tags":"","url":"proc/logo.html"},{"title":"solvlevpop – 3D-PDR","text":"subroutine solvlevpop(NLEV, transition, density, SOLUTION) Uses healpix_types definitions proc~~solvlevpop~~UsesGraph proc~solvlevpop solvlevpop module~definitions definitions proc~solvlevpop->module~definitions module~healpix_types~2 healpix_types proc~solvlevpop->module~healpix_types~2 module~healpix_types~2->module~definitions Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name integer(kind=i4b), intent(in) :: NLEV real(kind=dp), intent(in) :: transition (1:NLEV,1:NLEV) real(kind=dp), intent(in) :: density real(kind=dp), intent(out) :: SOLUTION (1:NLEV) Calls proc~~solvlevpop~~CallsGraph proc~solvlevpop solvlevpop gauss_jordan gauss_jordan proc~solvlevpop->gauss_jordan Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/solvlevpop.html"},{"title":"GAUSS_JORDAN – 3D-PDR","text":"subroutine GAUSS_JORDAN(A, N, NP, B, call_writes) Uses healpix_types definitions proc~~gauss_jordan~~UsesGraph proc~gauss_jordan GAUSS_JORDAN module~definitions definitions proc~gauss_jordan->module~definitions module~healpix_types~2 healpix_types proc~gauss_jordan->module~healpix_types~2 module~healpix_types~2->module~definitions Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: A (1:NP,1:NP) integer(kind=i4b), intent(in) :: N integer(kind=i4b), intent(in) :: NP real(kind=dp), intent(inout) :: B (1:NP) logical, intent(out) :: call_writes","tags":"","url":"proc/gauss_jordan.html"},{"title":"GAUSS_JORDAN_writes – 3D-PDR","text":"subroutine GAUSS_JORDAN_writes(A, N, NP, B, ill) Uses healpix_types maincode_module definitions proc~~gauss_jordan_writes~~UsesGraph proc~gauss_jordan_writes GAUSS_JORDAN_writes module~definitions definitions proc~gauss_jordan_writes->module~definitions module~healpix_types~2 healpix_types proc~gauss_jordan_writes->module~healpix_types~2 module~maincode_module maincode_module proc~gauss_jordan_writes->module~maincode_module module~healpix_types~2->module~definitions module~maincode_module->module~definitions module~maincode_module->module~healpix_types~2 iso_c_binding iso_c_binding module~maincode_module->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: A (1:NP,1:NP) integer(kind=i4b), intent(in) :: N integer(kind=i4b), intent(in) :: NP real(kind=dp), intent(inout) :: B (1:NP) integer(kind=i4b), intent(in) :: ill","tags":"","url":"proc/gauss_jordan_writes.html"},{"title":"CALC_UVFIELD – 3D-PDR","text":"subroutine CALC_UVFIELD() Uses healpix_types maincode_module global_module proc~~calc_uvfield~~UsesGraph proc~calc_uvfield CALC_UVFIELD module~global_module global_module proc~calc_uvfield->module~global_module module~healpix_types~2 healpix_types proc~calc_uvfield->module~healpix_types~2 module~maincode_module maincode_module proc~calc_uvfield->module~maincode_module module~global_module->module~healpix_types~2 iso_c_binding iso_c_binding module~global_module->iso_c_binding module~definitions definitions module~global_module->module~definitions module~healpix_types~2->module~definitions module~maincode_module->module~healpix_types~2 module~maincode_module->iso_c_binding module~maincode_module->module~definitions Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments None","tags":"","url":"proc/calc_uvfield.html"},{"title":"readcoolants – 3D-PDR","text":"subroutine readcoolants() Uses maincode_module proc~~readcoolants~~UsesGraph proc~readcoolants readcoolants module~maincode_module maincode_module proc~readcoolants->module~maincode_module iso_c_binding iso_c_binding module~maincode_module->iso_c_binding module~definitions definitions module~maincode_module->module~definitions module~healpix_types~2 healpix_types module~maincode_module->module~healpix_types~2 module~healpix_types~2->module~definitions Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments None Calls proc~~readcoolants~~CallsGraph proc~readcoolants readcoolants readinput readinput proc~readcoolants->readinput Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/readcoolants.html"},{"title":"Mesh – 3D-PDR","text":"public  subroutine Mesh() Arguments None","tags":"","url":"proc/mesh.html"},{"title":"InitVisu – 3D-PDR","text":"public  subroutine InitVisu() Arguments None","tags":"","url":"proc/initvisu.html"},{"title":"dump_visu – 3D-PDR","text":"public  subroutine dump_visu() Arguments None","tags":"","url":"proc/dump_visu.html"},{"title":"writeoutputs – 3D-PDR","text":"public  subroutine writeoutputs() Arguments None Calls proc~~writeoutputs~3~~CallsGraph proc~writeoutputs~3 writeoutputs h5close_f h5close_f proc~writeoutputs~3->h5close_f h5dclose_f h5dclose_f proc~writeoutputs~3->h5dclose_f h5dcreate_f h5dcreate_f proc~writeoutputs~3->h5dcreate_f h5dwrite_f h5dwrite_f proc~writeoutputs~3->h5dwrite_f h5fclose_f h5fclose_f proc~writeoutputs~3->h5fclose_f h5fcreate_f h5fcreate_f proc~writeoutputs~3->h5fcreate_f h5open_f h5open_f proc~writeoutputs~3->h5open_f h5sclose_f h5sclose_f proc~writeoutputs~3->h5sclose_f h5screate_simple_f h5screate_simple_f proc~writeoutputs~3->h5screate_simple_f h5tcopy_f h5tcopy_f proc~writeoutputs~3->h5tcopy_f h5tset_size_f h5tset_size_f proc~writeoutputs~3->h5tset_size_f proc~write_h5_one_r3d write_h5_one_r3d proc~writeoutputs~3->proc~write_h5_one_r3d proc~write_h5_one_r3d->h5dclose_f proc~write_h5_one_r3d->h5dcreate_f proc~write_h5_one_r3d->h5dwrite_f proc~write_h5_one_r3d->h5sclose_f proc~write_h5_one_r3d->h5screate_simple_f Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~writeoutputs~3~~CalledByGraph proc~writeoutputs~3 writeoutputs program~convert_fin2h5 convert_fin2h5 program~convert_fin2h5->proc~writeoutputs~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/writeoutputs~3.html"},{"title":"write_h5_one_r3d – 3D-PDR","text":"public  subroutine write_h5_one_r3d(file_id, dims, temp_real, name) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: file_id integer(kind=HSIZE_T), intent(in), dimension(3) :: dims real(kind=RK), intent(in) :: temp_real (:,:,:) character(len=*), intent(in) :: name Calls proc~~write_h5_one_r3d~~CallsGraph proc~write_h5_one_r3d write_h5_one_r3d h5dclose_f h5dclose_f proc~write_h5_one_r3d->h5dclose_f h5dcreate_f h5dcreate_f proc~write_h5_one_r3d->h5dcreate_f h5dwrite_f h5dwrite_f proc~write_h5_one_r3d->h5dwrite_f h5sclose_f h5sclose_f proc~write_h5_one_r3d->h5sclose_f h5screate_simple_f h5screate_simple_f proc~write_h5_one_r3d->h5screate_simple_f Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~write_h5_one_r3d~~CalledByGraph proc~write_h5_one_r3d write_h5_one_r3d proc~writeoutputs~3 writeoutputs proc~writeoutputs~3->proc~write_h5_one_r3d program~convert_fin2h5 convert_fin2h5 program~convert_fin2h5->proc~writeoutputs~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/write_h5_one_r3d.html"},{"title":"H2PDRATE – 3D-PDR","text":"interface Called by interface~~h2pdrate~~CalledByGraph interface~h2pdrate H2PDRATE proc~calculate_reaction_rates CALCULATE_REACTION_RATES proc~calculate_reaction_rates->interface~h2pdrate Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public  function H2PDRATE(k0, g0, av, nh2) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: k0 real(kind=dp), intent(in) :: g0 real(kind=dp), intent(in) :: av real(kind=dp), intent(in) :: nh2 Return Value real(kind=dp)","tags":"","url":"interface/h2pdrate.html"},{"title":"COPDRATE – 3D-PDR","text":"interface Called by interface~~copdrate~~CalledByGraph interface~copdrate COPDRATE proc~calculate_reaction_rates CALCULATE_REACTION_RATES proc~calculate_reaction_rates->interface~copdrate Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public  function COPDRATE(k0, g0, av, nco, nh2) result(copdrate) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: k0 real(kind=dp), intent(in) :: g0 real(kind=dp), intent(in) :: av real(kind=dp), intent(in) :: nco real(kind=dp), intent(in) :: nh2 Return Value real(kind=dp)","tags":"","url":"interface/copdrate.html"},{"title":"CIPDRATE – 3D-PDR","text":"interface Called by interface~~cipdrate~~CalledByGraph interface~cipdrate CIPDRATE proc~calculate_reaction_rates CALCULATE_REACTION_RATES proc~calculate_reaction_rates->interface~cipdrate Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public  function CIPDRATE(K0, G0, AV, KAV, NCI, nh2, TGAS) result(cipdrate) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: K0 real(kind=dp), intent(in) :: G0 real(kind=dp), intent(in) :: AV real(kind=dp), intent(in) :: KAV real(kind=dp), intent(in) :: NCI real(kind=dp), intent(in) :: nh2 real(kind=dp), intent(in) :: TGAS Return Value real(kind=dp)","tags":"","url":"interface/cipdrate.html"},{"title":"SIPDRATE – 3D-PDR","text":"interface Called by interface~~sipdrate~~CalledByGraph interface~sipdrate SIPDRATE proc~calculate_reaction_rates CALCULATE_REACTION_RATES proc~calculate_reaction_rates->interface~sipdrate Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. public  function SIPDRATE(K0, G0, AV, KAV, NSI) result(sipdrate) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: K0 real(kind=dp), intent(in) :: G0 real(kind=dp), intent(in) :: AV real(kind=dp), intent(in) :: KAV real(kind=dp), intent(in) :: NSI Return Value real(kind=dp)","tags":"","url":"interface/sipdrate.html"},{"title":"H2SHIELD1 – 3D-PDR","text":"interface public  function H2SHIELD1(nh2, DOPW, RADW) result(h2shield1) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: nh2 real(kind=dp), intent(in) :: DOPW real(kind=dp), intent(in) :: RADW Return Value real(kind=dp)","tags":"","url":"interface/h2shield1.html"},{"title":"h2shield2 – 3D-PDR","text":"interface public  function h2shield2(nh2) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: nh2 Return Value real(kind=dp)","tags":"","url":"interface/h2shield2.html"},{"title":"COSHIELD – 3D-PDR","text":"interface public  function COSHIELD(NCO, NH2) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: NCO real(kind=dp), intent(in) :: NH2 Return Value real(kind=dp)","tags":"","url":"interface/coshield.html"},{"title":"SCATTER – 3D-PDR","text":"interface public  function SCATTER(AV, LAMBDA) result(scatter) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: AV real(kind=dp), intent(in) :: LAMBDA Return Value real(kind=dp)","tags":"","url":"interface/scatter.html"},{"title":"XLAMBDA – 3D-PDR","text":"interface public  function XLAMBDA(lambda) result(xlambda) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: lambda Return Value real(kind=dp)","tags":"","url":"interface/xlambda.html"},{"title":"LBAR – 3D-PDR","text":"interface public  function LBAR(NCO, NH2) result(lbar) Arguments Type Intent Optional Attributes Name real(kind=dp) :: NCO real(kind=dp) :: NH2 Return Value real(kind=dp)","tags":"","url":"interface/lbar.html"},{"title":"calculate_heating – 3D-PDR","text":"interface public  function calculate_heating(density, gas_temperature, dust_temperature, UV_field, v_turb, nspec, init_abundance, nreac, rate) Arguments Type Intent Optional Attributes Name real(kind=dp) :: density real(kind=dp) :: gas_temperature real(kind=dp) :: dust_temperature real(kind=dp) :: UV_field real(kind=dp) :: v_turb integer(kind=i4b) :: nspec real(kind=dp) :: init_abundance (1:nspec) integer(kind=i4b) :: nreac real(kind=dp) :: rate (1:nreac) Return Value real(kind=dp)","tags":"","url":"interface/calculate_heating.html"},{"title":"octree – 3D-PDR","text":"public recursive subroutine octree(ray, parent, level, contribution, contribution_1D, density_3D, density_1D) Arguments Type Intent Optional Attributes Name type( HEALPix_ray ), intent(in) :: ray type( box ), intent(in) :: parent integer, intent(in) :: level real(kind=RK), intent(inout) :: contribution real(kind=RK), intent(inout) :: contribution_1D real(kind=RK) :: density_3D (:,:,:) real(kind=RK) :: density_1D (:) Called by proc~~octree~~CalledByGraph proc~octree octree proc~octree->proc~octree program~init3dpdr init3DPDR program~init3dpdr->proc~octree Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/octree.html"},{"title":"raytheia_table – 3D-PDR","text":"public recursive subroutine raytheia_table(ray, parent, level, source, ipix) Arguments Type Intent Optional Attributes Name type( HEALPix_ray ), intent(in) :: ray type( box ), intent(in) :: parent integer, intent(in) :: level integer, intent(in) :: source integer, intent(in) :: ipix","tags":"","url":"proc/raytheia_table.html"},{"title":"initvisual – 3D-PDR","text":"public  subroutine initvisual() Arguments None Called by proc~~initvisual~~CalledByGraph proc~initvisual initvisual program~convert_fin2h5 convert_fin2h5 program~convert_fin2h5->proc~initvisual Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/initvisual.html"},{"title":"m_Mesh – 3D-PDR","text":"Used by module~~m_mesh~~UsedByGraph module~m_mesh m_Mesh module~m_ioandvisu m_IOAndVisu module~m_ioandvisu->module~m_mesh module~m_ray_box m_Ray_box module~m_ray_box->module~m_mesh module~m_ray_box~2 m_Ray_box module~m_ray_box~2->module~m_mesh proc~escape_probability escape_probability proc~escape_probability->module~m_mesh proc~escape_probability->module~m_ray_box proc~evaluation_points evaluation_points proc~evaluation_points->module~m_mesh proc~evaluation_points->module~m_ray_box proc~readdensity readdensity proc~readdensity->module~m_mesh proc~readdensity->module~m_ray_box proc~readparams readparams proc~readparams->module~m_mesh program~init3dpdr init3DPDR program~init3dpdr->module~m_mesh program~init3dpdr->module~m_ray_box proc~calc_columndens calc_columndens proc~calc_columndens->module~m_ray_box proc~coolingfunctions coolingfunctions proc~coolingfunctions->module~m_ray_box Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public, parameter :: RK = KIND(0.D0) real(kind=RK), public :: xlx real(kind=RK), public :: yly real(kind=RK), public :: zlz integer, public :: nxp integer, public :: nyp integer, public :: nzp integer, public :: nxc integer, public :: nyc integer, public :: nzc real(kind=RK), public :: dx real(kind=RK), public :: dy real(kind=RK), public :: dz Subroutines public  subroutine Mesh () Arguments None","tags":"","url":"module/m_mesh.html"},{"title":"m_IOAndVisu – 3D-PDR","text":"InitVisu Write_XDMF_One dump_visu Uses maincode_module m_Mesh module~~m_ioandvisu~~UsesGraph module~m_ioandvisu m_IOAndVisu module~m_mesh m_Mesh module~m_ioandvisu->module~m_mesh module~maincode_module maincode_module module~m_ioandvisu->module~maincode_module iso_c_binding iso_c_binding module~maincode_module->iso_c_binding module~definitions definitions module~maincode_module->module~definitions module~healpix_types~2 healpix_types module~maincode_module->module~healpix_types~2 module~healpix_types~2->module~definitions Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public, parameter :: mytype_save = KIND(0.0D0) Subroutines public  subroutine InitVisu () Arguments None public  subroutine dump_visu () Arguments None","tags":"","url":"module/m_ioandvisu.html"},{"title":"m_writeoutputs – 3D-PDR","text":"Uses hdf5 m_paramters module~~m_writeoutputs~~UsesGraph module~m_writeoutputs m_writeoutputs hdf5 hdf5 module~m_writeoutputs->hdf5 module~m_paramters m_paramters module~m_writeoutputs->module~m_paramters Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~m_writeoutputs~~UsedByGraph module~m_writeoutputs m_writeoutputs program~convert_fin2h5 convert_fin2h5 program~convert_fin2h5->module~m_writeoutputs Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public :: h5err integer, public :: coords (3) character(len=256), public :: fin_file character(len=256), public :: out_file_h5 integer(kind=HID_T), public :: file_id integer(kind=HID_T), public :: filespace integer(kind=HID_T), public :: filespace2 integer(kind=HID_T), public :: filespace3 integer(kind=HID_T), public :: dset_id_network integer(kind=HID_T), public :: dset_id_cooarray integer(kind=HID_T), public :: dset_id_allpop integer(kind=HID_T), public :: dtype_id integer(kind=HID_T), public :: arrtype_id integer(kind=HSIZE_T), public, dimension(3) :: dims integer(kind=HSIZE_T), public, dimension(4) :: dims3 real(kind=RK), public, allocatable :: temp_real (:,:,:) Subroutines public  subroutine writeoutputs () Arguments None public  subroutine write_h5_one_r3d (file_id, dims, temp_real, name) Arguments Type Intent Optional Attributes Name integer(kind=HID_T), intent(in) :: file_id integer(kind=HSIZE_T), intent(in), dimension(3) :: dims real(kind=RK), intent(in) :: temp_real (:,:,:) character(len=*), intent(in) :: name","tags":"","url":"module/m_writeoutputs.html"},{"title":"m_paramters – 3D-PDR","text":"Used by module~~m_paramters~~UsedByGraph module~m_paramters m_paramters module~m_visual m_visual module~m_visual->module~m_paramters module~m_writeoutputs m_writeoutputs module~m_writeoutputs->module~m_paramters program~convert_fin2h5 convert_fin2h5 program~convert_fin2h5->module~m_paramters program~convert_fin2h5->module~m_visual program~convert_fin2h5->module~m_writeoutputs Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public, parameter :: RK = KIND(0.D0) integer, public, parameter :: coo = 4 integer, public, parameter :: nspec = 33 integer, public, parameter :: nrays = 12 integer, public, parameter,               dimension(coo) :: cnlev = [41, 5, 5, 5] integer, public, parameter :: nxc = 32 integer, public, parameter :: nyc = 32 integer, public, parameter :: nzc = 32 real(kind=RK), public, parameter :: xlx = 3.94156170 real(kind=RK), public, parameter :: yly = 3.93756294 real(kind=RK), public, parameter :: zlz = 3.93856335 character(len=50), public, parameter :: outname = 'test' real(kind=RK), public :: dx real(kind=RK), public :: dy real(kind=RK), public :: dz character(len=20), public :: cfile character(len=20), public :: coolfile (1:10) type( pdr_node ), public, allocatable :: pdr (:,:,:) Derived Types type, public :: pdr_excit Components Type Visibility Attributes Name Initial real(kind=RK), public, pointer :: pop (:) type, public :: pdr_node Components Type Visibility Attributes Name Initial integer, public :: etype real(kind=RK), public :: x real(kind=RK), public :: y real(kind=RK), public :: z real(kind=RK), public :: vx real(kind=RK), public :: vy real(kind=RK), public :: vz real(kind=RK), public :: Tgas real(kind=RK), public :: Tdust real(kind=RK), public :: rho real(kind=RK), public :: UVfield real(kind=RK), public :: totalcooling real(kind=RK), public, pointer :: AV (:) real(kind=RK), public, pointer :: abundance (:) real(kind=RK), public, pointer :: cooling (:) real(kind=RK), public, pointer :: heating (:) type( pdr_excit ), public, allocatable :: coolant (:) real(kind=RK), public :: zetalocal","tags":"","url":"module/m_paramters.html"},{"title":"maincode_local – 3D-PDR","text":"Uses healpix_types definitions module~~maincode_local~~UsesGraph module~maincode_local maincode_local module~definitions definitions module~maincode_local->module~definitions module~healpix_types~2 healpix_types module~maincode_local->module~healpix_types~2 module~healpix_types~2->module~definitions Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~maincode_local~~UsedByGraph module~maincode_local maincode_local proc~changetemperature changetemperature proc~changetemperature->module~maincode_local proc~chemicaliterations chemicaliterations proc~chemicaliterations->module~maincode_local proc~readdensity readdensity proc~readdensity->module~maincode_local program~threedpdr threedpdr program~threedpdr->module~maincode_local Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial logical, public :: write_output integer(kind=i4b), public :: mmpdr integer(kind=i4b), public :: j integer(kind=i4b), public :: newmaxpoints integer(kind=i4b), public :: ilevel integer(kind=i4b), public :: jlevel real(kind=dp), public, allocatable :: temp_abundance (:,:) real(kind=dp), public, allocatable :: temp_density (:) real(kind=dp), public, allocatable :: temp_temperature (:) real(kind=dp), public :: t1 real(kind=dp), public :: t2 integer(kind=i4b), public :: NRGR integer(kind=i4b), public :: NRH2 integer(kind=i4b), public :: NRHD integer(kind=i4b), public :: NRCO integer(kind=i4b), public :: NRCI integer(kind=i4b), public :: NRSI real(kind=dp), public :: uvfieldaux real(kind=dp), public, allocatable :: x_rev (:) real(kind=dp), public, allocatable :: y_rev (:) real(kind=dp), public, allocatable :: z_rev (:) real(kind=dp), public, allocatable :: n_rev (:) integer, public :: pp_debug real, public :: xp real, public :: yp real, public :: zp real, public :: dist real, public :: Avis integer, public :: proj integer, public :: pproj","tags":"","url":"module/maincode_local.html"},{"title":"healpix_module – 3D-PDR","text":"Uses healpix_types definitions module~~healpix_module~~UsesGraph module~healpix_module healpix_module module~definitions definitions module~healpix_module->module~definitions module~healpix_types~2 healpix_types module~healpix_module->module~healpix_types~2 module~healpix_types~2->module~definitions Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~healpix_module~~UsedByGraph module~healpix_module healpix_module proc~ang2pix_nest_id ang2pix_nest_id proc~ang2pix_nest_id->module~healpix_module proc~escape_probability escape_probability proc~escape_probability->module~healpix_module proc~evaluation_points evaluation_points proc~evaluation_points->module~healpix_module proc~mk_pix2xy mk_pix2xy proc~mk_pix2xy->module~healpix_module proc~mk_xy2pix mk_xy2pix proc~mk_xy2pix->module~healpix_module proc~pix2ang_nest pix2ang_nest proc~pix2ang_nest->module~healpix_module proc~pix2vec_nest pix2vec_nest proc~pix2vec_nest->module~healpix_module proc~readdensity readdensity proc~readdensity->module~healpix_module program~threedpdr threedpdr program~threedpdr->module~healpix_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer(kind=i4b), public :: ns_max integer(kind=i4b), public, dimension(0:1023) :: pix2x integer(kind=i4b), public, dimension(0:1023) :: pix2y real(kind=DP), public :: x2pix (0:1023) real(kind=DP), public :: y2pix (0:1023) real(kind=DP), public, allocatable :: vertex (:,:) real(kind=DP), public, allocatable :: vector (:)","tags":"","url":"module/healpix_module.html"},{"title":"maincode_module – 3D-PDR","text":"Uses iso_c_binding healpix_types definitions module~~maincode_module~~UsesGraph module~maincode_module maincode_module iso_c_binding iso_c_binding module~maincode_module->iso_c_binding module~definitions definitions module~maincode_module->module~definitions module~healpix_types~2 healpix_types module~maincode_module->module~healpix_types~2 module~healpix_types~2->module~definitions Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~maincode_module~~UsedByGraph module~maincode_module maincode_module module~m_ioandvisu m_IOAndVisu module~m_ioandvisu->module~maincode_module module~m_ray_box~2 m_Ray_box module~m_ray_box~2->module~maincode_module proc~allocations allocations proc~allocations->module~maincode_module proc~calc_columndens calc_columndens proc~calc_columndens->module~maincode_module proc~calc_crattenuation calc_CRattenuation proc~calc_crattenuation->module~maincode_module proc~calc_uvfield CALC_UVFIELD proc~calc_uvfield->module~maincode_module proc~calculate_dust_temperatures CALCULATE_DUST_TEMPERATURES proc~calculate_dust_temperatures->module~maincode_module proc~calculate_reaction_rates CALCULATE_REACTION_RATES proc~calculate_reaction_rates->module~maincode_module proc~changetemperature changetemperature proc~changetemperature->module~maincode_module proc~checkconvergence checkconvergence proc~checkconvergence->module~maincode_module proc~chemicaliterations chemicaliterations proc~chemicaliterations->module~maincode_module proc~coolingfunctions coolingfunctions proc~coolingfunctions->module~maincode_module proc~escape_probability escape_probability proc~escape_probability->module~maincode_module proc~evaluation_points evaluation_points proc~evaluation_points->module~maincode_module proc~gauss_jordan_writes GAUSS_JORDAN_writes proc~gauss_jordan_writes->module~maincode_module proc~h2pdrate H2PDRATE proc~h2pdrate->module~maincode_module proc~initialization initialization proc~initialization->module~maincode_module proc~read_command_line read_command_line proc~read_command_line->module~maincode_module proc~read_species READ_SPECIES proc~read_species->module~maincode_module proc~readcoolants readcoolants proc~readcoolants->module~maincode_module proc~readdensity readdensity proc~readdensity->module~maincode_module proc~readparams readparams proc~readparams->module~maincode_module proc~writeoutputs writeoutputs proc~writeoutputs->module~maincode_module proc~writeoutputs~2 writeoutputs proc~writeoutputs~2->module~maincode_module proc~writeparams writeparams proc~writeparams->module~maincode_module program~threedpdr threedpdr program~threedpdr->module~maincode_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer(kind=I4B), public :: i integer, public :: ii integer(kind=I4B), public :: k integer(kind=I4B), public :: kk integer(kind=I4B), public :: p integer(kind=I4B), public :: ipix integer(kind=I4B), public :: level integer(kind=I4B), public :: nrays integer(kind=I4B), public :: nside integer(kind=I4B), public :: itot integer(kind=I4B), public :: ktot integer(kind=I4B), public :: tot_eval integer(kind=I4B), public :: NLEV integer(kind=I4B), public :: NTEMP integer(kind=i4b), public :: iteration integer(kind=i4b), public :: ITERTOT integer(kind=i4b), public :: iterstep integer(kind=i4b), public :: NSPEC integer(kind=i4b), public :: NREAC integer(kind=i4b), public :: maxpoints integer(kind=i4b), public :: suma integer, public :: CHEMITERATIONS integer, public :: pdr_tot logical, public :: writeiterations logical, public :: SPH character(len=1), public :: crfieldchoice real(kind=dp), public :: crattennorm real(kind=dp), public :: crattenslope real(kind=dp), public :: crattenn0 integer(kind=I4B), public, allocatable :: rb (:) integer(kind=I4B), public, allocatable :: rrb (:) integer(kind=I4B), public :: iwork (1:1000) real(kind=dp), public :: rwork (1:1000000) character(len=50), public :: indir character(len=50), public :: outdir real(kind=dp), public :: ZETA real(kind=DP), public :: angle_los real(kind=dp), public :: radius real(kind=dp), public :: theta_crit real(kind=DP), public :: rvec (1:3) real(kind=DP), public :: theta real(kind=DP), public :: phi real(kind=dp), public :: adaptive_step real(kind=dp), public :: rhs1 real(kind=DP), public :: rhs2 real(kind=DP), public :: points real(kind=DP), public :: origin (1:3) real(kind=DP), public :: healpixvector (1:3) real(kind=dp), public :: ENERGY real(kind=dp), public :: WEIGHT real(kind=dp), public :: EINSTEINA real(kind=dp), public :: FREQUENCY real(kind=dp), public :: Tguess real(kind=dp), public :: n_H real(kind=dp), public :: Z_increment real(kind=dp), public :: frac1 real(kind=dp), public :: frac2 real(kind=dp), public :: frac3 real(kind=dp), public :: tau_increment real(kind=dp), public :: beta_ij_ray real(kind=dp), public :: beta_ij_sum real(kind=dp), public :: beta_ij real(kind=dp), public :: TPOP real(kind=dp), public :: TMP2 real(kind=dp), public :: BB_ij real(kind=dp), public :: relch real(kind=dp), public :: v_turb real(kind=dp), public :: v_turb_inp real(kind=dp), public :: Tlow0 real(kind=dp), public :: Thigh0 real(kind=dp), public :: Tmin real(kind=dp), public :: Tmax real(kind=dp), public :: Fcrit real(kind=dp), public :: Tdiff real(kind=dp), public :: dust_temperature real(kind=dp), public :: avmax real(kind=dp), public :: Gext (1:3) character(len=2), public :: UVdirchoice real(kind=sp), public :: user_UVAngle (2) real(kind=sp), public :: UVdir (1:3) real(kind=dp), public :: Xext (1:3) real(kind=dp), public :: AV_fac real(kind=dp), public :: UV_fac real(kind=dp), public :: redshift real(kind=dp), public :: Tcmb real(kind=dp), public :: Av_crit real(kind=dp), public :: v_alfv real(kind=DP), public, allocatable :: vectors (:,:) real(kind=DP), public, allocatable :: ep (:,:) real(kind=dp), public, allocatable :: ra (:) real(kind=dp), public, allocatable :: density (:) real(kind=DP), public, allocatable :: c_dens (:) real(kind=dp), public, allocatable :: rra (:) real(kind=dp), public, allocatable :: tau_ij (:) real(kind=dp), public, allocatable :: field (:,:) character(len=50), public :: input character(len=50), public :: output integer(kind=i4b), public, allocatable :: DUPLICATE (:) real(kind=dp), public, allocatable :: ALPHA (:) real(kind=dp), public, allocatable :: BETA (:) real(kind=dp), public, allocatable :: GAMMA (:) real(kind=dp), public, allocatable :: RATE (:) real(kind=dp), public, allocatable :: RTMIN (:) real(kind=dp), public, allocatable :: RTMAX (:) character(len=10), public, allocatable :: REACTANT (:,:) character(len=10), public, allocatable :: PRODUCT (:,:) real(kind=dp), public, allocatable :: MASS (:) real(kind=dp), public, allocatable :: init_abundance (:) character(len=10), public, allocatable :: SPECIES (:) real(kind=dp), public, bind(c,name=\"0\") :: start_time real(kind=dp), public, bind(c,name=\"0\") :: end_time integer(kind=i4b), public :: status character(len=50), public :: paramFile character(len=50), public :: coolfile (1:30) integer, public :: coo integer, public :: cur_nlev integer, public :: cur_ntemp real(kind=dp), public, allocatable :: temp_pop (:) type( coolant_node ), public, allocatable :: coolant (:) real(kind=dp), public :: temp_Z_function real(kind=dp), public, allocatable :: temp_C_COEFFS (:,:) real(kind=dp), public, allocatable :: temp_line (:,:) real(kind=dp), public, allocatable :: temp_transition (:,:) real(kind=dp), public, allocatable :: temp_solution (:) type( cpop_node ), public, allocatable :: cpop (:) type( pdr_node ), public, allocatable :: pdr (:) integer(kind=i4b), public :: levpop_iteration real(kind=dp), public :: thermal_percentage real(kind=dp), public :: levpop_percentage real(kind=dp), public :: rad_tot character(len=100), public :: out_file character(len=100), public :: out_file2 character(len=7), public :: file_ext character(len=6), public :: file_numb integer(kind=i4b), public :: referee integer(kind=i4b), public :: id logical, public :: level_conv logical, public :: first_time logical, public :: relch_conv logical, public, allocatable :: expanded (:) integer(kind=i4b), public :: pdr_ptot real(kind=DP), public, allocatable :: pdrpoint (:,:) real(kind=dp), public :: xpos real(kind=dp), public :: ypos real(kind=dp), public :: zpos real(kind=dp), public :: denst Derived Types type, public :: coolant_node Components Type Visibility Attributes Name Initial real(kind=dp), public, pointer :: COEFF (:) real(kind=dp), public, pointer :: ENERGIES (:) real(kind=dp), public, pointer :: WEIGHTS (:) real(kind=dp), public, pointer :: A_COEFFS (:,:) real(kind=dp), public, pointer :: B_COEFFS (:,:) real(kind=dp), public, pointer :: C_COEFFS (:,:) real(kind=dp), public, pointer :: FREQUENCIES (:,:) real(kind=dp), public, pointer :: TEMPERATURES (:,:) real(kind=dp), public, pointer :: HP_COL (:,:,:) real(kind=dp), public, pointer :: H_COL (:,:,:) real(kind=dp), public, pointer :: EL_COL (:,:,:) real(kind=dp), public, pointer :: HE_COL (:,:,:) real(kind=dp), public, pointer :: H2_COL (:,:,:) real(kind=dp), public, pointer :: PH2_COL (:,:,:) real(kind=dp), public, pointer :: OH2_COL (:,:,:) real(kind=dp), public :: molweight integer, public :: cnlev integer, public :: cntemp integer, public :: cspec character(len=10), public :: cname integer, public :: incr real, public :: percentage type, public :: cpop_node Components Type Visibility Attributes Name Initial real(kind=dp), public, pointer :: evalpop (:,:,:) type, public :: pdr_excit Components Type Visibility Attributes Name Initial real(kind=dp), public, pointer :: pop (:) real(kind=dp), public, pointer :: line (:,:) real(kind=dp), public, pointer :: solution (:) real(kind=dp), public, pointer :: relativechange (:) logical, public :: isconverged type, public :: pdr_node Components Type Visibility Attributes Name Initial integer(kind=i4b), public, pointer :: epray (:) integer(kind=i4b), public, pointer :: projected (:,:) real(kind=dp), public, pointer :: length (:,:) integer(kind=i4b), public, pointer :: raytype (:) real(kind=dp), public, pointer :: epoint (:,:,:) real(kind=dp), public, pointer :: AV (:) real(kind=dp), public, pointer :: rad_surface (:) real(kind=dp), public, pointer :: abundance (:) real(kind=dp), public, pointer :: cooling (:) real(kind=dp), public, pointer :: heating (:) real(kind=dp), public, pointer :: column_NH2 (:) real(kind=dp), public, pointer :: column_NHD (:) real(kind=dp), public, pointer :: column_NCO (:) real(kind=dp), public, pointer :: column_NC (:) real(kind=dp), public, pointer :: column_NS (:) real(kind=dp), public :: totalcooling type( pdr_excit ), public, allocatable :: coolant (:) real(kind=dp), public :: UVfield real(kind=dp), public :: zetalocal real(kind=dp), public :: rho real(kind=dp), public :: smoo real(kind=dp), public :: x real(kind=dp), public :: y real(kind=dp), public :: z integer(kind=i4b), public :: etype real(kind=dp), public :: Tdust real(kind=dp), public :: nTgas real(kind=dp), public :: Tgas real(kind=dp), public, pointer :: solution (:,:) logical, public :: levelconverged character(len=1), public :: previouschange","tags":"","url":"module/maincode_module.html"},{"title":"uclpdr_module – 3D-PDR","text":"Uses healpix_types definitions module~~uclpdr_module~~UsesGraph module~uclpdr_module uclpdr_module module~definitions definitions module~uclpdr_module->module~definitions module~healpix_types~2 healpix_types module~uclpdr_module->module~healpix_types~2 module~healpix_types~2->module~definitions Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~uclpdr_module~~UsedByGraph module~uclpdr_module uclpdr_module proc~allocations allocations proc~allocations->module~uclpdr_module proc~coshield COSHIELD proc~coshield->module~uclpdr_module proc~h2shield2 H2SHIELD2 proc~h2shield2->module~uclpdr_module proc~xlambda XLAMBDA proc~xlambda->module~uclpdr_module program~threedpdr threedpdr program~threedpdr->module~uclpdr_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer(kind=i4b), public, save :: NUMH2 = 105 real(kind=dp), public, dimension(105), save :: COL_GRID = (/0.000D+00, 3.690D+11, 3.715D+12, 3.948D+13, 1.233D+14, 2.536D+14, 4.342D+14, 6.653D+14, 6.689D+14, 9.075D+14, 1.234D+15, 1.631D+15, 2.105D+15, 2.363D+15, 2.899D+15, 3.207D+15, 3.848D+15, 4.636D+15, 5.547D+15, 6.604D+15, 7.855D+15, 9.368D+15, 1.122D+16, 1.352D+16, 1.643D+16, 2.017D+16, 2.515D+16, 3.190D+16, 4.128D+16, 5.439D+16, 7.315D+16, 1.009D+17, 1.432D+17, 2.092D+17, 3.123D+17, 4.738D+17, 5.388D+17, 8.935D+17, 1.381D+18, 2.164D+18, 3.330D+18, 5.024D+18, 7.404D+18, 9.029D+18, 1.316D+19, 1.813D+19, 2.453D+19, 3.248D+19, 4.216D+19, 5.370D+19, 6.722D+19, 8.277D+19, 9.894D+19, 1.186D+20, 1.404D+20, 1.644D+20, 1.908D+20, 2.197D+20, 2.510D+20, 2.849D+20, 3.214D+20, 3.604D+20, 4.019D+20, 4.456D+20, 4.915D+20, 5.393D+20, 5.886D+20, 6.392D+20, 6.909D+20, 7.433D+20, 7.965D+20, 8.505D+20, 9.056D+20, 9.627D+20, 1.011D+21, 1.068D+21, 1.125D+21, 1.185D+21, 1.250D+21, 1.327D+21, 1.428D+21, 1.578D+21, 1.851D+21, 2.128D+21, 2.298D+21, 2.389D+21, 2.459D+21, 2.519D+21, 2.571D+21, 2.618D+21, 2.707D+21, 2.790D+21, 2.887D+21, 3.001D+21, 3.139D+21, 3.303D+21, 3.497D+21, 3.722D+21, 3.983D+21, 4.283D+21, 4.644D+21, 5.127D+21, 5.945D+21, 8.205D+21, 1.015D+22/) real(kind=dp), public, dimension(105), save :: SH2_GRID = (/1.000D+00, 9.983D-01, 9.853D-01, 8.761D-01, 7.199D-01, 5.728D-01, 4.455D-01, 3.431D-01, 3.418D-01, 2.732D-01, 2.110D-01, 1.619D-01, 1.236D-01, 1.084D-01, 8.447D-02, 7.410D-02, 5.774D-02, 4.416D-02, 3.390D-02, 2.625D-02, 2.048D-02, 1.606D-02, 1.264D-02, 9.987D-03, 7.937D-03, 6.343D-03, 5.088D-03, 4.089D-03, 3.283D-03, 2.640D-03, 2.130D-03, 1.725D-03, 1.397D-03, 1.129D-03, 9.097D-04, 7.340D-04, 6.883D-04, 5.377D-04, 4.352D-04, 3.475D-04, 2.771D-04, 2.205D-04, 1.753D-04, 1.549D-04, 1.210D-04, 9.666D-05, 7.705D-05, 6.148D-05, 4.904D-05, 3.909D-05, 3.112D-05, 2.473D-05, 1.997D-05, 1.578D-05, 1.244D-05, 9.769D-06, 7.634D-06, 5.932D-06, 4.581D-06, 3.515D-06, 2.679D-06, 2.029D-06, 1.527D-06, 1.144D-06, 8.523D-07, 6.332D-07, 4.693D-07, 3.475D-07, 2.574D-07, 1.907D-07, 1.413D-07, 1.047D-07, 7.739D-08, 5.677D-08, 4.386D-08, 3.227D-08, 2.385D-08, 1.750D-08, 1.248D-08, 8.389D-09, 5.026D-09, 2.382D-09, 6.259D-10, 1.653D-10, 7.399D-11, 4.824D-11, 3.474D-11, 2.633D-11, 2.069D-11, 1.663D-11, 1.099D-11, 7.506D-12, 4.825D-12, 2.864D-12, 1.534D-12, 7.324D-13, 3.087D-13, 1.135D-13, 3.591D-14, 9.689D-15, 2.045D-15, 2.618D-16, 8.918D-18, 3.041D-21, 1.739D-23/) logical, public :: start integer(kind=i4b), public, save :: DIMH2 = 6 integer(kind=i4b), public, save :: DIMCO = 8 real(kind=dp), public, dimension(8), save :: NCO_GRID = (/12.0D0, 13.0D0, 14.0D0, 15.0D0, 16.0D0, 17.0D0, 18.0D0, 19.0D0/) real(kind=dp), public, dimension(6), save :: NH2_GRID = (/18.0D0, 19.0D0, 20.0D0, 21.0D0, 22.0D0, 23.0D0/) real(kind=dp), public :: SCO_GRID (1:8,1:6) integer(kind=i4b), public, save :: N_GRID = 30 real(kind=dp), public, dimension(30), save :: L_GRID = (/910.0D0, 950.0D0, 1000.0D0, 1050.0D0, 1110.0D0, 1180.0D0, 1250.0D0, 1390.0D0, 1490.0D0, 1600.0D0, 1700.0D0, 1800.0D0, 1900.0D0, 2000.0D0, 2100.0D0, 2190.0D0, 2300.0D0, 2400.0D0, 2500.0D0, 2740.0D0, 3440.0D0, 4000.0D0, 4400.0D0, 5500.0D0, 7000.0D0, 9000.0D0, 12500.0D0, 22000.0D0, 34000.0D0, 1.0D9/) real(kind=dp), public, dimension(30), save :: X_GRID = (/5.76D0, 5.18D0, 4.65D0, 4.16D0, 3.73D0, 3.40D0, 3.11D0, 2.74D0, 2.63D0, 2.62D0, 2.54D0, 2.50D0, 2.58D0, 2.78D0, 3.01D0, 3.12D0, 2.86D0, 2.58D0, 2.35D0, 2.00D0, 1.58D0, 1.42D0, 1.32D0, 1.00D0, 0.75D0, 0.48D0, 0.28D0, 0.12D0, 0.05D0, 0.00D0/) real(kind=dp), public :: SH2_DERIV (1:105) real(kind=dp), public :: SCO_DERIV (1:8,1:6) real(kind=dp), public :: X_DERIV (1:30)","tags":"","url":"module/uclpdr_module.html"},{"title":"global_module – 3D-PDR","text":"Uses iso_c_binding healpix_types definitions module~~global_module~~UsesGraph module~global_module global_module iso_c_binding iso_c_binding module~global_module->iso_c_binding module~definitions definitions module~global_module->module~definitions module~healpix_types~2 healpix_types module~global_module->module~healpix_types~2 module~healpix_types~2->module~definitions Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~global_module~~UsedByGraph module~global_module global_module proc~allocations allocations proc~allocations->module~global_module proc~analyse_chemistry ANALYSE_CHEMISTRY proc~analyse_chemistry->module~global_module proc~calc_columndens calc_columndens proc~calc_columndens->module~global_module proc~calc_crattenuation calc_CRattenuation proc~calc_crattenuation->module~global_module proc~calc_uvfield CALC_UVFIELD proc~calc_uvfield->module~global_module proc~calculate_reaction_rates CALCULATE_REACTION_RATES proc~calculate_reaction_rates->module~global_module proc~changetemperature changetemperature proc~changetemperature->module~global_module proc~checkconvergence checkconvergence proc~checkconvergence->module~global_module proc~chemicaliterations chemicaliterations proc~chemicaliterations->module~global_module proc~coolingfunctions coolingfunctions proc~coolingfunctions->module~global_module proc~h2_formation_rate H2_FORMATION_RATE proc~h2_formation_rate->module~global_module proc~read_rates READ_RATES proc~read_rates->module~global_module proc~read_species READ_SPECIES proc~read_species->module~global_module proc~readdensity readdensity proc~readdensity->module~global_module proc~readparams readparams proc~readparams->module~global_module proc~writeoutputs writeoutputs proc~writeoutputs->module~global_module proc~writeoutputs~2 writeoutputs proc~writeoutputs~2->module~global_module proc~writeparams writeparams proc~writeparams->module~global_module program~threedpdr threedpdr program~threedpdr->module~global_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer(kind=i4b), public :: NH integer(kind=i4b), public :: ND integer(kind=i4b), public :: NH2 integer(kind=i4b), public :: NHD integer(kind=i4b), public :: NC integer(kind=i4b), public :: NCx integer(kind=i4b), public :: NCO integer(kind=i4b), public :: NO integer(kind=i4b), public :: NPROTON integer(kind=i4b), public :: NH2O integer(kind=i4b), public :: NHe integer(kind=i4b), public :: NMG integer(kind=i4b), public :: NMGx integer(kind=i4b), public :: NN integer(kind=i4b), public :: NFE integer(kind=i4b), public :: NFEx integer(kind=i4b), public :: NSI integer(kind=i4b), public :: NSIx integer(kind=i4b), public :: NCA integer(kind=i4b), public :: NCAx integer(kind=i4b), public :: NCAxx integer(kind=i4b), public :: NS integer(kind=i4b), public :: NSx integer(kind=i4b), public :: NCS integer(kind=i4b), public :: NOSH integer(kind=i4b), public :: NCL integer(kind=i4b), public :: NCLx integer(kind=i4b), public :: NH2x integer(kind=i4b), public :: NHEx integer(kind=i4b), public :: NOx integer(kind=i4b), public :: NNx integer(kind=i4b), public :: NNA integer(kind=i4b), public :: NNAx integer(kind=i4b), public :: NCH integer(kind=i4b), public :: NCH2 integer(kind=i4b), public :: NOH integer(kind=i4b), public :: NO2 integer(kind=i4b), public :: NH3x integer(kind=i4b), public :: NH3Ox integer(kind=i4b), public :: NHCOx integer(kind=i4b), public :: NCHx integer(kind=i4b), public :: NCN integer(kind=i4b), public :: NOHx integer(kind=i4b), public :: NSiO integer(kind=i4b), public :: NC2H integer(kind=i4b), public :: NHCN integer(kind=i4b), public :: NHNC integer(kind=i4b), public :: NN2Hx integer(kind=i4b), public, bind(c,name=\"0\") :: NELECT real(kind=dp), public :: metallicity real(kind=dp), public :: omega real(kind=dp), public :: grain_radius real(kind=dp), public, allocatable :: allheating (:)","tags":"","url":"module/global_module.html"},{"title":"functions_module – 3D-PDR","text":"Uses healpix_types definitions module~~functions_module~~UsesGraph module~functions_module functions_module module~definitions definitions module~functions_module->module~definitions module~healpix_types~2 healpix_types module~functions_module->module~healpix_types~2 module~healpix_types~2->module~definitions Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~functions_module~~UsedByGraph module~functions_module functions_module proc~calculate_reaction_rates CALCULATE_REACTION_RATES proc~calculate_reaction_rates->module~functions_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces interface public  function H2PDRATE(k0, g0, av, nh2) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: k0 real(kind=dp), intent(in) :: g0 real(kind=dp), intent(in) :: av real(kind=dp), intent(in) :: nh2 Return Value real(kind=dp) interface public  function COPDRATE(k0, g0, av, nco, nh2) result(copdrate) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: k0 real(kind=dp), intent(in) :: g0 real(kind=dp), intent(in) :: av real(kind=dp), intent(in) :: nco real(kind=dp), intent(in) :: nh2 Return Value real(kind=dp) interface public  function CIPDRATE(K0, G0, AV, KAV, NCI, nh2, TGAS) result(cipdrate) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: K0 real(kind=dp), intent(in) :: G0 real(kind=dp), intent(in) :: AV real(kind=dp), intent(in) :: KAV real(kind=dp), intent(in) :: NCI real(kind=dp), intent(in) :: nh2 real(kind=dp), intent(in) :: TGAS Return Value real(kind=dp) interface public  function SIPDRATE(K0, G0, AV, KAV, NSI) result(sipdrate) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: K0 real(kind=dp), intent(in) :: G0 real(kind=dp), intent(in) :: AV real(kind=dp), intent(in) :: KAV real(kind=dp), intent(in) :: NSI Return Value real(kind=dp) interface public  function H2SHIELD1(nh2, DOPW, RADW) result(h2shield1) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: nh2 real(kind=dp), intent(in) :: DOPW real(kind=dp), intent(in) :: RADW Return Value real(kind=dp) interface public  function h2shield2(nh2) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: nh2 Return Value real(kind=dp) interface public  function COSHIELD(NCO, NH2) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: NCO real(kind=dp), intent(in) :: NH2 Return Value real(kind=dp) interface public  function SCATTER(AV, LAMBDA) result(scatter) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: AV real(kind=dp), intent(in) :: LAMBDA Return Value real(kind=dp) interface public  function XLAMBDA(lambda) result(xlambda) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: lambda Return Value real(kind=dp) interface public  function LBAR(NCO, NH2) result(lbar) Arguments Type Intent Optional Attributes Name real(kind=dp) :: NCO real(kind=dp) :: NH2 Return Value real(kind=dp) interface public  function calculate_heating(density, gas_temperature, dust_temperature, UV_field, v_turb, nspec, init_abundance, nreac, rate) Arguments Type Intent Optional Attributes Name real(kind=dp) :: density real(kind=dp) :: gas_temperature real(kind=dp) :: dust_temperature real(kind=dp) :: UV_field real(kind=dp) :: v_turb integer(kind=i4b) :: nspec real(kind=dp) :: init_abundance (1:nspec) integer(kind=i4b) :: nreac real(kind=dp) :: rate (1:nreac) Return Value real(kind=dp)","tags":"","url":"module/functions_module.html"},{"title":"chemistry_module – 3D-PDR","text":"Uses iso_c_binding healpix_types module~~chemistry_module~~UsesGraph module~chemistry_module chemistry_module iso_c_binding iso_c_binding module~chemistry_module->iso_c_binding module~healpix_types~2 healpix_types module~chemistry_module->module~healpix_types~2 module~definitions definitions module~healpix_types~2->module~definitions Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~chemistry_module~~UsedByGraph module~chemistry_module chemistry_module proc~readdensity readdensity proc~readdensity->module~chemistry_module proc~readparams readparams proc~readparams->module~chemistry_module program~threedpdr threedpdr program~threedpdr->module~chemistry_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial real(kind=dp), public, bind(c,name=\"0\") :: relative_abundance_tolerance real(kind=dp), public, bind(c,name=\"0\") :: absolute_abundance_tolerance","tags":"","url":"module/chemistry_module.html"},{"title":"m_Ray_box – 3D-PDR","text":"Uses m_Mesh module~~m_ray_box~~UsesGraph module~m_ray_box m_Ray_box module~m_mesh m_Mesh module~m_ray_box->module~m_mesh Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~m_ray_box~~UsedByGraph module~m_ray_box m_Ray_box proc~calc_columndens calc_columndens proc~calc_columndens->module~m_ray_box proc~coolingfunctions coolingfunctions proc~coolingfunctions->module~m_ray_box proc~escape_probability escape_probability proc~escape_probability->module~m_ray_box proc~evaluation_points evaluation_points proc~evaluation_points->module~m_ray_box proc~readdensity readdensity proc~readdensity->module~m_ray_box program~init3dpdr init3DPDR program~init3dpdr->module~m_ray_box Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial real(kind=RK), public, parameter :: PC = 3.08568025D+18 Derived Types type, public :: box Components Type Visibility Attributes Name Initial real(kind=RK), public :: min (3) real(kind=RK), public :: max (3) type, public :: HEALPix_ray Components Type Visibility Attributes Name Initial integer, public :: eval real(kind=RK), public :: length real(kind=RK), public :: origin (3) real(kind=RK), public :: angle (2) Subroutines public recursive subroutine octree (ray, parent, level, contribution, contribution_1D, density_3D, density_1D) Arguments Type Intent Optional Attributes Name type( HEALPix_ray ), intent(in) :: ray type( box ), intent(in) :: parent integer, intent(in) :: level real(kind=RK), intent(inout) :: contribution real(kind=RK), intent(inout) :: contribution_1D real(kind=RK) :: density_3D (:,:,:) real(kind=RK) :: density_1D (:)","tags":"","url":"module/m_ray_box.html"},{"title":"healpix_types – 3D-PDR","text":"Uses definitions module~~healpix_types~2~~UsesGraph module~healpix_types~2 healpix_types module~definitions definitions module~healpix_types~2->module~definitions Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~healpix_types~2~~UsedByGraph module~healpix_types~2 healpix_types module~chemistry_module chemistry_module module~chemistry_module->module~healpix_types~2 module~functions_module functions_module module~functions_module->module~healpix_types~2 module~global_module global_module module~global_module->module~healpix_types~2 module~healpix_module healpix_module module~healpix_module->module~healpix_types~2 module~m_ray_box~2 m_Ray_box module~m_ray_box~2->module~healpix_types~2 module~maincode_module maincode_module module~m_ray_box~2->module~maincode_module module~maincode_local maincode_local module~maincode_local->module~healpix_types~2 module~maincode_module->module~healpix_types~2 module~uclpdr_module uclpdr_module module~uclpdr_module->module~healpix_types~2 proc~allocations allocations proc~allocations->module~healpix_types~2 proc~allocations->module~global_module proc~allocations->module~maincode_module proc~allocations->module~uclpdr_module proc~analyse_chemistry ANALYSE_CHEMISTRY proc~analyse_chemistry->module~healpix_types~2 proc~analyse_chemistry->module~global_module proc~ang2pix_nest_id ang2pix_nest_id proc~ang2pix_nest_id->module~healpix_types~2 proc~ang2pix_nest_id->module~healpix_module proc~calc_columndens calc_columndens proc~calc_columndens->module~healpix_types~2 proc~calc_columndens->module~global_module proc~calc_columndens->module~maincode_module proc~calc_crattenuation calc_CRattenuation proc~calc_crattenuation->module~healpix_types~2 proc~calc_crattenuation->module~global_module proc~calc_crattenuation->module~maincode_module proc~calc_uvfield CALC_UVFIELD proc~calc_uvfield->module~healpix_types~2 proc~calc_uvfield->module~global_module proc~calc_uvfield->module~maincode_module proc~calculate_dust_temperatures CALCULATE_DUST_TEMPERATURES proc~calculate_dust_temperatures->module~healpix_types~2 proc~calculate_dust_temperatures->module~maincode_module proc~calculate_lte_populations CALCULATE_LTE_POPULATIONS proc~calculate_lte_populations->module~healpix_types~2 proc~calculate_partition_function CALCULATE_PARTITION_FUNCTION proc~calculate_partition_function->module~healpix_types~2 proc~calculate_reaction_rates CALCULATE_REACTION_RATES proc~calculate_reaction_rates->module~healpix_types~2 proc~calculate_reaction_rates->module~functions_module proc~calculate_reaction_rates->module~global_module proc~calculate_reaction_rates->module~maincode_module proc~checkconvergence checkconvergence proc~checkconvergence->module~healpix_types~2 proc~checkconvergence->module~global_module proc~checkconvergence->module~maincode_module proc~chemicaliterations chemicaliterations proc~chemicaliterations->module~healpix_types~2 proc~chemicaliterations->module~global_module proc~chemicaliterations->module~maincode_local proc~chemicaliterations->module~maincode_module proc~cipdrate CIPDRATE proc~cipdrate->module~healpix_types~2 proc~coolingfunctions coolingfunctions proc~coolingfunctions->module~healpix_types~2 proc~coolingfunctions->module~global_module proc~coolingfunctions->module~maincode_module proc~copdrate COPDRATE proc~copdrate->module~healpix_types~2 proc~coshield COSHIELD proc~coshield->module~healpix_types~2 proc~coshield->module~uclpdr_module proc~escape_probability escape_probability proc~escape_probability->module~healpix_types~2 proc~escape_probability->module~healpix_module proc~escape_probability->module~maincode_module proc~evaluation_points evaluation_points proc~evaluation_points->module~healpix_types~2 proc~evaluation_points->module~healpix_module proc~evaluation_points->module~maincode_module proc~gauss_jordan GAUSS_JORDAN proc~gauss_jordan->module~healpix_types~2 proc~gauss_jordan_writes GAUSS_JORDAN_writes proc~gauss_jordan_writes->module~healpix_types~2 proc~gauss_jordan_writes->module~maincode_module proc~h2_formation_rate H2_FORMATION_RATE proc~h2_formation_rate->module~healpix_types~2 proc~h2_formation_rate->module~global_module proc~h2pdrate H2PDRATE proc~h2pdrate->module~healpix_types~2 proc~h2pdrate->module~maincode_module proc~h2shield1 H2SHIELD1 proc~h2shield1->module~healpix_types~2 proc~h2shield2 H2SHIELD2 proc~h2shield2->module~healpix_types~2 proc~h2shield2->module~uclpdr_module proc~heapsort heapsort proc~heapsort->module~healpix_types~2 proc~lbar LBAR proc~lbar->module~healpix_types~2 proc~mk_pix2xy mk_pix2xy proc~mk_pix2xy->module~healpix_types~2 proc~mk_pix2xy->module~healpix_module proc~mk_xy2pix mk_xy2pix proc~mk_xy2pix->module~healpix_types~2 proc~mk_xy2pix->module~healpix_module proc~pix2ang_nest pix2ang_nest proc~pix2ang_nest->module~healpix_types~2 proc~pix2ang_nest->module~healpix_module proc~pix2vec_nest pix2vec_nest proc~pix2vec_nest->module~healpix_types~2 proc~pix2vec_nest->module~healpix_module proc~read_rates READ_RATES proc~read_rates->module~healpix_types~2 proc~read_rates->module~global_module proc~read_species READ_SPECIES proc~read_species->module~healpix_types~2 proc~read_species->module~global_module proc~read_species->module~maincode_module proc~readdensity readdensity proc~readdensity->module~healpix_types~2 proc~readdensity->module~chemistry_module proc~readdensity->module~global_module proc~readdensity->module~healpix_module proc~readdensity->module~maincode_local proc~readdensity->module~maincode_module proc~readinput READINPUT proc~readinput->module~healpix_types~2 proc~readparams readparams proc~readparams->module~healpix_types~2 proc~readparams->module~chemistry_module proc~readparams->module~global_module proc~readparams->module~maincode_module proc~scatter SCATTER proc~scatter->module~healpix_types~2 proc~sipdrate SIPDRATE proc~sipdrate->module~healpix_types~2 proc~solvlevpop solvlevpop proc~solvlevpop->module~healpix_types~2 proc~splie2 SPLIE2 proc~splie2->module~healpix_types~2 proc~splin2 SPLIN2 proc~splin2->module~healpix_types~2 proc~spline SPLINE proc~spline->module~healpix_types~2 proc~splint SPLINT proc~splint->module~healpix_types~2 proc~vec2ang vec2ang proc~vec2ang->module~healpix_types~2 proc~writeoutputs writeoutputs proc~writeoutputs->module~healpix_types~2 proc~writeoutputs->module~global_module proc~writeoutputs->module~maincode_module proc~writeoutputs~2 writeoutputs proc~writeoutputs~2->module~healpix_types~2 proc~writeoutputs~2->module~global_module proc~writeoutputs~2->module~maincode_module proc~writeparams writeparams proc~writeparams->module~healpix_types~2 proc~writeparams->module~global_module proc~writeparams->module~maincode_module proc~xlambda XLAMBDA proc~xlambda->module~healpix_types~2 proc~xlambda->module~uclpdr_module program~threedpdr threedpdr program~threedpdr->module~healpix_types~2 program~threedpdr->module~chemistry_module program~threedpdr->module~global_module program~threedpdr->module~healpix_module program~threedpdr->module~maincode_local program~threedpdr->module~maincode_module program~threedpdr->module~uclpdr_module module~m_ioandvisu m_IOAndVisu module~m_ioandvisu->module~maincode_module proc~changetemperature changetemperature proc~changetemperature->module~global_module proc~changetemperature->module~maincode_local proc~changetemperature->module~maincode_module proc~initialization initialization proc~initialization->module~maincode_module proc~read_command_line read_command_line proc~read_command_line->module~maincode_module proc~readcoolants readcoolants proc~readcoolants->module~maincode_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public, parameter :: i8b = SELECTED_INT_KIND(16) integer, public, parameter :: i4b = SELECTED_INT_KIND(9) integer, public, parameter :: i2b = SELECTED_INT_KIND(4) integer, public, parameter :: i1b = SELECTED_INT_KIND(2) integer, public, parameter :: lgt = KIND(.TRUE.) integer, public, parameter :: spc = KIND((1.0_sp, 1.0_sp)) integer, public, parameter :: dpc = KIND((1.0_dp, 1.0_dp)) integer(kind=I8B), public, parameter :: max_i8b = HUGE(1_i8b) integer, public, parameter :: max_i4b = HUGE(1_i4b) integer, public, parameter :: max_i2b = HUGE(1_i2b) integer, public, parameter :: max_i1b = 127 real(kind=sp), public, parameter :: max_sp = HUGE(1.0_sp) real(kind=dp), public, parameter :: max_dp = HUGE(1.0_dp) real(kind=dp), public, parameter :: QUARTPI = 0.785398163397448309615660845819875721049_dp real(kind=dp), public, parameter :: HALFPI = 1.570796326794896619231321691639751442099_dp real(kind=dp), public, parameter :: PI = 3.141592653589793238462643383279502884197_dp real(kind=dp), public, parameter :: TWOPI = 6.283185307179586476925286766559005768394_dp real(kind=dp), public, parameter :: FOURPI = 12.56637061435917295385057353311801153679_dp real(kind=dp), public, parameter :: SQRT2 = 1.41421356237309504880168872420969807856967_dp real(kind=dp), public, parameter :: SQ4PI_INV = 0.2820947917738781434740397257803862929220_dp real(kind=dp), public, parameter :: TWOTHIRD = 0.6666666666666666666666666666666666666666_dp real(kind=DP), public, parameter :: RAD2DEG = 180.0_DP/PI real(kind=DP), public, parameter :: DEG2RAD = PI/180.0_DP real(kind=SP), public, parameter :: hpx_sbadval = -1.6375e30_sp real(kind=DP), public, parameter :: hpx_dbadval = -1.6375e30_dp integer, public, parameter :: filenamelen = 1024 real(kind=dp), public, parameter :: KvS = 1.0_dp real(kind=dp), public, parameter :: sgQ = -1.0_dp real(kind=dp), public, parameter :: SW1 = -1.0_dp real(kind=dp), public, parameter :: iKvS = 1.0_dp/KvS real(kind=dp), public, parameter :: KB = 1.38065040D-16 real(kind=dp), public, parameter :: C = 2.99792458D+10 real(kind=dp), public, parameter :: MP = 1.67262164D-24 real(kind=dp), public, parameter :: HP = 6.62606896D-27 real(kind=dp), public, parameter :: HB = 1.05457163D-27 real(kind=dp), public, parameter :: HK = 4.79923734D-11 real(kind=dp), public, parameter :: NA = 6.02214179D+23 real(kind=dp), public, parameter :: AU = 1.66053878D-24 real(kind=dp), public, parameter :: MH = 1.67372346D-24 real(kind=dp), public, parameter :: ME = 9.10938215D-28 real(kind=dp), public, parameter :: EC = 4.80320427D-10 real(kind=dp), public, parameter :: PC = 3.08568025D+18 real(kind=dp), public, parameter :: EV = 1.60217646D-12","tags":"","url":"module/healpix_types~2.html"},{"title":"healpix_types – 3D-PDR","text":"Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: healpix_version = '2.12a' integer, public, parameter :: i4b = SELECTED_INT_KIND(9) integer, public, parameter :: i8b = SELECTED_INT_KIND(16) integer, public, parameter :: i2b = SELECTED_INT_KIND(4) integer, public, parameter :: i1b = SELECTED_INT_KIND(2) integer, public, parameter :: sp = SELECTED_REAL_KIND(5, 30) integer, public, parameter :: dp = SELECTED_REAL_KIND(12, 200) integer, public, parameter :: lgt = KIND(.TRUE.) integer, public, parameter :: spc = KIND((1.0_sp, 1.0_sp)) integer, public, parameter :: dpc = KIND((1.0_dp, 1.0_dp)) integer(kind=I8B), public, parameter :: max_i8b = HUGE(1_i8b) integer, public, parameter :: max_i4b = HUGE(1_i4b) integer, public, parameter :: max_i2b = HUGE(1_i2b) integer, public, parameter :: max_i1b = 127 real(kind=sp), public, parameter :: max_sp = HUGE(1.0_sp) real(kind=dp), public, parameter :: max_dp = HUGE(1.0_dp) real(kind=dp), public, parameter :: QUARTPI = 0.785398163397448309615660845819875721049_dp real(kind=dp), public, parameter :: HALFPI = 1.570796326794896619231321691639751442099_dp real(kind=dp), public, parameter :: PI = 3.141592653589793238462643383279502884197_dp real(kind=dp), public, parameter :: TWOPI = 6.283185307179586476925286766559005768394_dp real(kind=dp), public, parameter :: FOURPI = 12.56637061435917295385057353311801153679_dp real(kind=dp), public, parameter :: SQRT2 = 1.41421356237309504880168872420969807856967_dp real(kind=dp), public, parameter :: EULER = 0.5772156649015328606065120900824024310422_dp real(kind=dp), public, parameter :: SQ4PI_INV = 0.2820947917738781434740397257803862929220_dp real(kind=dp), public, parameter :: TWOTHIRD = 0.6666666666666666666666666666666666666666_dp real(kind=DP), public, parameter :: RAD2DEG = 180.0_DP/PI real(kind=DP), public, parameter :: DEG2RAD = PI/180.0_DP real(kind=SP), public, parameter :: hpx_sbadval = -1.6375e30_sp real(kind=DP), public, parameter :: hpx_dbadval = -1.6375e30_dp integer, public, parameter :: filenamelen = 1024 real(kind=dp), public, parameter :: KvS = 1.0_dp","tags":"","url":"module/healpix_types.html"},{"title":"definitions – 3D-PDR","text":"Used by module~~definitions~~UsedByGraph module~definitions definitions module~functions_module functions_module module~functions_module->module~definitions module~healpix_types~2 healpix_types module~functions_module->module~healpix_types~2 module~global_module global_module module~global_module->module~definitions module~global_module->module~healpix_types~2 module~healpix_module healpix_module module~healpix_module->module~definitions module~healpix_module->module~healpix_types~2 module~healpix_types~2->module~definitions module~maincode_local maincode_local module~maincode_local->module~definitions module~maincode_local->module~healpix_types~2 module~maincode_module maincode_module module~maincode_module->module~definitions module~maincode_module->module~healpix_types~2 module~uclpdr_module uclpdr_module module~uclpdr_module->module~definitions module~uclpdr_module->module~healpix_types~2 proc~analyse_chemistry ANALYSE_CHEMISTRY proc~analyse_chemistry->module~definitions proc~analyse_chemistry->module~global_module proc~analyse_chemistry->module~healpix_types~2 proc~ang2pix_nest_id ang2pix_nest_id proc~ang2pix_nest_id->module~definitions proc~ang2pix_nest_id->module~healpix_module proc~ang2pix_nest_id->module~healpix_types~2 proc~calculate_reaction_rates CALCULATE_REACTION_RATES proc~calculate_reaction_rates->module~definitions proc~calculate_reaction_rates->module~functions_module proc~calculate_reaction_rates->module~global_module proc~calculate_reaction_rates->module~healpix_types~2 proc~calculate_reaction_rates->module~maincode_module proc~cipdrate CIPDRATE proc~cipdrate->module~definitions proc~cipdrate->module~healpix_types~2 proc~copdrate COPDRATE proc~copdrate->module~definitions proc~copdrate->module~healpix_types~2 proc~coshield COSHIELD proc~coshield->module~definitions proc~coshield->module~healpix_types~2 proc~coshield->module~uclpdr_module proc~escape_probability escape_probability proc~escape_probability->module~definitions proc~escape_probability->module~healpix_module proc~escape_probability->module~healpix_types~2 proc~escape_probability->module~maincode_module proc~evaluation_points evaluation_points proc~evaluation_points->module~definitions proc~evaluation_points->module~healpix_module proc~evaluation_points->module~healpix_types~2 proc~evaluation_points->module~maincode_module proc~gauss_jordan GAUSS_JORDAN proc~gauss_jordan->module~definitions proc~gauss_jordan->module~healpix_types~2 proc~gauss_jordan_writes GAUSS_JORDAN_writes proc~gauss_jordan_writes->module~definitions proc~gauss_jordan_writes->module~healpix_types~2 proc~gauss_jordan_writes->module~maincode_module proc~h2_formation_rate H2_FORMATION_RATE proc~h2_formation_rate->module~definitions proc~h2_formation_rate->module~global_module proc~h2_formation_rate->module~healpix_types~2 proc~h2pdrate H2PDRATE proc~h2pdrate->module~definitions proc~h2pdrate->module~healpix_types~2 proc~h2pdrate->module~maincode_module proc~h2shield1 H2SHIELD1 proc~h2shield1->module~definitions proc~h2shield1->module~healpix_types~2 proc~h2shield2 H2SHIELD2 proc~h2shield2->module~definitions proc~h2shield2->module~healpix_types~2 proc~h2shield2->module~uclpdr_module proc~heapsort heapsort proc~heapsort->module~definitions proc~heapsort->module~healpix_types~2 proc~lbar LBAR proc~lbar->module~definitions proc~lbar->module~healpix_types~2 proc~mk_pix2xy mk_pix2xy proc~mk_pix2xy->module~definitions proc~mk_pix2xy->module~healpix_module proc~mk_pix2xy->module~healpix_types~2 proc~mk_xy2pix mk_xy2pix proc~mk_xy2pix->module~definitions proc~mk_xy2pix->module~healpix_module proc~mk_xy2pix->module~healpix_types~2 proc~pix2ang_nest pix2ang_nest proc~pix2ang_nest->module~definitions proc~pix2ang_nest->module~healpix_module proc~pix2ang_nest->module~healpix_types~2 proc~pix2vec_nest pix2vec_nest proc~pix2vec_nest->module~definitions proc~pix2vec_nest->module~healpix_module proc~pix2vec_nest->module~healpix_types~2 proc~read_command_line read_command_line proc~read_command_line->module~definitions proc~read_command_line->module~maincode_module proc~read_rates READ_RATES proc~read_rates->module~definitions proc~read_rates->module~global_module proc~read_rates->module~healpix_types~2 proc~read_species READ_SPECIES proc~read_species->module~definitions proc~read_species->module~global_module proc~read_species->module~healpix_types~2 proc~read_species->module~maincode_module proc~readdensity readdensity proc~readdensity->module~definitions proc~readdensity->module~global_module proc~readdensity->module~healpix_module proc~readdensity->module~healpix_types~2 proc~readdensity->module~maincode_local proc~readdensity->module~maincode_module module~chemistry_module chemistry_module proc~readdensity->module~chemistry_module proc~readparams readparams proc~readparams->module~definitions proc~readparams->module~global_module proc~readparams->module~healpix_types~2 proc~readparams->module~maincode_module proc~readparams->module~chemistry_module proc~scatter SCATTER proc~scatter->module~definitions proc~scatter->module~healpix_types~2 proc~sipdrate SIPDRATE proc~sipdrate->module~definitions proc~sipdrate->module~healpix_types~2 proc~solvlevpop solvlevpop proc~solvlevpop->module~definitions proc~solvlevpop->module~healpix_types~2 proc~splie2 SPLIE2 proc~splie2->module~definitions proc~splie2->module~healpix_types~2 proc~splin2 SPLIN2 proc~splin2->module~definitions proc~splin2->module~healpix_types~2 proc~spline SPLINE proc~spline->module~definitions proc~spline->module~healpix_types~2 proc~splint SPLINT proc~splint->module~definitions proc~splint->module~healpix_types~2 proc~vec2ang vec2ang proc~vec2ang->module~definitions proc~vec2ang->module~healpix_types~2 proc~writeparams writeparams proc~writeparams->module~definitions proc~writeparams->module~global_module proc~writeparams->module~healpix_types~2 proc~writeparams->module~maincode_module proc~xlambda XLAMBDA proc~xlambda->module~definitions proc~xlambda->module~healpix_types~2 proc~xlambda->module~uclpdr_module program~threedpdr threedpdr program~threedpdr->module~definitions program~threedpdr->module~global_module program~threedpdr->module~healpix_module program~threedpdr->module~healpix_types~2 program~threedpdr->module~maincode_local program~threedpdr->module~maincode_module program~threedpdr->module~uclpdr_module program~threedpdr->module~chemistry_module module~chemistry_module->module~healpix_types~2 module~m_ioandvisu m_IOAndVisu module~m_ioandvisu->module~maincode_module module~m_ray_box~2 m_Ray_box module~m_ray_box~2->module~healpix_types~2 module~m_ray_box~2->module~maincode_module proc~allocations allocations proc~allocations->module~global_module proc~allocations->module~healpix_types~2 proc~allocations->module~maincode_module proc~allocations->module~uclpdr_module proc~calc_columndens calc_columndens proc~calc_columndens->module~global_module proc~calc_columndens->module~healpix_types~2 proc~calc_columndens->module~maincode_module proc~calc_crattenuation calc_CRattenuation proc~calc_crattenuation->module~global_module proc~calc_crattenuation->module~healpix_types~2 proc~calc_crattenuation->module~maincode_module proc~calc_uvfield CALC_UVFIELD proc~calc_uvfield->module~global_module proc~calc_uvfield->module~healpix_types~2 proc~calc_uvfield->module~maincode_module proc~calculate_dust_temperatures CALCULATE_DUST_TEMPERATURES proc~calculate_dust_temperatures->module~healpix_types~2 proc~calculate_dust_temperatures->module~maincode_module proc~calculate_lte_populations CALCULATE_LTE_POPULATIONS proc~calculate_lte_populations->module~healpix_types~2 proc~calculate_partition_function CALCULATE_PARTITION_FUNCTION proc~calculate_partition_function->module~healpix_types~2 proc~changetemperature changetemperature proc~changetemperature->module~global_module proc~changetemperature->module~maincode_local proc~changetemperature->module~maincode_module proc~checkconvergence checkconvergence proc~checkconvergence->module~global_module proc~checkconvergence->module~healpix_types~2 proc~checkconvergence->module~maincode_module proc~chemicaliterations chemicaliterations proc~chemicaliterations->module~global_module proc~chemicaliterations->module~healpix_types~2 proc~chemicaliterations->module~maincode_local proc~chemicaliterations->module~maincode_module proc~coolingfunctions coolingfunctions proc~coolingfunctions->module~global_module proc~coolingfunctions->module~healpix_types~2 proc~coolingfunctions->module~maincode_module proc~initialization initialization proc~initialization->module~maincode_module proc~readcoolants readcoolants proc~readcoolants->module~maincode_module proc~readinput READINPUT proc~readinput->module~healpix_types~2 proc~writeoutputs writeoutputs proc~writeoutputs->module~global_module proc~writeoutputs->module~healpix_types~2 proc~writeoutputs->module~maincode_module proc~writeoutputs~2 writeoutputs proc~writeoutputs~2->module~global_module proc~writeoutputs~2->module~healpix_types~2 proc~writeoutputs~2->module~maincode_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public, parameter :: DP = selected_real_kind(p=15) integer, public, parameter :: SP = selected_real_kind(p=6) integer, public, parameter :: DDP = selected_real_kind(p=16) integer, public, parameter :: PR = SP integer, public, parameter :: ILP = 4","tags":"","url":"module/definitions.html"},{"title":"m_Ray_box – 3D-PDR","text":"Uses healpix_types maincode_module m_Mesh module~~m_ray_box~2~~UsesGraph module~m_ray_box~2 m_Ray_box module~healpix_types~2 healpix_types module~m_ray_box~2->module~healpix_types~2 module~m_mesh m_Mesh module~m_ray_box~2->module~m_mesh module~maincode_module maincode_module module~m_ray_box~2->module~maincode_module module~definitions definitions module~healpix_types~2->module~definitions module~maincode_module->module~healpix_types~2 iso_c_binding iso_c_binding module~maincode_module->iso_c_binding module~maincode_module->module~definitions Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public :: levels integer, public, allocatable :: maxpoints_ray (:) type( box ), public :: box1 type( HEALPix_ray ), public :: ray real(kind=dp), public :: thfpix real(kind=dp), public :: phfpix real(kind=dp), public :: contribution real(kind=dp), public :: corner_min (3) real(kind=dp), public :: corner_max (3) Derived Types type, public :: box Components Type Visibility Attributes Name Initial real(kind=RK), public :: min (3) real(kind=RK), public :: max (3) type, public :: HEALPix_ray Components Type Visibility Attributes Name Initial integer, public :: eval real(kind=RK), public :: length real(kind=RK), public :: origin (3) real(kind=RK), public :: angle (2) Subroutines public recursive subroutine raytheia_table (ray, parent, level, source, ipix) Arguments Type Intent Optional Attributes Name type( HEALPix_ray ), intent(in) :: ray type( box ), intent(in) :: parent integer, intent(in) :: level integer, intent(in) :: source integer, intent(in) :: ipix","tags":"","url":"module/m_ray_box~2.html"},{"title":"m_visual – 3D-PDR","text":"InitVisu Write_XDMF_One Uses m_paramters module~~m_visual~~UsesGraph module~m_visual m_visual module~m_paramters m_paramters module~m_visual->module~m_paramters Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~m_visual~~UsedByGraph module~m_visual m_visual program~convert_fin2h5 convert_fin2h5 program~convert_fin2h5->module~m_visual Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine initvisual () Arguments None","tags":"","url":"module/m_visual.html"},{"title":"threedpdr – 3D-PDR","text":"Uses healpix_types maincode_module global_module healpix_module definitions chemistry_module maincode_local uclpdr_module program~~threedpdr~~UsesGraph program~threedpdr threedpdr module~chemistry_module chemistry_module program~threedpdr->module~chemistry_module module~definitions definitions program~threedpdr->module~definitions module~global_module global_module program~threedpdr->module~global_module module~healpix_module healpix_module program~threedpdr->module~healpix_module module~healpix_types~2 healpix_types program~threedpdr->module~healpix_types~2 module~maincode_local maincode_local program~threedpdr->module~maincode_local module~maincode_module maincode_module program~threedpdr->module~maincode_module module~uclpdr_module uclpdr_module program~threedpdr->module~uclpdr_module module~chemistry_module->module~healpix_types~2 iso_c_binding iso_c_binding module~chemistry_module->iso_c_binding module~global_module->module~definitions module~global_module->module~healpix_types~2 module~global_module->iso_c_binding module~healpix_module->module~definitions module~healpix_module->module~healpix_types~2 module~healpix_types~2->module~definitions module~maincode_local->module~definitions module~maincode_local->module~healpix_types~2 module~maincode_module->module~definitions module~maincode_module->module~healpix_types~2 module~maincode_module->iso_c_binding module~uclpdr_module->module~definitions module~uclpdr_module->module~healpix_types~2 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~threedpdr~~CallsGraph program~threedpdr threedpdr allocations allocations program~threedpdr->allocations calc_columndens calc_columndens program~threedpdr->calc_columndens calc_crattenuation calc_crattenuation program~threedpdr->calc_crattenuation calc_uvfield calc_uvfield program~threedpdr->calc_uvfield changetemperature changetemperature program~threedpdr->changetemperature checkconvergence checkconvergence program~threedpdr->checkconvergence chemicaliterations chemicaliterations program~threedpdr->chemicaliterations coolingfunctions coolingfunctions program~threedpdr->coolingfunctions evaluation_points evaluation_points program~threedpdr->evaluation_points initialization initialization program~threedpdr->initialization mk_xy2pix mk_xy2pix program~threedpdr->mk_xy2pix pix2ang_nest pix2ang_nest program~threedpdr->pix2ang_nest pix2vec_nest pix2vec_nest program~threedpdr->pix2vec_nest read_command_line read_command_line program~threedpdr->read_command_line read_rates read_rates program~threedpdr->read_rates read_species read_species program~threedpdr->read_species readcoolants readcoolants program~threedpdr->readcoolants readdensity readdensity program~threedpdr->readdensity readparams readparams program~threedpdr->readparams writeoutputs writeoutputs program~threedpdr->writeoutputs Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial real(kind=dp) :: thfpix real(kind=dp) :: phfpix","tags":"","url":"program/threedpdr.html"},{"title":"convert_fin2h5 – 3D-PDR","text":"Uses m_paramters m_visual m_writeoutputs program~~convert_fin2h5~~UsesGraph program~convert_fin2h5 convert_fin2h5 module~m_paramters m_paramters program~convert_fin2h5->module~m_paramters module~m_visual m_visual program~convert_fin2h5->module~m_visual module~m_writeoutputs m_writeoutputs program~convert_fin2h5->module~m_writeoutputs module~m_visual->module~m_paramters module~m_writeoutputs->module~m_paramters hdf5 hdf5 module~m_writeoutputs->hdf5 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~convert_fin2h5~~CallsGraph program~convert_fin2h5 convert_fin2h5 proc~initvisual initvisual program~convert_fin2h5->proc~initvisual proc~writeoutputs~3 writeoutputs program~convert_fin2h5->proc~writeoutputs~3 h5close_f h5close_f proc~writeoutputs~3->h5close_f h5dclose_f h5dclose_f proc~writeoutputs~3->h5dclose_f h5dcreate_f h5dcreate_f proc~writeoutputs~3->h5dcreate_f h5dwrite_f h5dwrite_f proc~writeoutputs~3->h5dwrite_f h5fclose_f h5fclose_f proc~writeoutputs~3->h5fclose_f h5fcreate_f h5fcreate_f proc~writeoutputs~3->h5fcreate_f h5open_f h5open_f proc~writeoutputs~3->h5open_f h5sclose_f h5sclose_f proc~writeoutputs~3->h5sclose_f h5screate_simple_f h5screate_simple_f proc~writeoutputs~3->h5screate_simple_f h5tcopy_f h5tcopy_f proc~writeoutputs~3->h5tcopy_f h5tset_size_f h5tset_size_f proc~writeoutputs~3->h5tset_size_f proc~write_h5_one_r3d write_h5_one_r3d proc~writeoutputs~3->proc~write_h5_one_r3d proc~write_h5_one_r3d->h5dclose_f proc~write_h5_one_r3d->h5dcreate_f proc~write_h5_one_r3d->h5dwrite_f proc~write_h5_one_r3d->h5sclose_f proc~write_h5_one_r3d->h5screate_simple_f Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: pdr_ptot integer :: unit integer :: i integer :: j integer :: k integer :: II integer :: JJ integer :: KK integer :: p integer :: pp integer :: ilevel integer :: ico character(len=7) :: first_col logical :: file_exists","tags":"","url":"program/convert_fin2h5.html"},{"title":"init3DPDR – 3D-PDR","text":"Uses m_Ray_box m_Mesh program~~init3dpdr~~UsesGraph program~init3dpdr init3DPDR module~m_mesh m_Mesh program~init3dpdr->module~m_mesh module~m_ray_box m_Ray_box program~init3dpdr->module~m_ray_box module~m_ray_box->module~m_mesh Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~init3dpdr~~CallsGraph program~init3dpdr init3DPDR proc~octree octree program~init3dpdr->proc~octree proc~octree->proc~octree Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial real(kind=8), parameter :: Pi = 3.141592653589793238462643383279502884 integer :: i integer :: j integer :: k integer :: p integer :: nunit real(kind=8) :: x real(kind=8) :: y real(kind=8) :: z real(kind=8) :: xc real(kind=8) :: yc real(kind=8) :: zc real(kind=8) :: r real(kind=8) :: rr real(kind=8) :: n real(kind=8), allocatable, dimension(:,:,:) :: density_3D real(kind=8), allocatable, dimension(:) :: density_1D real(kind=RK) :: xs real(kind=RK) :: ys real(kind=RK) :: zs integer :: levels type( box ) :: box1 type( HEALPix_ray ) :: ray real(kind=RK) :: thfpix real(kind=RK) :: phfpix real(kind=RK) :: contribution real(kind=RK) :: contribution_1D real(kind=RK) :: corner_min (3) real(kind=RK) :: corner_max (3)","tags":"","url":"program/init3dpdr.html"},{"title":"m_Mesh.F90 – 3D-PDR","text":"Files dependent on this one sourcefile~~m_mesh.f90~~AfferentGraph sourcefile~m_mesh.f90 m_Mesh.F90 sourcefile~escape_probability.f90 escape_probability.F90 sourcefile~escape_probability.f90->sourcefile~m_mesh.f90 sourcefile~m_ray_box.f90 m_Ray_box.F90 sourcefile~escape_probability.f90->sourcefile~m_ray_box.f90 sourcefile~eval_points.f90 eval_points.F90 sourcefile~eval_points.f90->sourcefile~m_mesh.f90 sourcefile~eval_points.f90->sourcefile~m_ray_box.f90 sourcefile~init3dpdr.f90 init3DPDR.F90 sourcefile~init3dpdr.f90->sourcefile~m_mesh.f90 sourcefile~init3dpdr.f90->sourcefile~m_ray_box.f90 sourcefile~input_parameters.f90 input_parameters.F90 sourcefile~input_parameters.f90->sourcefile~m_mesh.f90 sourcefile~m_ioandvisu.f90 m_IOAndVisu.F90 sourcefile~m_ioandvisu.f90->sourcefile~m_mesh.f90 sourcefile~m_ray_box.f90->sourcefile~m_mesh.f90 sourcefile~m_ray_box.f90~2 m_Ray_box.F90 sourcefile~m_ray_box.f90~2->sourcefile~m_mesh.f90 sourcefile~readdensity.f90 readdensity.F90 sourcefile~readdensity.f90->sourcefile~m_mesh.f90 sourcefile~readdensity.f90->sourcefile~m_ray_box.f90 sourcefile~columndensity.f90 columndensity.F90 sourcefile~columndensity.f90->sourcefile~m_ray_box.f90 sourcefile~coolingfunctions.f90 coolingfunctions.F90 sourcefile~coolingfunctions.f90->sourcefile~m_ray_box.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module m_Mesh implicit none private integer , parameter , public :: RK = KIND ( 0.D0 ) ! mesh option real ( RK ), public :: xlx , yly , zlz ! domain length integer , public :: nxp , nyp , nzp ! grid points number integer , public :: nxc , nyc , nzc ! grid center number real ( RK ), public :: dx , dy , dz public :: Mesh contains subroutine Mesh implicit none ! locals integer :: nUnit , ierror ! grid parameters nxp = nxc + 1 nyp = nyc + 1 nzp = nzc + 1 dx = xlx / real ( nxc , kind = RK ) dy = yly / real ( nyc , kind = RK ) dz = zlz / real ( nzc , kind = RK ) end subroutine Mesh end module m_Mesh","tags":"","url":"sourcefile/m_mesh.f90.html"},{"title":"read_input.F90 – 3D-PDR","text":"This file depends on sourcefile~~read_input.f90~~EfferentGraph sourcefile~read_input.f90 read_input.F90 sourcefile~healpix_types.f90 healpix_types.F90 sourcefile~read_input.f90->sourcefile~healpix_types.f90 sourcefile~definitions.f90 definitions.F90 sourcefile~healpix_types.f90->sourcefile~definitions.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !----------------------------------------------------------------------- !     Read atomic/molecular datafile (in LAMDA/RADEX format) !     The standard LAMDA/RADEX datafile format is used: !     http://www.strw.leidenuniv.nl/~moldata/molformat.html !----------------------------------------------------------------------- SUBROUTINE READINPUT ( FILENAME , NLEV , NTEMP , ENERGIES , WEIGHTS ,& & A_COEFFS , B_COEFFS , FREQUENCIES , TEMPERATURES ,& & H_COL , HP_COL , EL_COL , HE_COL , H2_COL , PH2_COL , OH2_COL ) !T.Bell use healpix_types implicit none INTEGER ( kind = I4B ), INTENT ( IN ) :: NLEV INTEGER ( kind = I4B ), INTENT ( IN ) :: NTEMP CHARACTER ( len =* ), INTENT ( IN ) :: FILENAME real ( kind = dp ), intent ( out ) :: ENERGIES ( 1 : NLEV ), WEIGHTS ( 1 : NLEV ) real ( kind = dp ), intent ( out ) :: A_COEFFS ( 1 : NLEV , 1 : NLEV ), B_COEFFS ( 1 : NLEV , 1 : NLEV ) real ( kind = dp ), intent ( out ) :: FREQUENCIES ( 1 : NLEV , 1 : NLEV ), TEMPERATURES ( 1 : 7 , 1 : NTEMP ) real ( kind = dp ), intent ( out ) :: H_COL ( 1 : NLEV , 1 : NLEV , 1 : NTEMP ) real ( kind = dp ), intent ( out ) :: HP_COL ( 1 : NLEV , 1 : NLEV , 1 : NTEMP ) real ( kind = dp ), intent ( out ) :: EL_COL ( 1 : NLEV , 1 : NLEV , 1 : NTEMP ) real ( kind = dp ), intent ( out ) :: HE_COL ( 1 : NLEV , 1 : NLEV , 1 : NTEMP ) real ( kind = dp ), intent ( out ) :: H2_COL ( 1 : NLEV , 1 : NLEV , 1 : NTEMP ) real ( kind = dp ), intent ( out ) :: PH2_COL ( 1 : NLEV , 1 : NLEV , 1 : NTEMP ) real ( kind = dp ), intent ( out ) :: OH2_COL ( 1 : NLEV , 1 : NLEV , 1 : NTEMP ) INTEGER ( kind = I4B ) :: NLIN , NPART , NCOL INTEGER ( kind = I4B ) :: I , J , K , L , M , N , P real ( kind = dp ) :: ENERGY , WEIGHT , EINSTEINA , FREQUENCY real ( kind = dp ) :: COEFF ( 1 : NTEMP ) !     Initialize all variables to zero before reading in the data DO I = 1 , NLEV ENERGIES ( I ) = 0.0D0 WEIGHTS ( I ) = 0.0D0 DO J = 1 , NLEV A_COEFFS ( I , J ) = 0.0D0 B_COEFFS ( I , J ) = 0.0D0 FREQUENCIES ( I , J ) = 0.0D0 DO K = 1 , NTEMP TEMPERATURES (:, K ) = 0.0D0 H_COL ( I , J , K ) = 0.0D0 HP_COL ( I , J , K ) = 0.0D0 EL_COL ( I , J , K ) = 0.0D0 HE_COL ( I , J , K ) = 0.0D0 H2_COL ( I , J , K ) = 0.0D0 PH2_COL ( I , J , K ) = 0.0D0 OH2_COL ( I , J , K ) = 0.0D0 ENDDO ENDDO ENDDO OPEN ( 8 , FILE = trim ( adjustl ( FILENAME )), STATUS = 'OLD' ) READ ( 8 , '(////)' ) !empty line READ ( 8 , * ) N !number of levels of the file IF ( N . NE . NLEV ) STOP \"ERROR! Incorrect number of energy levels, N>NLEV\" READ ( 8 , * ) N = 0 DO WHILE ( N . LT . NLEV ) READ ( 8 , * ) N , ENERGY , WEIGHT ENERGIES ( N ) = ENERGY * C * HP ! Convert from cm&#94;-1 to erg WEIGHTS ( N ) = WEIGHT ENDDO READ ( 8 , * ) READ ( 8 , * ) NLIN READ ( 8 , * ) N = 0 DO WHILE ( N . LT . NLIN ) READ ( 8 , * ) N , I , J , EINSTEINA , FREQUENCY FREQUENCIES ( I , J ) = FREQUENCY * 1.0D9 ! Convert from GHz to Hz FREQUENCIES ( J , I ) = FREQUENCIES ( I , J ) A_COEFFS ( I , J ) = EINSTEINA !        Calculate the Einstein B coefficients using Bij = Aij/(2.h.nu&#94;3/c&#94;2) B_COEFFS ( I , J ) = A_COEFFS ( I , J )& & / ( 2.0D0 * HP * ( FREQUENCIES ( I , J ) ** 3 ) / ( C ** 2 )) B_COEFFS ( J , I ) = B_COEFFS ( I , J ) * ( WEIGHTS ( I ) / WEIGHTS ( J )) ENDDO !     Calculate the transition frequencies between all levels (even if forbidden) DO I = 1 , NLEV DO J = 1 , NLEV FREQUENCY = ABS ( ENERGIES ( I ) - ENERGIES ( J )) / HP IF ( FREQUENCIES ( I , J ). NE . 0.0D0 ) THEN !              Check if the calculated and measured frequencies differ by >1% IF ( ABS ( FREQUENCY - FREQUENCIES ( I , J ))& & / FREQUENCIES ( I , J ). GT . 1.0D-2 ) THEN WRITE ( 6 , * ) 'ERROR! Calculated frequency differs by >1%:' WRITE ( 6 , * ) FREQUENCY , ' Hz vs' , FREQUENCIES ( I , J ), ' Hz' STOP ENDIF ELSE FREQUENCIES ( I , J ) = FREQUENCY ENDIF ENDDO ENDDO READ ( 8 , * ) READ ( 8 , * ) NPART !     Read the collisional rate coefficients (cm&#94;3 s&#94;-1) for each collision partner DO L = 1 , NPART READ ( 8 , * ) READ ( 8 , * ) P READ ( 8 , * ) READ ( 8 , * ) NCOL READ ( 8 , * ) READ ( 8 , * ) M IF ( M . GT . NTEMP ) THEN WRITE ( 6 , * ) 'ERROR! Too many temperature values (>NTEMP):' , M STOP ENDIF IF ( P . EQ . 1 ) THEN READ ( 8 , * ) READ ( 8 , * ) ( TEMPERATURES ( P , K ), K = 1 , M ) READ ( 8 , * ) N = 0 DO WHILE ( N . LT . NCOL ) READ ( 8 , * ) N , I , J ,( COEFF ( K ), K = 1 , M ) DO K = 1 , M H2_COL ( I , J , K ) = COEFF ( K ) !                 Calculate the reverse (excitation) rate coefficient !                 from detailed balance: Cji = Cij*gi/gj*exp(-(Ei-Ej)/kT) IF ( H2_COL ( I , J , K ). NE . 0.0D0 . AND . H2_COL ( J , I , K ). EQ . 0.0D0 ) THEN H2_COL ( J , I , K ) = H2_COL ( I , J , K ) * ( WEIGHTS ( I ) / WEIGHTS ( J )) & & * EXP ( - ( ENERGIES ( I ) - ENERGIES ( J )) / ( KB * TEMPERATURES ( P , K ))) ENDIF ENDDO ENDDO ELSE IF ( P . EQ . 2 ) THEN READ ( 8 , * ) READ ( 8 , * ) ( TEMPERATURES ( P , K ), K = 1 , M ) READ ( 8 , * ) N = 0 DO WHILE ( N . LT . NCOL ) READ ( 8 , * ) N , I , J ,( COEFF ( K ), K = 1 , M ) DO K = 1 , M PH2_COL ( I , J , K ) = COEFF ( K ) !                 Calculate the reverse (excitation) rate coefficient !                 from detailed balance: Cji = Cij*gi/gj*exp(-(Ei-Ej)/kT) IF ( PH2_COL ( I , J , K ). NE . 0.0D0 . AND . PH2_COL ( J , I , K ). EQ . 0.0D0 ) THEN PH2_COL ( J , I , K ) = PH2_COL ( I , J , K ) * ( WEIGHTS ( I ) / WEIGHTS ( J )) & & * EXP ( - ( ENERGIES ( I ) - ENERGIES ( J )) / ( KB * TEMPERATURES ( P , K ))) ENDIF ENDDO ENDDO ELSE IF ( P . EQ . 3 ) THEN READ ( 8 , * ) READ ( 8 , * ) ( TEMPERATURES ( P , K ), K = 1 , M ) READ ( 8 , * ) N = 0 DO WHILE ( N . LT . NCOL ) READ ( 8 , * ) N , I , J ,( COEFF ( K ), K = 1 , M ) DO K = 1 , M OH2_COL ( I , J , K ) = COEFF ( K ) !                 Calculate the reverse (excitation) rate coefficient !                 from detailed balance: Cji = Cij*gi/gj*exp(-(Ei-Ej)/kT) IF ( OH2_COL ( I , J , K ). NE . 0.0D0 . AND . OH2_COL ( J , I , K ). EQ . 0.0D0 ) THEN OH2_COL ( J , I , K ) = OH2_COL ( I , J , K ) * ( WEIGHTS ( I ) / WEIGHTS ( J )) & & * EXP ( - ( ENERGIES ( I ) - ENERGIES ( J )) / ( KB * TEMPERATURES ( P , K ))) ENDIF ENDDO ENDDO ELSE IF ( P . EQ . 4 ) THEN READ ( 8 , * ) READ ( 8 , * ) ( TEMPERATURES ( P , K ), K = 1 , M ) READ ( 8 , * ) N = 0 DO WHILE ( N . LT . NCOL ) READ ( 8 , * ) N , I , J ,( COEFF ( K ), K = 1 , M ) DO K = 1 , M EL_COL ( I , J , K ) = COEFF ( K ) !                 Calculate the reverse (excitation) rate coefficient !                 from detailed balance: Cji = Cij*gi/gj*exp(-(Ei-Ej)/kT) IF ( EL_COL ( I , J , K ). NE . 0.0D0 . AND . EL_COL ( J , I , K ). EQ . 0.0D0 ) THEN EL_COL ( J , I , K ) = EL_COL ( I , J , K ) * ( WEIGHTS ( I ) / WEIGHTS ( J )) & & * EXP ( - ( ENERGIES ( I ) - ENERGIES ( J )) / ( KB * TEMPERATURES ( P , K ))) ENDIF ENDDO ENDDO ELSE IF ( P . EQ . 5 ) THEN READ ( 8 , * ) READ ( 8 , * ) ( TEMPERATURES ( P , K ), K = 1 , M ) READ ( 8 , * ) N = 0 DO WHILE ( N . LT . NCOL ) READ ( 8 , * ) N , I , J ,( COEFF ( K ), K = 1 , M ) DO K = 1 , M H_COL ( I , J , K ) = COEFF ( K ) !                 Calculate the reverse (excitation) rate coefficient !                 from detailed balance: Cji = Cij*gi/gj*exp(-(Ei-Ej)/kT) IF ( H_COL ( I , J , K ). NE . 0.0D0 . AND . H_COL ( J , I , K ). EQ . 0.0D0 ) THEN H_COL ( J , I , K ) = H_COL ( I , J , K ) * ( WEIGHTS ( I ) / WEIGHTS ( J )) & & * EXP ( - ( ENERGIES ( I ) - ENERGIES ( J )) / ( KB * TEMPERATURES ( P , K ))) ENDIF ENDDO ENDDO ELSE IF ( P . EQ . 6 ) THEN READ ( 8 , * ) READ ( 8 , * ) ( TEMPERATURES ( P , K ), K = 1 , M ) READ ( 8 , * ) N = 0 DO WHILE ( N . LT . NCOL ) READ ( 8 , * ) N , I , J ,( COEFF ( K ), K = 1 , M ) DO K = 1 , M HE_COL ( I , J , K ) = COEFF ( K ) !                 Calculate the reverse (excitation) rate coefficient !                 from detailed balance: Cji = Cij*gi/gj*exp(-(Ei-Ej)/kT) IF ( HE_COL ( I , J , K ). NE . 0.0D0 . AND . HE_COL ( J , I , K ). EQ . 0.0D0 ) THEN HE_COL ( J , I , K ) = HE_COL ( I , J , K ) * ( WEIGHTS ( I ) / WEIGHTS ( J )) & & * EXP ( - ( ENERGIES ( I ) - ENERGIES ( J )) / ( KB * TEMPERATURES ( P , K ))) ENDIF ENDDO ENDDO ELSE IF ( P . EQ . 7 ) THEN READ ( 8 , * ) READ ( 8 , * ) ( TEMPERATURES ( P , K ), K = 1 , M ) READ ( 8 , * ) N = 0 DO WHILE ( N . LT . NCOL ) READ ( 8 , * ) N , I , J ,( COEFF ( K ), K = 1 , M ) DO K = 1 , M HP_COL ( I , J , K ) = COEFF ( K ) !                 Calculate the reverse (excitation) rate coefficient !                 from detailed balance: Cji = Cij*gi/gj*exp(-(Ei-Ej)/kT) IF ( HP_COL ( I , J , K ). NE . 0.0D0 . AND . HP_COL ( J , I , K ). EQ . 0.0D0 ) THEN HP_COL ( J , I , K ) = HP_COL ( I , J , K ) * ( WEIGHTS ( I ) / WEIGHTS ( J )) & & * EXP ( - ( ENERGIES ( I ) - ENERGIES ( J )) / ( KB * TEMPERATURES ( P , K ))) ENDIF ENDDO ENDDO ELSE WRITE ( 6 , * ) 'ERROR! Unrecognized collision partner ID:' , P STOP ENDIF ENDDO CLOSE ( 8 ) WRITE ( 6 , * ) 'Cooling datafile: ' , trim ( adjustl ( FILENAME )), ' read successfully' RETURN END subroutine","tags":"","url":"sourcefile/read_input.f90.html"},{"title":"writeparams.F90 – 3D-PDR","text":"This file depends on sourcefile~~writeparams.f90~~EfferentGraph sourcefile~writeparams.f90 writeparams.F90 sourcefile~definitions.f90 definitions.F90 sourcefile~writeparams.f90->sourcefile~definitions.f90 sourcefile~healpix_types.f90 healpix_types.F90 sourcefile~writeparams.f90->sourcefile~healpix_types.f90 sourcefile~modules.f90 modules.F90 sourcefile~writeparams.f90->sourcefile~modules.f90 sourcefile~healpix_types.f90->sourcefile~definitions.f90 sourcefile~modules.f90->sourcefile~definitions.f90 sourcefile~modules.f90->sourcefile~healpix_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code subroutine writeparams use definitions use healpix_types use maincode_module , only : input , level , Tguess , iterstep ,& & theta_crit , ITERTOT , & & Gext , AV_fac , UV_fac , nspec , nreac , maxpoints , & & Tlow0 , Thigh0 , Tmin , Tmax , Fcrit , Tdiff , dust_temperature ,& & chemiterations , zeta , v_turb !, fieldchoice use global_module , only : metallicity , omega , grain_radius write ( 6 , * ) 'Input file:               ' , input write ( 6 , * ) 'HEALPix level:            ' , level #ifdef ONEDIMENSIONAL if ( level . gt . 0 ) STOP \"HEALPix level must be set to 0 in ONEDIMENSIONAL mode\" #endif #ifdef PSEUDO_2D if ( level . gt . 0 ) STOP \"HEALPix level must be set to 0 in ONEDIMENSIONAL mode\" #endif write ( 6 , * ) 'Theta critical:           ' , theta_crit write ( 6 , * ) 'Angle between rays:       ' , sqrt ( pi / 3.0D0 / 4.0D0 ** ( real ( level ))) write ( 6 , * ) 'Maxpoints                 ' , maxpoints if ( theta_crit . ge . pi / 2.0D0 ) stop 'theta_crit must be less than pi/2' write ( 6 , * ) 'Guess Temperature (K):    ' , Tguess write ( 6 , * ) 'Dust  Temperature (K):    ' , dust_temperature write ( 6 , * ) 'Turbulent velocity (cm/s):' , v_turb #ifdef THERMALBALANCE write ( 6 , * ) 'Tlow:                     ' , Tlow0 write ( 6 , * ) 'Thigh:                    ' , Thigh0 #endif write ( 6 , * ) 'Tmin:                     ' , Tmin write ( 6 , * ) 'Tmax:                     ' , Tmax write ( 6 , * ) 'Fcrit:                    ' , Fcrit write ( 6 , * ) 'Tdiff:                    ' , Tdiff !write(6,*) 'Form of field:            ',fieldchoice write ( 6 , * ) 'Gext:                     ' , Gext ( 1 ) write ( 6 , * ) 'AV factor:                ' , AV_fac write ( 6 , * ) 'UV factor:                ' , UV_fac #ifdef REDUCED write ( 6 , * ) 'Chemical network:           REDUCED' #elif MEDIUM write ( 6 , * ) 'Chemical network:           MEDIUM' #elif FULL write ( 6 , * ) 'Chemical network:           FULL' #elif MYNETWORK write ( 6 , * ) 'Chemical network:           MYNETWORK' #endif write ( 6 , * ) 'Number of species:        ' , nspec write ( 6 , * ) 'Number of reactions:      ' , nreac write ( 6 , * ) 'Total iterations:         ' , itertot write ( 6 , * ) 'Output interval / iter.:  ' , iterstep write ( 6 , * ) 'Chemiterations:           ' , chemiterations write ( 6 , * ) 'Zeta:                     ' , zeta * 1.3d-17 write ( 6 , * ) 'Metallicity               ' , metallicity write ( 6 , * ) 'Omega                     ' , omega write ( 6 , * ) 'Grain radius              ' , grain_radius close ( 12 ) write ( 6 , * ) '=============================================' write ( 6 , * ) '' write ( 6 , * ) '------FLAGS-----' #ifdef THERMALBALANCE write ( 6 , * ) 'THERMALBALANCE' #endif #ifdef GRAINRECOMB write ( 6 , * ) 'GRAINRECOMB' #endif #ifdef SUPRATHERMAL write ( 6 , * ) 'SUPRATHERMAL' #endif #ifdef OPENMP write ( 6 , * ) 'OPENMP' #endif #ifdef ONEDIMENSIONAL write ( 6 , * ) 'ONEDIMENSIONAL' #else write ( 6 , * ) 'FULL_3D' #endif #ifdef DUST write ( 6 , * ) 'DUST' #endif #ifdef FORCECONVERGENCE write ( 6 , * ) 'FORCECONVERGENCE' #endif #ifdef H2FORM write ( 6 , * ) 'H2FORM' #endif #ifdef GUESS_TEMP write ( 6 , * ) 'GUESS_TEMP' #endif write ( 6 , * ) '' write ( 6 , * ) 'Reading initial conditions file' return end subroutine","tags":"","url":"sourcefile/writeparams.f90.html"},{"title":"writeoutputs.F90 – 3D-PDR","text":"This file depends on sourcefile~~writeoutputs.f90~~EfferentGraph sourcefile~writeoutputs.f90 writeoutputs.F90 sourcefile~healpix_types.f90 healpix_types.F90 sourcefile~writeoutputs.f90->sourcefile~healpix_types.f90 sourcefile~modules.f90 modules.F90 sourcefile~writeoutputs.f90->sourcefile~modules.f90 sourcefile~definitions.f90 definitions.F90 sourcefile~healpix_types.f90->sourcefile~definitions.f90 sourcefile~modules.f90->sourcefile~healpix_types.f90 sourcefile~modules.f90->sourcefile~definitions.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code subroutine writeoutputs !for ASCII outputs use healpix_types use maincode_module use global_module #if (defined(OUTRAYINFO) &&  !defined(ONEDIMENSIONAL)) character ( len = 100 ) :: outFormat #endif #ifdef PYWRAP out_file = trim ( adjustl ( output )) // \".pywrap\" out_file2 = trim ( adjustl ( out_file )) // \"]\" write ( 6 , '(\" Writing file [\",A)' ) trim ( adjustl ( out_file2 )) open ( unit = 21 , file = out_file , status = 'replace' ) write ( 21 , '(\"x Av Tgas Tdust nH fuv\")' , advance = 'no' ) do i = 1 , nspec write ( 21 , '(A6)' , advance = 'no' ) trim ( species ( i )) enddo write ( 21 , '(\" dummy1 photoelectric dummy2 Cionization H2formation H2photodis FUVpumping\")' , advance = 'no' ) write ( 21 , '(\" cosmicray turbulent chemical gasgrain totheat \")' , advance = 'no' ) do i = 1 , coo write ( 21 , '(A10)' , advance = 'no' ) trim ( adjustl ( coolant ( i )% cname )) // \"cool\" enddo write ( 21 , '(\" totcool\")' , advance = 'no' ) write ( 21 , * ) '' do p = 1 , pdr_ptot write ( 21 , '(300ES15.7)' ) pdr ( p )% x , pdr ( p )% AV ( 6 ), pdr ( p )% Tgas , pdr ( p )% Tdust , pdr ( p )% rho , pdr ( p )% UVfield ,& & pdr ( p )% abundance , pdr ( p )% heating , pdr ( p )% cooling , pdr ( p )% totalcooling enddo close ( 21 ) #endif #ifdef CHEMANALYSIS !------------------------------------- !OUTPUT FOR CHEMICAL ANALYSIS !------------------------------------- out_file = trim ( adjustl ( output )) // \".rates.fin\" out_file2 = trim ( adjustl ( out_file )) // \"]\" write ( 6 , '(\" Writing file [\",A)' ) trim ( adjustl ( out_file2 )) open ( unit = 98 , file = out_file , status = 'replace' ) do p = 1 , pdr_ptot call analyse_chemistry ( p , end_time , pdr ( p )% rho , pdr ( p )% Tgas , & & 12 , pdr ( p )% AV ( 6 ), nspec , species , pdr ( p )% abundance ( 1 : nspec ), nreac , reactant , & & product , temp_rate (:, p )) enddo close ( 98 ) #endif !------------------------------------- !OUTPUT FOR PDR PARAMETERS !------------------------------------- out_file = trim ( adjustl ( output )) // \".params\" out_file2 = trim ( adjustl ( out_file )) // \"]\" write ( 6 , '(\" Writing file [\",A)' ) trim ( adjustl ( out_file2 )) open ( unit = 21 , file = out_file , status = 'replace' ) write ( 21 , '(3ES11.3)' ) Gext ( 1 ), zeta * 1.3d-17 , metallicity close ( 21 ) !------------------------------------- !OUTPUT FOR ABUNDANCES AND TEMPERATURE !------------------------------------- out_file = trim ( adjustl ( output )) // \".pdr.fin\" out_file2 = trim ( adjustl ( out_file )) // \"]\" write ( 6 , '(\" Writing file [\",A)' ) trim ( adjustl ( out_file2 )) open ( unit = 21 , file = out_file , status = 'replace' ) do p = 1 , pdr_ptot #ifdef ONEDIMENSIONAL write ( 21 , '(I7,4ES15.7,I5,300ES15.7)' ) p , pdr ( p )% x , pdr ( p )% AV ( 6 ), pdr ( p )% Tgas , pdr ( p )% Tdust , pdr ( p )% etype ,& & pdr ( p )% rho , pdr ( p )% UVfield , pdr ( p )% abundance #else write ( 21 , '(I7,5ES15.7,I5,300ES15.7)' ) p , pdr ( p )% x , pdr ( p )% y , pdr ( p )% z , pdr ( p )% Tgas , pdr ( p )% Tdust ,& & pdr ( p )% etype , pdr ( p )% rho , pdr ( p )% UVfield , pdr ( p )% abundance !,pdr(p)%AV #endif enddo close ( 21 ) !----------------------------------------- !END OUTPUT FOR ABUNDANCES AND TEMPERATURE !----------------------------------------- #ifdef CRATTENUATION !------------------------- !OUTPUT FOR LOCAL CR VALUE !------------------------- out_file = trim ( adjustl ( output )) // \".cr.fin\" out_file2 = trim ( adjustl ( out_file )) // \"]\" write ( 6 , '(\" Writing file [\",A)' ) trim ( adjustl ( out_file2 )) open ( unit = 21 , file = out_file , status = 'replace' ) do p = 1 , pdr_ptot write ( 21 , '(ES15.7)' ) pdr ( p )% zetalocal * 1.3d-17 enddo close ( 21 ) !----------------------------- !END OUTPUT FOR LOCAL CR VALUE !----------------------------- #endif #if (defined(OUTRAYINFO) &&  !defined(ONEDIMENSIONAL)) write ( outFormat , '( \"(\", I6, \"ES15.7)\" )' ) nrays out_file = trim ( adjustl ( output )) // \".rayAV.fin\" out_file2 = trim ( adjustl ( out_file )) // \"]\" write ( 6 , '(\" Writing file [\",A)' ) trim ( adjustl ( out_file2 )) open ( unit = 21 , file = out_file , status = 'replace' ) do p = 1 , pdr_ptot write ( 21 , outFormat ) pdr ( p )% AV enddo out_file = trim ( adjustl ( output )) // \".rayH2.fin\" out_file2 = trim ( adjustl ( out_file )) // \"]\" write ( 6 , '(\" Writing file [\",A)' ) trim ( adjustl ( out_file2 )) open ( unit = 21 , file = out_file , status = 'replace' ) do p = 1 , pdr_ptot write ( 21 , outFormat ) pdr ( p )% column_NH2 enddo out_file = trim ( adjustl ( output )) // \".rayHD.fin\" out_file2 = trim ( adjustl ( out_file )) // \"]\" write ( 6 , '(\" Writing file [\",A)' ) trim ( adjustl ( out_file2 )) open ( unit = 21 , file = out_file , status = 'replace' ) do p = 1 , pdr_ptot write ( 21 , outFormat ) pdr ( p )% column_NHD enddo #endif !--------------------------- !OUTPUT FOR COOLING FUNCTION !--------------------------- out_file = trim ( adjustl ( output )) // trim ( adjustl ( \".cool\" )) // \".fin\" out_file2 = trim ( adjustl ( out_file )) // \"]\" write ( 6 , '(\" Writing file [\",A)' ) trim ( adjustl ( out_file2 )) open ( unit = 13 , file = out_file , status = 'replace' ) do p = 1 , pdr_ptot #ifdef ONEDIMENSIONAL write ( 13 , '(I7,200ES15.7)' ) p , pdr ( p )% x , pdr ( p )% AV ( 6 ), pdr ( p )% cooling (:), pdr ( p )% totalcooling #else write ( 13 , '(I7,200ES15.7)' ) p , pdr ( p )% x , pdr ( p )% y , pdr ( p )% z , pdr ( p )% cooling (:), pdr ( p )% totalcooling !, pdr(p)%AV(:) #endif enddo !------------------------------- !END OUTPUT FOR COOLING FUNCTION !------------------------------- !--------------------------- !OUTPUT FOR HEATING FUNCTION !--------------------------- out_file = trim ( adjustl ( output )) // trim ( adjustl ( \".heat\" )) // \".fin\" out_file2 = trim ( adjustl ( out_file )) // \"]\" write ( 6 , '(\" Writing file [\",A)' ) trim ( adjustl ( out_file2 )) open ( unit = 14 , file = out_file , status = 'replace' ) do p = 1 , pdr_ptot #ifdef ONEDIMENSIONAL write ( 14 , '(I7,200ES15.7)' ) p , pdr ( p )% x , pdr ( p )% AV ( 6 ), pdr ( p )% heating #else write ( 14 , '(I7,200ES15.7)' ) p , pdr ( p )% x , pdr ( p )% y , pdr ( p )% z , pdr ( p )% heating !, pdr(p)%AV #endif enddo close ( 14 ) !------------------------------- !END OUTPUT FOR HEATING FUNCTION !------------------------------- #ifdef ONEDIMENSIONAL !----------------------- !OUTPUT FOR EMISSIVITIES !----------------------- do k = 1 , coo out_file = trim ( adjustl ( output )) // \".\" // trim ( adjustl ( coolant ( k )% cname )) // trim ( adjustl ( \".line\" )) // \".fin\" out_file2 = trim ( adjustl ( out_file )) // \"]\" write ( 6 , '(\" Writing file [\",A)' ) trim ( adjustl ( out_file2 )) open ( unit = 16 , file = out_file , status = 'replace' ) !experimental [1D models only] do p = 1 , pdr_ptot write ( 16 , '(I5, 1X, ES15.7, 1X, ES15.7, 1X)' , advance = 'no' ) p , pdr ( p )% x , pdr ( p )% AV ( 6 ) do ilevel = 1 , coolant ( k )% cnlev - 1 if ( pdr ( p )% coolant ( k )% line ( ilevel + 1 , ilevel ). lt . 1 d - 99 ) pdr ( p )% coolant ( k )% line ( ilevel + 1 , ilevel ) = 0.0D0 write ( 16 , '(100ES15.7)' , advance = 'no' ) pdr ( p )% coolant ( k )% line ( ilevel + 1 , ilevel ) end do write ( 16 , * ) end do close ( 16 ) enddo !--------------------------- !END OUTPUT FOR EMISSIVITIES !--------------------------- !---------------------------- !OUTPUT FOR LEVEL POPULATIONS !---------------------------- do k = 1 , coo out_file = trim ( adjustl ( output )) // \".\" // trim ( adjustl ( coolant ( k )% cname )) // trim ( adjustl ( \".spop\" )) // \".fin\" out_file2 = trim ( adjustl ( out_file )) // \"]\" write ( 6 , '(\" Writing file [\",A)' ) trim ( adjustl ( out_file2 )) open ( unit = 16 , file = out_file , status = 'replace' ) !experimental [1D models only] do p = 1 , pdr_ptot write ( 16 , '(I5, 1X, ES15.7, 1X, ES15.7, 1X)' , advance = 'no' ) p , pdr ( p )% x , pdr ( p )% AV ( 6 ) do ilevel = 1 , coolant ( k )% cnlev if ( pdr ( p )% coolant ( k )% pop ( ilevel ). lt . 1 d - 99 ) pdr ( p )% coolant ( k )% pop ( ilevel ) = 0.0D0 end do write ( 16 , '(100ES15.7)' , advance = 'no' ) pdr ( p )% coolant ( k )% pop write ( 16 , * ) end do close ( 16 ) enddo !-------------------------------- !END OUTPUT FOR LEVEL POPULATIONS !-------------------------------- #endif !---------------------------- !OUTPUT FOR RTtool !---------------------------- out_file = trim ( adjustl ( output )) // trim ( adjustl ( \".RTspop\" )) // \".fin\" out_file2 = trim ( adjustl ( out_file )) // \"]\" write ( 6 , '(\" Writing file [\",A)' ) trim ( adjustl ( out_file2 )) open ( unit = 16 , file = out_file , status = 'replace' ) #ifdef REDUCED write ( 16 , * ) 'REDUCED' #elif MEDIUM write ( 16 , * ) 'MEDIUM' #elif FULL write ( 16 , * ) 'FULL' #endif do k = 1 , coo write ( 16 , * ) coolfile ( k ) enddo write ( 16 , * ) 'ENDCOOLFILES' do p = 1 , pdr_ptot do k = 1 , coo do ilevel = 1 , coolant ( k )% cnlev if ( pdr ( p )% coolant ( k )% pop ( ilevel ). lt . 1 d - 99 ) pdr ( p )% coolant ( k )% pop ( ilevel ) = 0.0D0 end do end do do k = 1 , coo write ( 16 , '(100ES15.7)' , advance = 'no' ) pdr ( p )% coolant ( k )% pop ( 1 : coolant ( k )% cnlev ) end do write ( 16 , * ) end do close ( 16 ) !-------------------------------- !END OUTPUT FOR LEVEL POPULATIONS !-------------------------------- return end subroutine","tags":"","url":"sourcefile/writeoutputs.f90.html"},{"title":"calc_reac_rates.F90 – 3D-PDR","text":"This file depends on sourcefile~~calc_reac_rates.f90~~EfferentGraph sourcefile~calc_reac_rates.f90 calc_reac_rates.F90 sourcefile~definitions.f90 definitions.F90 sourcefile~calc_reac_rates.f90->sourcefile~definitions.f90 sourcefile~healpix_types.f90 healpix_types.F90 sourcefile~calc_reac_rates.f90->sourcefile~healpix_types.f90 sourcefile~modules.f90 modules.F90 sourcefile~calc_reac_rates.f90->sourcefile~modules.f90 sourcefile~healpix_types.f90->sourcefile~definitions.f90 sourcefile~modules.f90->sourcefile~definitions.f90 sourcefile~modules.f90->sourcefile~healpix_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !======================================================================= ! !  Calculate the rate coefficients for all reactions at the specified !  temperature and visual extinction A_V. The photodissociation of H2 !  and CO and the photoionization of CI and SI are treated separately !  in detail (see the routines in photorates.f90). Multiple rates for !  the same reaction (duplicates) are allowed in the ratefile and are !  activated based on their minimum and maximum temperature specified !  in that file. Negative gamma factors are ignored below the minimum !  temperature at which the reaction rate is valid. ! !  X-ray induced reaction rates are calculated following the detailed !  treatment of Meijerink & Spaans (2005, A&A, 436, 397). ! !----------------------------------------------------------------------- SUBROUTINE CALCULATE_REACTION_RATES ( TEMPERATURE , DUST_TEMPERATURE , NRAYS , RAD_SURFACE , AV , & & COLUMN_NH2 , COLUMN_NHD , COLUMN_NCO , COLUMN_NC , COLUMN_NS , & & NREAC , REACTANT , PRODUCT , ALPHA , BETA , GAMMA , RATE , RTMIN , RTMAX , DUPLICATE , NSPEC , & & NRGR , NRH2 , NRHD , NRCO , NRCI , NRSI , nelectron , density , ZETALOCAL ) use definitions use healpix_types use global_module use functions_module use maincode_module , only : species , mass , Av_crit , v_alfv IMPLICIT NONE INTEGER ( kind = i4b ), intent ( in ) :: NRAYS , NSPEC real ( kind = dp ), intent ( in ) :: TEMPERATURE , DUST_TEMPERATURE real ( kind = dp ), intent ( in ) :: RAD_SURFACE ( 0 : nrays - 1 ), AV ( 0 : nrays - 1 ) real ( kind = dp ), intent ( in ) :: COLUMN_NH2 ( 0 : nrays - 1 ) real ( kind = dp ), intent ( in ) :: COLUMN_NHD ( 0 : nrays - 1 ) real ( kind = dp ), intent ( in ) :: COLUMN_NCO ( 0 : nrays - 1 ) real ( kind = dp ), intent ( in ) :: COLUMN_NC ( 0 : nrays - 1 ) real ( kind = dp ), intent ( in ) :: COLUMN_NS ( 0 : nrays - 1 ) INTEGER ( kind = i4b ), intent ( in ) :: NREAC , DUPLICATE ( 1 : nreac ) real ( kind = dp ), intent ( in ) :: ALPHA ( 1 : nreac ), BETA ( 1 : nreac ), GAMMA ( 1 : nreac ), RTMIN ( 1 : nreac ), RTMAX ( 1 : nreac ) real ( kind = dp ), intent ( out ) :: rate ( 1 : nreac ) INTEGER ( kind = i4b ), intent ( out ) :: NRGR , NRH2 , NRHD , NRCO , NRCI , NRSI CHARACTER ( len = 10 ), intent ( in ) :: REACTANT ( 1 : nreac , 1 : 3 ), PRODUCT ( 1 : nreac , 1 : 4 ) real ( kind = dp ), intent ( in ) :: ZETALOCAL real ( kind = dp ) :: PHI_PAH , CION , STICKING , FLUX , YIELD INTEGER ( kind = i4b ) :: I , J , K !BALG real ( kind = dp ), intent ( in ) :: nelectron , density real ( kind = dp ) :: PHI_REC #ifdef GRAINRECOMB real ( kind = dp ) :: C0 , C1 , C2 , C3 , C4 , C5 , C6 , PSI , ALPHA_G #endif real ( kind = dp ) :: loctemperature #ifdef SUPRATHERMAL character ( len = 10 ) :: isition1 , isition2 integer :: isp real :: mass1 , mass2 #endif !     Initialize the rate coefficients. RATE = 0.0D0 !     Initialize the stored reaction numbers. If they are not assigned !     subsequently, any attempt to access that reaction will generate an !     error and the code will crash. This is a useful bug catch. NRGR = 0 NRH2 = 0 NRHD = 0 NRCO = 0 NRCI = 0 NRSI = 0 DO I = 1 , NREAC !        Determine the type of reaction IF ( REACTANT ( I , 2 ). EQ . \"PHOTON\" ) GOTO 1 IF ( REACTANT ( I , 2 ). EQ . \"CRP   \" ) GOTO 2 IF ( REACTANT ( I , 2 ). EQ . \"CRPHOT\" ) GOTO 3 IF ( REACTANT ( I , 2 ). EQ . \"FREEZE\" ) GOTO 4 IF ( REACTANT ( I , 2 ). EQ . \"ELFRZE\" ) GOTO 5 IF ( REACTANT ( I , 2 ). EQ . \"CRH   \" ) GOTO 6 IF ( REACTANT ( I , 2 ). EQ . \"PHOTD \" ) GOTO 7 IF ( REACTANT ( I , 2 ). EQ . \"THERM \" ) GOTO 8 IF ( REACTANT ( I , 2 )( 1 : 1 ). EQ . \"#\" ) GOTO 9 IF ( REACTANT ( I , 2 ). EQ . \"XRAY  \" ) GOTO 110 IF ( REACTANT ( I , 2 ). EQ . \"XRSEC \" ) GOTO 120 IF ( REACTANT ( I , 2 ). EQ . \"XRLYA \" ) GOTO 130 IF ( REACTANT ( I , 2 ). EQ . \"XRPHOT\" ) GOTO 140 !----------------------------------------------------------------------- !     Thermal reactions: !     The rate of H2 formation on grains is calculated separately !     by the function H2_FORMATION_RATE (see function for details) IF (( REACTANT ( I , 1 ). EQ . \"H  \" . AND . REACTANT ( I , 2 ). EQ . \"H  \" . AND . & & ( REACTANT ( I , 3 ). EQ . \"   \" . OR . REACTANT ( I , 3 ). EQ . \"#  \" )) . AND . & & ( PRODUCT ( I , 1 ). EQ . \"H2 \" . AND . & & ( PRODUCT ( I , 2 ). EQ . \"   \" . OR . PRODUCT ( I , 2 ). EQ . \"#  \" ))) THEN #ifdef H2FORM_CT02 RATE ( I ) = H2_FORMATION_RATE ( TEMPERATURE , DUST_TEMPERATURE ) #endif #ifdef H2FORM_SIMPLE RATE ( I ) = 3.0D-18 * SQRT ( TEMPERATURE ) * EXP ( - ( TEMPERATURE / 1.0D3 )) #endif #ifdef H2FORM_R07 RATE ( I ) = 3.0D-18 * SQRT ( TEMPERATURE ) #endif NRGR = I GOTO 10 ENDIF #ifdef BALG IF (( REACTANT ( I , 1 ). EQ . \"He+\" . AND . REACTANT ( I , 2 ). EQ . \"e- \" . AND . & & ( REACTANT ( I , 3 ). EQ . \"#  \" )) . AND . & & ( PRODUCT ( I , 1 ). EQ . \"He \" . AND . & & ( PRODUCT ( I , 2 ). EQ . \"#  \" ))) THEN PHI_REC = ( 1.7 * RAD_SURFACE ( 6 ) * EXP ( - 1.87 * AV ( 6 )) * SQRT ( TEMPERATURE )) / ( nelectron ) if ( PHI_REC . EQ . 0.0D0 ) THEN RATE ( I ) = 5.272D-14 else RATE ( I ) = 5.572D-14 * ( 1.0 + 3.185D-7 * PHI_REC ** ( 1.512 ) * ( 1.0 + 5115 * TEMPERATURE ** ( 3.903D-7 ) * & PHI_REC ** ( - 0.4956 - 5.494D-7 * LOG ( TEMPERATURE )))) ** ( - 1 ) endif GOTO 10 ENDIF !     The rate for C+ grain assisted recombination following Gong+2017 - BALG IF (( REACTANT ( I , 1 ). EQ . \"C+ \" . AND . REACTANT ( I , 2 ). EQ . \"e- \" . AND . & & ( REACTANT ( I , 3 ). EQ . \"#  \" )) . AND . & & ( PRODUCT ( I , 1 ). EQ . \"C  \" . AND . & & ( PRODUCT ( I , 2 ). EQ . \"#  \" ))) THEN PHI_REC = ( 1.7 * RAD_SURFACE ( 6 ) * EXP ( - 1.87 * AV ( 6 )) * SQRT ( TEMPERATURE )) / ( nelectron ) if ( PHI_REC . EQ . 0.0D0 ) THEN RATE ( I ) = 4 5.58D-14 else RATE ( I ) = 4 5.58D-14 * ( 1.0 + 6.089D-3 * PHI_REC ** ( 1.128 ) * ( 1.0 + 41 1.3 * TEMPERATURE ** ( 0.04845 ) * & PHI_REC ** ( - 0.8120 - 1.333D-4 * LOG ( TEMPERATURE )))) ** ( - 1 ) endif GOTO 10 ENDIF #endif !     Rates for reactions involving PAHs are calculated according to the !     treatment of Wolfire et al. (2003, ApJ, 587, 278; 2008, ApJ, 680, 384) IF ( ANY ( REACTANT ( I ,:). EQ . \"PAH  \" ) . OR . ANY ( REACTANT ( I ,:). EQ . \"PAH0 \" ) . OR . & & ANY ( REACTANT ( I ,:). EQ . \"PAH+ \" ) . OR . ANY ( REACTANT ( I ,:). EQ . \"PAH- \" )) THEN PHI_PAH = 0.4D0 RATE ( I ) = ALPHA ( I ) * ( TEMPERATURE / 10 0.0D0 ) ** BETA ( I ) * PHI_PAH GOTO 10 END IF !     Check for large negative gamma values that might cause discrepant !     rates at low temperatures. Set these rates to zero when T < RTMIN. !CODE RESPONSINBLE FOR O + H+ --> O+ + H IF ( DUPLICATE ( I ). EQ . 0 ) THEN IF ( GAMMA ( I ). LT . - 20 0.0D0 . AND . TEMPERATURE . LT . RTMIN ( I )) THEN RATE ( I ) = 0.0D0 ELSE LOCTEMPERATURE = TEMPERATURE #ifdef SUPRATHERMAL !Suprathermal heating following Visser+(2009). Added by TGBisbas !v_alfv has been converted to K in input_parameters.F90 following Eqn~6 Visser+(2009) isition1 = adjustr ( reactant ( i , 1 )) isition2 = adjustr ( reactant ( i , 2 )) !condition to consider *only* ion-neutral reactions. if ( isition1 ( 10 : 10 ). eq . '+' . and . isition2 ( 10 : 10 ). ne . '+' . and . isition2 ( 10 : 10 ). ne . '-' . or .& & isition2 ( 10 : 10 ). eq . '+' . and . isition1 ( 10 : 10 ). ne . '+' . and . isition1 ( 10 : 10 ). ne . '-' ) then do isp = 1 , nspec if ( species ( isp ) == reactant ( i , 1 )) mass1 = mass ( isp ) if ( species ( isp ) == reactant ( i , 2 )) mass2 = mass ( isp ) enddo if ( AV ( 6 ). lt . Av_crit ) LOCTEMPERATURE = LOCTEMPERATURE + v_alfv * mass1 * mass2 / ( mass1 + mass2 ) endif #endif RATE ( I ) = ALPHA ( I ) * ( LOCTEMPERATURE / 30 0.0D0 ) ** BETA ( I ) * EXP ( - ( GAMMA ( I ) / LOCTEMPERATURE )) ENDIF ELSE IF ( DUPLICATE ( I ). EQ . 1 ) THEN J = I DO IF ( TEMPERATURE . LE . RTMAX ( J )) THEN IF ( GAMMA ( J ). LT . - 20 0.0D0 . AND . TEMPERATURE . LT . RTMIN ( J )) THEN RATE ( J ) = 0.0D0 ELSE LOCTEMPERATURE = TEMPERATURE #ifdef SUPRATHERMAL isition1 = adjustr ( reactant ( i , 1 )) isition2 = adjustr ( reactant ( i , 2 )) if ( isition1 ( 10 : 10 ). eq . '+' . and . isition2 ( 10 : 10 ). ne . '+' . and . isition2 ( 10 : 10 ). ne . '-' . or .& & isition2 ( 10 : 10 ). eq . '+' . and . isition1 ( 10 : 10 ). ne . '+' . and . isition1 ( 10 : 10 ). ne . '-' ) then do isp = 1 , nspec if ( species ( isp ) == reactant ( i , 1 )) mass1 = mass ( isp ) if ( species ( isp ) == reactant ( i , 2 )) mass2 = mass ( isp ) enddo if ( AV ( 6 ). lt . Av_crit ) LOCTEMPERATURE = LOCTEMPERATURE + v_alfv * mass1 * mass2 / ( mass1 + mass2 ) endif #endif RATE ( J ) = ALPHA ( J ) * ( LOCTEMPERATURE / 30 0.0D0 ) ** BETA ( J ) * EXP ( - ( GAMMA ( J ) / LOCTEMPERATURE )) ENDIF EXIT ELSE IF ( DUPLICATE ( J + 1 ). LT . DUPLICATE ( J )) THEN IF ( GAMMA ( J ). LT . - 20 0.0D0 . AND . TEMPERATURE . LT . RTMIN ( J )) THEN RATE ( J ) = 0.0D0 ELSE LOCTEMPERATURE = TEMPERATURE #ifdef SUPRATHERMAL isition1 = adjustr ( reactant ( i , 1 )) isition2 = adjustr ( reactant ( i , 2 )) if ( isition1 ( 10 : 10 ). eq . '+' . and . isition2 ( 10 : 10 ). ne . '+' . and . isition2 ( 10 : 10 ). ne . '-' . or .& & isition2 ( 10 : 10 ). eq . '+' . and . isition1 ( 10 : 10 ). ne . '+' . and . isition1 ( 10 : 10 ). ne . '-' ) then do isp = 1 , nspec if ( species ( isp ) == reactant ( i , 1 )) mass1 = mass ( isp ) if ( species ( isp ) == reactant ( i , 2 )) mass2 = mass ( isp ) enddo if ( AV ( 6 ). lt . Av_crit ) LOCTEMPERATURE = LOCTEMPERATURE + v_alfv * mass1 * mass2 / ( mass1 + mass2 ) endif #endif RATE ( J ) = ALPHA ( J ) * ( LOCTEMPERATURE / 30 0.0D0 ) ** BETA ( J ) * EXP ( - ( GAMMA ( J ) / LOCTEMPERATURE )) ENDIF EXIT ELSE RATE ( J ) = 0.0D0 J = J + 1 ENDIF ENDDO ENDIF GOTO 10 !----------------------------------------------------------------------- !     Photoreactions: !     Store the reaction number for H2 photodissociation. The rate itself !     is calculated separately by the function H2PDRATE (within shield.f) 1 IF ( REACTANT ( I , 1 ). EQ . \"H2 \" . AND . REACTANT ( I , 3 ). EQ . \"   \" ) THEN !           Loop over all rays DO K = 0 , NRAYS - 1 RATE ( I ) = RATE ( I ) + H2PDRATE ( ALPHA ( I ), RAD_SURFACE ( K ), AV ( K ), COLUMN_NH2 ( K )) ENDDO IF ( PRODUCT ( I , 1 ). EQ . \"H \" . AND . PRODUCT ( I , 2 ). EQ . \"H \" ) NRH2 = I GOTO 10 ENDIF !     Store the reaction number for HD photodissociation. The rate itself !     is calculated separately by the function H2PDRATE (within shield.f) IF ( REACTANT ( I , 1 ). EQ . \"HD \" . AND . REACTANT ( I , 3 ). EQ . \"   \" ) THEN !           Loop over all rays DO K = 0 , NRAYS - 1 RATE ( I ) = RATE ( I ) + H2PDRATE ( ALPHA ( I ), RAD_SURFACE ( K ), AV ( K ), COLUMN_NHD ( K )) ENDDO IF ( ANY ( PRODUCT ( I ,:). EQ . \"H \" ) . AND . ANY ( PRODUCT ( I ,:). EQ . \"D \" )) NRHD = I GOTO 10 ENDIF !     Store the reaction number for CO photodissociation. The rate itself !     is calculated separately by the function !COPDRATE (within shield.f) IF ( REACTANT ( I , 1 ). EQ . \"CO \" . AND . REACTANT ( I , 3 ). EQ . \"   \" . AND . & & ANY ( PRODUCT ( I ,:). EQ . \"C \" ) . AND . ANY ( PRODUCT ( I ,:). EQ . \"O \" )) THEN !           Loop over all rays DO K = 0 , NRAYS - 1 RATE ( I ) = RATE ( I ) + COPDRATE ( ALPHA ( I ), RAD_SURFACE ( K ), AV ( K ), COLUMN_NCO ( K ), COLUMN_NH2 ( K )) ENDDO NRCO = I GOTO 10 ENDIF !     Store the reaction number for CI photoionization. The rate itself !     is calculated separately by the function CIPDRATE (within shield.f) IF ( REACTANT ( I , 1 ). EQ . \"C  \" . AND . REACTANT ( I , 3 ). EQ . \"   \" . AND .& & (( PRODUCT ( I , 1 ). EQ . \"C+ \" . AND . PRODUCT ( I , 2 ). EQ . \"e- \" ) . OR .& & ( PRODUCT ( I , 1 ). EQ . \"e- \" . AND . PRODUCT ( I , 2 ). EQ . \"C+ \" ))) THEN !           Loop over all rays DO K = 0 , NRAYS - 1 RATE ( I ) = RATE ( I ) + CIPDRATE ( ALPHA ( I ), RAD_SURFACE ( K ), AV ( K ), GAMMA ( I ), COLUMN_NC ( K ), COLUMN_NH2 ( K ), TEMPERATURE ) ENDDO NRCI = I GOTO 10 ENDIF !     Store the reaction number for SI photoionization. The rate itself !     is calculated separately by the function SIPDRATE (within shield.f) IF ( REACTANT ( I , 1 ). EQ . \"S  \" . AND . REACTANT ( I , 3 ). EQ . \"   \" . AND .& & (( PRODUCT ( I , 1 ). EQ . \"S+ \" . AND . PRODUCT ( I , 2 ). EQ . \"e- \" ) . OR .& & ( PRODUCT ( I , 1 ). EQ . \"e- \" . AND . PRODUCT ( I , 2 ). EQ . \"S+ \" ))) THEN !           Loop over all rays DO K = 0 , NRAYS - 1 RATE ( I ) = RATE ( I ) + SIPDRATE ( ALPHA ( I ), RAD_SURFACE ( K ), AV ( K ), GAMMA ( I ), COLUMN_NS ( K )) ENDDO NRSI = I GOTO 10 ENDIF IF ( DUPLICATE ( I ). EQ . 0 ) THEN !           Loop over all rays DO K = 0 , NRAYS - 1 RATE ( I ) = RATE ( I ) + ALPHA ( I ) * RAD_SURFACE ( K ) * EXP ( - ( GAMMA ( I ) * AV ( K ))) ENDDO ELSE IF ( DUPLICATE ( I ). EQ . 1 ) THEN J = I DO IF ( TEMPERATURE . LE . RTMAX ( J )) THEN !                 Loop over all rays DO K = 0 , NRAYS - 1 RATE ( J ) = RATE ( J ) + ALPHA ( J ) * RAD_SURFACE ( K ) * EXP ( - ( GAMMA ( J ) * AV ( K ))) ENDDO EXIT ELSE IF ( DUPLICATE ( J + 1 ). LT . DUPLICATE ( J )) THEN !                 Loop over all rays DO K = 0 , NRAYS - 1 RATE ( J ) = RATE ( J ) + ALPHA ( J ) * RAD_SURFACE ( K ) * EXP ( - ( GAMMA ( J ) * AV ( K ))) ENDDO EXIT ELSE RATE ( J ) = 0.0D0 J = J + 1 ENDIF ENDDO ENDIF GOTO 10 !----------------------------------------------------------------------- !     Cosmic ray-induced ionization: 2 IF ( DUPLICATE ( I ). EQ . 0 ) THEN RATE ( I ) = ALPHA ( I ) * ZETALOCAL ELSE IF ( DUPLICATE ( I ). EQ . 1 ) THEN J = I DO IF ( TEMPERATURE . LE . RTMAX ( J )) THEN RATE ( J ) = ALPHA ( J ) * ZETALOCAL EXIT ELSE IF ( DUPLICATE ( J + 1 ). LT . DUPLICATE ( J )) THEN RATE ( J ) = ALPHA ( J ) * ZETALOCAL EXIT ELSE RATE ( J ) = 0.0D0 J = J + 1 ENDIF ENDDO ENDIF GOTO 10 110 RATE ( I ) = 0.0D0 ; GOTO 10 120 RATE ( I ) = 0.0D0 ; GOTO 10 130 RATE ( I ) = 0.0D0 ; GOTO 10 140 RATE ( I ) = 0.0D0 ; GOTO 10 !----------------------------------------------------------------------- !     Photoreactions due to cosmic ray-induced secondary photons: 3 IF ( DUPLICATE ( I ). EQ . 0 ) THEN RATE ( I ) = ALPHA ( I ) * ZETALOCAL * ( TEMPERATURE / 30 0.0D0 ) ** BETA ( I )& & * GAMMA ( I ) / ( 1.0D0 - OMEGA ) ELSE IF ( DUPLICATE ( I ). EQ . 1 ) THEN J = I DO IF ( TEMPERATURE . LE . RTMAX ( J )) THEN RATE ( J ) = ALPHA ( J ) * ZETALOCAL * ( TEMPERATURE / 30 0.0D0 ) ** BETA ( J )& & * GAMMA ( J ) / ( 1.0D0 - OMEGA ) EXIT ELSE IF ( DUPLICATE ( J + 1 ). LT . DUPLICATE ( J )) THEN RATE ( J ) = ALPHA ( J ) * ZETALOCAL * ( TEMPERATURE / 30 0.0D0 ) ** BETA ( J )& & * GAMMA ( J ) / ( 1.0D0 - OMEGA ) EXIT ELSE RATE ( J ) = 0.0D0 J = J + 1 ENDIF ENDDO ENDIF GOTO 10 !----------------------------------------------------------------------- !     Freeze-out of neutral species: 4 IF ( BETA ( I ). EQ . 0.0D0 ) THEN CION = 1.0D0 ELSE IF ( BETA ( I ). EQ . 1.0D0 ) THEN CION = 1.0D0 + 1 6.71D-4 / ( GRAIN_RADIUS * TEMPERATURE ) ELSE CION = 0.0D0 ENDIF STICKING = 0.3D0 RATE ( I ) = ALPHA ( I ) * 4.57D4 * 2.4D-22 * SQRT ( TEMPERATURE / GAMMA ( I )) * CION * STICKING GOTO 10 !----------------------------------------------------------------------- !     Freeze-out of singly charged positive ions: 5 IF ( BETA ( I ). EQ . 0.0D0 ) THEN CION = 1.0D0 ELSE IF ( BETA ( I ). EQ . 1.0D0 ) THEN CION = 1.0D0 + 1 6.71D-4 / ( GRAIN_RADIUS * TEMPERATURE ) ELSE CION = 0.0D0 ENDIF STICKING = 0.3D0 RATE ( I ) = ALPHA ( I ) * 4.57D4 * 2.4D-22 * SQRT ( TEMPERATURE / GAMMA ( I )) * CION * STICKING GOTO 10 !----------------------------------------------------------------------- !     Desorption due to cosmic ray heating: !     Treatment of Hasegawa & Herbst (1993, MNRAS, 261, 83, Equation 15) !6       RATE(I)=ALPHA(I)*ZETALOCAL !     Treatment of Roberts et al. (2007, MNRAS, 382, 773, Equation 3) 6 IF ( GAMMA ( I ). LE . 121 0.0D0 ) THEN YIELD = 1.0D5 ! Number of adsorbed molecules released per cosmic ray impact ELSE YIELD = 0.0D0 ENDIF FLUX = 2.06D-3 ! Flux of iron nuclei cosmic rays (in cm&#94;-2 s&#94;-1) RATE ( I ) = FLUX * ZETALOCAL * 2.4D-22 * YIELD GOTO 10 !----------------------------------------------------------------------- !     Photodesorption: 7 IF ( TEMPERATURE . LT . 5 0.0D0 ) THEN YIELD = 3.5D-3 ELSE IF ( TEMPERATURE . LT . 8 5.0D0 ) THEN YIELD = 4.0D-3 ELSE IF ( TEMPERATURE . LT . 10 0.0D0 ) THEN YIELD = 5.5D-3 ELSE YIELD = 7.5D-3 ENDIF !         FLUX=1.0D8 ! Flux of FUV photons in the unattenuated Habing field (in photons cm&#94;-2 s&#94;-1) FLUX = 1.7D8 ! Flux of FUV photons in the unattenuated Draine field (in photons cm&#94;-2 s&#94;-1) !        Loop over all rays DO K = 0 , NRAYS - 1 RATE ( I ) = RATE ( I ) + FLUX * RAD_SURFACE ( K ) * EXP ( - ( 1.8D0 * AV ( K ))) * 2.4D-22 * YIELD ENDDO GOTO 10 !----------------------------------------------------------------------- !     Thermal desorption: !     Treatment of Hasegawa, Herbst & Leung (1992, ApJS, 82, 167, Equations 2 & 3) 8 RATE ( I ) = SQRT ( 2.0D0 * 1.5D15 * KB / ( PI ** 2 * AU ) * ALPHA ( I ) / GAMMA ( I ))& & * EXP ( - ( ALPHA ( I ) / DUST_TEMPERATURE )) GOTO 10 !----------------------------------------------------------------------- !     Grain mantle reactions: 9 RATE ( I ) = ALPHA ( I ) GOTO 10 !----------------------------------------------------------------------- !     Check that the rate is physical (0<RATE(I)<1) and produce an error !     message if not. Impose a lower cut-off on all rate coefficients to !     prevent the problem becoming too stiff. Rates less than 1E-99 are !     set to zero. Grain-surface reactions and desorption mechanisms are !     allowed rates greater than 1. 10 CONTINUE #ifdef GRAINRECOMB IF ( REACTANT ( I , 1 ). EQ . \"H+ \" . AND . REACTANT ( I , 2 ). EQ . \"e- \" ) THEN C0 = 1 2.25 ; C1 = 8.074e-6 ; C2 = 1.378 ; C3 = 5.087E2 ; C4 = 1.586E-2 ; C5 = 0.4723 ; C6 = 1.102E-5 PSI = 0.0D0 DO K = 0 , NRAYS - 1 !PSI = PSI + 1.68D0*RAD_SURFACE(K)*EXP(-(1.8D0*AV(K)))*SQRT(TEMPERATURE)/nelectron PSI = PSI + 1.68D0 * RAD_SURFACE ( K ) * EXP ( - ( 2.63D0 * AV ( K ))) * SQRT ( TEMPERATURE ) / nelectron ENDDO ALPHA_G = 1e-14 * C0 / ( 1.0 + C1 * PSI ** C2 + C1 * PSI ** ( C2 - C5 - C6 * log ( TEMPERATURE )) * C3 * TEMPERATURE ** C4 ) RATE ( I ) = RATE ( I ) + ALPHA_G * density / nelectron ENDIF IF ( REACTANT ( I , 1 ). EQ . \"He+\" . AND . REACTANT ( I , 2 ). EQ . \"e- \" ) THEN C0 = 5.572 ; C1 = 3.185E-7 ; C2 = 1.512 ; C3 = 5.115E3 ; C4 = 3.903E-7 ; C5 = 0.4956 ; C6 = 5.494E-7 PSI = 0.0D0 DO K = 0 , NRAYS - 1 !PSI = PSI + 1.68D0*RAD_SURFACE(K)*EXP(-(1.8D0*AV(K)))*SQRT(TEMPERATURE)/nelectron PSI = PSI + 1.68D0 * RAD_SURFACE ( K ) * EXP ( - ( 2.63D0 * AV ( K ))) * SQRT ( TEMPERATURE ) / nelectron ENDDO ALPHA_G = 1e-14 * C0 / ( 1.0 + C1 * PSI ** C2 + C1 * PSI ** ( C2 - C5 - C6 * log ( TEMPERATURE )) * C3 * TEMPERATURE ** C4 ) RATE ( I ) = RATE ( I ) + ALPHA_G * density / nelectron ENDIF IF ( REACTANT ( I , 1 ). EQ . \"C+ \" . AND . REACTANT ( I , 2 ). EQ . \"e- \" ) THEN C0 = 4 5.58 ; C1 = 6.089E-3 ; C2 = 1.128 ; C3 = 4.331E2 ; C4 = 4.845E-2 ; C5 = 0.8120 ; C6 = 1.333E-4 PSI = 0.0D0 DO K = 0 , NRAYS - 1 !PSI = PSI + 1.68D0*RAD_SURFACE(K)*EXP(-(1.8D0*AV(K)))*SQRT(TEMPERATURE)/nelectron PSI = PSI + 1.68D0 * RAD_SURFACE ( K ) * EXP ( - ( 2.63D0 * AV ( K ))) * SQRT ( TEMPERATURE ) / nelectron ENDDO ALPHA_G = 1e-14 * C0 / ( 1.0 + C1 * PSI ** C2 + C1 * PSI ** ( C2 - C5 - C6 * log ( TEMPERATURE )) * C3 * TEMPERATURE ** C4 ) RATE ( I ) = RATE ( I ) + ALPHA_G * density / nelectron ENDIF #endif IF ( RATE ( I ). LT . 0.0D0 ) THEN PRINT * , 'ERROR! Negative rate for reaction' , I STOP ENDIF IF ( RATE ( I ). GT . 1.0D0 . AND . REACTANT ( I , 1 )( 1 : 1 ). NE . \"G\" ) RATE ( I ) = 1.0D0 IF ( RATE ( I ). LT . 1.0D-99 ) RATE ( I ) = 0.0D0 !     End of loop over rates ENDDO RETURN END SUBROUTINE CALCULATE_REACTION_RATES","tags":"","url":"sourcefile/calc_reac_rates.f90.html"},{"title":"h2_form.F90 – 3D-PDR","text":"This file depends on sourcefile~~h2_form.f90~~EfferentGraph sourcefile~h2_form.f90 h2_form.F90 sourcefile~definitions.f90 definitions.F90 sourcefile~h2_form.f90->sourcefile~definitions.f90 sourcefile~healpix_types.f90 healpix_types.F90 sourcefile~h2_form.f90->sourcefile~healpix_types.f90 sourcefile~modules.f90 modules.F90 sourcefile~h2_form.f90->sourcefile~modules.f90 sourcefile~healpix_types.f90->sourcefile~definitions.f90 sourcefile~modules.f90->sourcefile~definitions.f90 sourcefile~modules.f90->sourcefile~healpix_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !======================================================================= ! !  Calculate the rate of molecular hydrogen (H2) formation on grains !  using the treatment of Cazaux & Tielens (2002, ApJ, 575, L29) and !  Cazaux & Tielens (2004, ApJ, 604, 222). ! !----------------------------------------------------------------------- FUNCTION H2_FORMATION_RATE ( GAS_TEMPERATURE , GRAIN_TEMPERATURE ) RESULT ( RATE ) USE DEFINITIONS USE HEALPIX_TYPES USE GLOBAL_MODULE , ONLY : metallicity IMPLICIT NONE REAL ( KIND = DP ) :: RATE REAL ( KIND = DP ), INTENT ( IN ) :: GAS_TEMPERATURE , GRAIN_TEMPERATURE REAL ( KIND = DP ) :: THERMAL_VELOCITY , STICKING_COEFFICIENT , TOTAL_CROSS_SECTION REAL ( KIND = DP ) :: FLUX , FACTOR1 , FACTOR2 , EPSILON REAL ( KIND = DP ) :: SILICATE_FORMATION_EFFICIENCY , GRAPHITE_FORMATION_EFFICIENCY REAL ( KIND = DP ) :: SILICATE_CROSS_SECTION , SILICATE_MU , SILICATE_E_S , SILICATE_E_H2 REAL ( KIND = DP ) :: SILICATE_E_HP , SILICATE_E_HC , SILICATE_NU_H2 , SILICATE_NU_HC REAL ( KIND = DP ) :: GRAPHITE_CROSS_SECTION , GRAPHITE_MU , GRAPHITE_E_S , GRAPHITE_E_H2 REAL ( KIND = DP ) :: GRAPHITE_E_HP , GRAPHITE_E_HC , GRAPHITE_NU_H2 , GRAPHITE_NU_HC !  Mean thermal velocity of hydrogen atoms (cm s&#94;-1) THERMAL_VELOCITY = 1.45D5 * SQRT ( GAS_TEMPERATURE / 1.0D2 ) !  Calculate the thermally averaged sticking coefficient of hydrogen atoms on grains, !  as given by Hollenbach & McKee (1979, ApJS, 41, 555, eqn 3.7) STICKING_COEFFICIENT = 1.0D0 / ( 1.0D0 + 0.04D0 * SQRT ( GAS_TEMPERATURE + GRAIN_TEMPERATURE ) & & + 0.2D0 * ( GAS_TEMPERATURE / 1.0D2 ) + 0.08D0 * ( GAS_TEMPERATURE / 1.0D2 ) ** 2 ) FLUX = 1.0D-10 ! Flux of H atoms in monolayers per second (mLy s&#94;-1) TOTAL_CROSS_SECTION = 6.273D-22 ! Total mixed grain cross section per H nucleus (cm&#94;-2/nucleus) SILICATE_CROSS_SECTION = 8.473D-22 ! Silicate grain cross section per H nucleus (cm&#94;-2/nucleus) GRAPHITE_CROSS_SECTION = 7.908D-22 ! Graphite grain cross section per H nucleus (cm&#94;-2/nucleus) !  Silicate grain properties SILICATE_MU = 0.005D0 ! Fraction of newly formed H2 that stays on the grain surface SILICATE_E_S = 11 0.0D0 ! Energy of the saddle point between a physisorbed and a chemisorbed site (K) SILICATE_E_H2 = 32 0.0D0 ! Desorption energy of H2 molecules (K) SILICATE_E_HP = 45 0.0D0 ! Desorption energy of physisorbed H atoms (K) SILICATE_E_HC = 3.0D4 ! Desorption energy of chemisorbed H atoms (K) SILICATE_NU_H2 = 3.0D12 ! Vibrational frequency of H2 molecules in surface sites (s&#94;-1) SILICATE_NU_HC = 1.3D13 ! Vibrational frequency of H atoms in their surface sites (s&#94;-1) FACTOR1 = SILICATE_MU * FLUX / ( 2 * SILICATE_NU_H2 * EXP ( - SILICATE_E_H2 / GRAIN_TEMPERATURE )) FACTOR2 = 1.0D0 * ( 1.0D0 + SQRT (( SILICATE_E_HC - SILICATE_E_S ) / ( SILICATE_E_HP - SILICATE_E_S ))) ** 2 & & / 4.0D0 * EXP ( - SILICATE_E_S / GRAIN_TEMPERATURE ) EPSILON = 1.0D0 / ( 1.0D0 + SILICATE_NU_HC / ( 2 * FLUX ) * EXP ( - 1.5 * SILICATE_E_HC / GRAIN_TEMPERATURE ) & & * ( 1.0D0 + SQRT (( SILICATE_E_HC - SILICATE_E_S ) / ( SILICATE_E_HP - SILICATE_E_S ))) ** 2 ) SILICATE_FORMATION_EFFICIENCY = 1.0D0 / ( 1.0D0 + FACTOR1 + FACTOR2 ) * EPSILON !  Graphite grain properties GRAPHITE_MU = 0.005D0 ! Fraction of newly formed H2 that stays on the grain surface GRAPHITE_E_S = 26 0.0D0 ! Energy of the saddle point between a physisorbed and a chemisorbed site (K) GRAPHITE_E_H2 = 52 0.0D0 ! Desorption energy of H2 molecules (K) GRAPHITE_E_HP = 80 0.0D0 ! Desorption energy of physisorbed H atoms (K) GRAPHITE_E_HC = 3.0D4 ! Desorption energy of chemisorbed H atoms (K) GRAPHITE_NU_H2 = 3.0D12 ! Vibrational frequency of H2 molecules in surface sites (s&#94;-1) GRAPHITE_NU_HC = 1.3D13 ! Vibrational frequency of H atoms in their surface sites (s&#94;-1) FACTOR1 = GRAPHITE_MU * FLUX / ( 2 * GRAPHITE_NU_H2 * EXP ( - GRAPHITE_E_H2 / GRAIN_TEMPERATURE )) FACTOR2 = 1.0D0 * ( 1.0D0 + SQRT (( GRAPHITE_E_HC - GRAPHITE_E_S ) / ( GRAPHITE_E_HP - GRAPHITE_E_S ))) ** 2 & & / 4.0D0 * EXP ( - GRAPHITE_E_S / GRAIN_TEMPERATURE ) EPSILON = 1.0D0 / ( 1.0D0 + GRAPHITE_NU_HC / ( 2 * FLUX ) * EXP ( - 1.5 * GRAPHITE_E_HC / GRAIN_TEMPERATURE ) & & * ( 1.0D0 + SQRT (( GRAPHITE_E_HC - GRAPHITE_E_S ) / ( GRAPHITE_E_HP - GRAPHITE_E_S ))) ** 2 ) GRAPHITE_FORMATION_EFFICIENCY = 1.0D0 / ( 1.0D0 + FACTOR1 + FACTOR2 ) * EPSILON !!$!  Use the tradional rate, with a simple temperature dependence based on the !!$!  thermal velocity of the H atoms in the gas and neglecting any temperature !!$!  dependency of the formation and sticking efficiencies !!$   RATE=3.0D-18*SQRT(GAS_TEMPERATURE) !!$!  Use the treatment of de Jong (1977, A&A, 55, 137, p140 right column). !!$!  The second exponential dependence on the gas temperature reduces the !!$!  efficiency at high temperatures and so prevents runaway H2 formation !!$!  heating at high temperatures: !!$! !!$!  k_H2 = 3E-18 * T&#94;0.5 * exp(-T/1000)   [cm3/s] !!$! !!$   RATE=3.0D-18*SQRT(GAS_TEMPERATURE)*EXP(-(GAS_TEMPERATURE/1.0D3)) !!$!  Use the treatment of Tielens & Hollenbach (1985, ApJ, 291, 722, eqn 4) !!$   RATE=0.5D0*THERMAL_VELOCITY*TOTAL_CROSS_SECTION*STICKING_COEFFICIENT !  Use the treatment of Cazaux & Tielens (2002, ApJ, 575, L29) and !  Cazaux & Tielens (2004, ApJ, 604, 222) RATE = 0.5D0 * THERMAL_VELOCITY * ( SILICATE_CROSS_SECTION * SILICATE_FORMATION_EFFICIENCY & & + GRAPHITE_CROSS_SECTION * GRAPHITE_FORMATION_EFFICIENCY ) * STICKING_COEFFICIENT * METALLICITY !RATE = RATE / 3.0 !!$!  Use the expression given by Markus Rollig during the February 2012 Leiden workshop !!$   RATE=0.5D0*THERMAL_VELOCITY & !!$      & *(SILICATE_CROSS_SECTION/((1.0D0 + 6.998D24/EXP(1.5*SILICATE_E_HC/GRAIN_TEMPERATURE)) & !!$      & *(1.0D0 + 1.0D0/(EXP(SILICATE_E_HP/GRAIN_TEMPERATURE) & !!$      & *(0.427D0/EXP((SILICATE_E_HP-SILICATE_E_S)/GRAIN_TEMPERATURE) + 2.5336D-14*SQRT(GRAIN_TEMPERATURE))))) & !!$      & + GRAPHITE_CROSS_SECTION/((1.0D0 + 4.610D24/EXP(1.5*GRAPHITE_E_HC/GRAIN_TEMPERATURE)) & !!$      & *(1.0D0 + 1.0D0/(EXP(GRAPHITE_E_HP/GRAIN_TEMPERATURE) & !!$      & *(0.539D0/EXP((GRAPHITE_E_HP-GRAPHITE_E_S)/GRAIN_TEMPERATURE) + 5.6334D-14*SQRT(GRAIN_TEMPERATURE)))))) & !!$      & *STICKING_COEFFICIENT RETURN END FUNCTION H2_FORMATION_RATE !=======================================================================","tags":"","url":"sourcefile/h2_form.f90.html"},{"title":"m_IOAndVisu.F90 – 3D-PDR","text":"This file depends on sourcefile~~m_ioandvisu.f90~~EfferentGraph sourcefile~m_ioandvisu.f90 m_IOAndVisu.F90 sourcefile~m_mesh.f90 m_Mesh.F90 sourcefile~m_ioandvisu.f90->sourcefile~m_mesh.f90 sourcefile~modules.f90 modules.F90 sourcefile~m_ioandvisu.f90->sourcefile~modules.f90 sourcefile~definitions.f90 definitions.F90 sourcefile~modules.f90->sourcefile~definitions.f90 sourcefile~healpix_types.f90 healpix_types.F90 sourcefile~modules.f90->sourcefile~healpix_types.f90 sourcefile~healpix_types.f90->sourcefile~definitions.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module m_IOAndVisu #ifdef OPENMP use omp_lib #endif use maincode_module use m_Mesh implicit none private integer , parameter , public :: mytype_save = KIND ( 0.0D0 ) public :: InitVisu , dump_visu contains !****************************************************************** ! InitVisu !****************************************************************** subroutine InitVisu implicit none ! locals character ( 128 ) :: XdmfFile integer :: nUnitFile , ierror , nflds , ifld , iprec , i , j , k ! write XDMF file write ( xdmfFile , \"(A)\" ) \"VisuFor3DPDR.xmf\" open ( newunit = nUnitFile , file = XdmfFile , status = 'replace' , form = 'formatted' , IOSTAT = ierror ) if ( ierror /= 0 ) print * , \"Cannot open xmf file\" ! XDMF/XMF Title write ( nUnitFile , '(A)' ) '<?xml version=\"1.0\" ?>' write ( nUnitFile , '(A)' ) '<!DOCTYPE Xdmf SYSTEM \"Xdmf.dtd\" []>' write ( nUnitFile , '(A)' ) '<Xdmf xmlns:xi=\"http://www.w3.org/2001/XInclude\" Version=\"2.0\">' write ( nUnitFile , '(A)' ) '<Domain>' ! grid iprec = mytype_save write ( nUnitFile , '(A,3I7,A)' ) '    <Topology name=\"TOPO\" TopologyType=\"3DRectMesh\" Dimensions=\"' , nzc , nyc , nxc , '\"/>' write ( nUnitFile , '(A)' ) '    <Geometry name=\"GEO\" GeometryType=\"VXVYVZ\">' ! x-grid write ( nUnitFile , '(A,I1,A,I5,A)' ) '        <DataItem Format=\"XML\" DataType=\"Float\" Precision=\"' ,& & iprec , '\" Endian=\"Native\" Dimensions=\"' , nxc , '\">' write ( nUnitFile , '(A)' , advance = 'no' ) '        ' do i = 1 , nxc write ( nUnitFile , '(E14.7)' , advance = 'no' ) ( i - 1 ) * dx + dx * 0.5_RK enddo write ( nUnitFile , '(A)' ) ' ' ; write ( nUnitFile , '(A)' ) '        </DataItem>' ! y-grid write ( nUnitFile , '(A,I1,A,I5,A)' ) '        <DataItem Format=\"XML\" DataType=\"Float\" Precision=\"' ,& & iprec , '\" Endian=\"Native\" Dimensions=\"' , nyc , '\">' write ( nUnitFile , '(A)' , advance = 'no' ) '        ' do j = 1 , nyc write ( nUnitFile , '(E14.7)' , advance = 'no' ) ( j - 1 ) * dy + dy * 0.5_RK enddo write ( nUnitFile , '(A)' ) ' ' ; write ( nUnitFile , '(A)' ) '        </DataItem>' ! z-grid write ( nUnitFile , '(A,I1,A,I5,A)' ) '        <DataItem Format=\"XML\" DataType=\"Float\" Precision=\"' ,& & iprec , '\" Endian=\"Native\" Dimensions=\"' , nzc , '\">' write ( nUnitFile , '(A)' , advance = 'no' ) '        ' do k = 1 , nzc write ( nUnitFile , '(E14.7)' , advance = 'no' ) ( k - 1 ) * dz + dz * 0.5_RK enddo write ( nUnitFile , '(A)' ) ' ' ; write ( nUnitFile , '(A)' ) '        </DataItem>' write ( nUnitFile , '(A)' ) '    </Geometry>' ! Time series nflds = 1 write ( nUnitFile , '(A)' ) '    <Grid Name=\"TimeSeries\" GridType=\"Collection\" CollectionType=\"Temporal\">' write ( nUnitFile , '(A)' ) '        <Time TimeType=\"List\">' write ( nUnitFile , '(A,I6,A)' ) '        <DataItem Format=\"XML\" NumberType=\"Int\" Dimensions=\"' , nflds , '\">' write ( nUnitFile , '(A)' , advance = 'no' ) '        ' ifld = 0 write ( nUnitFile , '(I10)' , advance = 'no' ) ifld write ( nUnitFile , '(A)' ) '        </DataItem>' write ( nUnitFile , '(A)' ) ' ' ; write ( nUnitFile , '(A)' ) '       </Time>' ! attribute write ( nUnitFile , '(A,I10.10,A)' ) '        <Grid Name=\"T' , ifld , '\" GridType=\"Uniform\">' write ( nUnitFile , '(A)' ) '            <Topology Reference=\"/Xdmf/Domain/Topology[1]\"/>' write ( nUnitFile , '(A)' ) '            <Geometry Reference=\"/Xdmf/Domain/Geometry[1]\"/>' ! add virables call Write_XDMF_One ( nUnitFile , ifld , 'Density' ) call Write_XDMF_One ( nUnitFile , ifld , 'Tgas' ) write ( nUnitFile , '(A)' ) '        </Grid>' write ( nUnitFile , '(A)' ) '    </Grid>' write ( nUnitFile , '(A)' ) '</Domain>' write ( nUnitFile , '(A)' ) '</Xdmf>' close ( nUnitFile , IOSTAT = ierror ) end subroutine InitVisu !****************************************************************** ! Write_XDMF_One !****************************************************************** subroutine Write_XDMF_One ( nUnitFile , ifld , chAttribute ) implicit none integer , intent ( in ) :: nUnitFile , ifld character ( * ), intent ( in ) :: chAttribute ! locals character ( 128 ) :: chFile integer :: iprec = mytype_save write ( chFile , '(A,A,I10.10)' ) \"VisuFor3DPDR\" , \"_\" // trim ( adjustl ( chAttribute )) // \"_\" , ifld write ( nUnitFile , '(A)' ) '            <Attribute Name=\"' // trim ( chAttribute ) // '\" Center=\"Node\">' write ( nUnitFile , '(A,I1,A,3I7,A)' ) '                <DataItem Format=\"Binary\" DataType=\"Float\" Precision=\"' ,& & iprec , '\" Endian=\"Native\" Dimensions=\"' , nzc , nyc , nxc , '\">' write ( nUnitFile , '(A)' ) '                    ' // trim ( chFile ) write ( nUnitFile , '(A)' ) '                </DataItem>' write ( nUnitFile , '(A)' ) '            </Attribute>' end subroutine Write_XDMF_One !****************************************************************** ! dump_visu !****************************************************************** subroutine dump_visu implicit none ! locals character ( 128 ) :: chFile integer :: I , J , K , p , cI , ntime , nUnit , ierror real ( RK ), allocatable , dimension (:) :: GridCell ntime = 0 ! write Density allocate ( GridCell ( nxc * nyc * nzc )) GridCell = 0.D0 #ifdef XYZ !$omp parallel do do p = 1 , pdr_ptot ! GridCell(p)=log10(pdr(p)%rho) GridCell ( p ) = pdr ( p )% rho enddo !$omp end parallel do #else !$omp parallel do private (p,cI) do K = 1 , nzc do J = 1 , nyc do I = 1 , nxc p = I + ( J - 1 ) * nxc + ( K - 1 ) * ( nxc * nyc ) cI = K + ( J - 1 ) * nzc + ( I - 1 ) * ( nzc * nyc ) GridCell ( p ) = pdr ( cI )% rho enddo enddo enddo !$omp end parallel do #endif write ( chFile , \"(A,I10.10)\" ) \"VisuFor3DPDR_Density_\" , ntime open ( newunit = nUnit , file = chFile , status = 'replace' , form = 'unformatted' , access = 'stream' ) write ( nUnit ) GridCell close ( nUnit ) ! write Tgas GridCell = 0.D0 #ifdef XYZ !$omp parallel do do p = 1 , pdr_ptot GridCell ( p ) = pdr ( p )% Tgas enddo !$omp end parallel do #else !$omp parallel do private (p,cI) do K = 1 , nzc do J = 1 , nyc do I = 1 , nxc p = I + ( J - 1 ) * nxc + ( K - 1 ) * ( nxc * nyc ) cI = K + ( J - 1 ) * nzc + ( I - 1 ) * ( nzc * nyc ) GridCell ( p ) = pdr ( cI )% Tgas enddo enddo enddo !$omp end parallel do #endif write ( chFile , \"(A,I10.10)\" ) \"VisuFor3DPDR_Tgas_\" , ntime open ( newunit = nUnit , file = chFile , status = 'replace' , form = 'unformatted' , access = 'stream' ) write ( nUnit ) GridCell close ( nUnit ) deallocate ( GridCell ) !     ! write deltau !     allocate(GridCell(nxc,nyc,nzc),GridCell_temp(nxc,nyc,nzc)) !     GridCell=0.D0; GridCell_temp=0.D0 ! !$omp parallel do private(II,JJ,KK) !     do k=1,nznp !       do j=1,nynp !         do i=1,nxnp !         II=i+IID*nxnp !         JJ=j+JID*nynp !         KK=k+KID*nznp !         GridCell_temp(II,JJ,KK)=Deltau(i,j,k) !         enddo !       enddo !     enddo ! !$omp end parallel do !     call MPI_REDUCE(GridCell_temp,GridCell,nxc*nyc*nzc,MPI_DOUBLE_PRECISION,MPI_SUM,0,MPI_COMM_WORLD,ierror) !     ! call MPI_ALLREDUCE(GridCell_temp,GridCell,nxc*nyc*nzc,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,ierror) !     if(nrank==0) then !       write(chFile,\"(A,I10.10)\") \"VisuForVolume_deltau_\",ntime !       open(newunit=nUnit, file=chFile, status='replace', form='unformatted', access='stream') !         write(nUnit) GridCell !       close(nUnit) !     endif !     deallocate(GridCell,GridCell_temp) !     ! write J0 !     allocate(GridCell(nxc,nyc,nzc),GridCell_temp(nxc,nyc,nzc)) !     GridCell=0.D0; GridCell_temp=0.D0 ! !$omp parallel do private(II,JJ,KK) !     do k=1,nznp !       do j=1,nynp !         do i=1,nxnp !         II=i+IID*nxnp !         JJ=j+JID*nynp !         KK=k+KID*nznp ! #ifndef SPHERE !         GridCell_temp(II,JJ,KK)=log10(spop(1,i,j,k)) ! #else !         GridCell_temp(II,JJ,KK)=spop(1,i,j,k) ! #endif !         enddo !       enddo !     enddo ! !$omp end parallel do !     call MPI_REDUCE(GridCell_temp,GridCell,nxc*nyc*nzc,MPI_DOUBLE_PRECISION,MPI_SUM,0,MPI_COMM_WORLD,ierror) !     ! call MPI_ALLREDUCE(GridCell_temp,GridCell,nxc*nyc*nzc,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,ierror) !     if(nrank==0) then !       open(newunit=nUnit,file='spop1.dat') !       do k = 1,nzc !         do j = 1,nyc !           do i = 1,nxc !             xc=(real(i,kind=RK)-0.5D0)*ndSize !             yc=(real(j,kind=RK)-0.5D0)*ndSize !             zc=(real(k,kind=RK)-0.5D0)*ndSize !             rr=radius-sqrt((xc-xp)**2.D0+(yc-yp)**2.D0+(zc-zp)**2.D0) !             if(k==nzc/2.and.j==nyc/2.and.i.ge.nxc/2) then !               write(nUnit,'(1ES11.3)') GridCell(i,j,k) !             endif !           enddo !         enddo !       enddo !       close(nUnit) !       write(chFile,\"(A,I10.10)\") \"VisuForVolume_J0_\",ntime !       open(newunit=nUnit, file=chFile, status='replace', form='unformatted', access='stream') !         write(nUnit) GridCell !       close(nUnit) !     endif !     deallocate(GridCell,GridCell_temp) !     ! write J1 !     allocate(GridCell(nxc,nyc,nzc),GridCell_temp(nxc,nyc,nzc)) !     GridCell=0.D0; GridCell_temp=0.D0 ! !$omp parallel do private(II,JJ,KK) !     do k=1,nznp !       do j=1,nynp !         do i=1,nxnp !         II=i+IID*nxnp !         JJ=j+JID*nynp !         KK=k+KID*nznp ! #ifndef SPHERE !         GridCell_temp(II,JJ,KK)=log10(spop(2,i,j,k)) ! #else !         GridCell_temp(II,JJ,KK)=spop(2,i,j,k) ! #endif !         enddo !       enddo !     enddo ! !$omp end parallel do !     call MPI_REDUCE(GridCell_temp,GridCell,nxc*nyc*nzc,MPI_DOUBLE_PRECISION,MPI_SUM,0,MPI_COMM_WORLD,ierror) !     ! call MPI_ALLREDUCE(GridCell_temp,GridCell,nxc*nyc*nzc,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,ierror) !     if(nrank==0) then !       open(newunit=nUnit,file='spop2.dat') !       do k = 1,nzc !         do j = 1,nyc !           do i = 1,nxc !             xc=(real(i,kind=RK)-0.5D0)*ndSize !             yc=(real(j,kind=RK)-0.5D0)*ndSize !             zc=(real(k,kind=RK)-0.5D0)*ndSize !             rr=radius-sqrt((xc-xp)**2.D0+(yc-yp)**2.D0+(zc-zp)**2.D0) !             if(k==nzc/2.and.j==nyc/2.and.i.ge.nxc/2) then !               write(nUnit,'(1ES11.3)') GridCell(i,j,k) !             endif !           enddo !         enddo !       enddo !       close(nUnit) !       write(chFile,\"(A,I10.10)\") \"VisuForVolume_J1_\",ntime !       open(newunit=nUnit, file=chFile, status='replace', form='unformatted', access='stream') !         write(nUnit) GridCell !       close(nUnit) !     endif !     deallocate(GridCell,GridCell_temp) !     ! write optical depth and escaprprobability !     allocate(GridCellPix(nxc,nyc,nzc,0:tr_nPix-1),GridCellPix_temp(nxc,nyc,nzc,0:tr_nPix-1)) !     allocate(GridCell(nxc,nyc,nzc),GridCell_temp(nxc,nyc,nzc)) !     GridCellPix=0.D0; GridCell_temp=0.D0 !     GridCell=0.D0; GridCell_temp=0.D0 ! !$omp parallel do private(II,JJ,KK) !     do k=1,nznp !       do j=1,nynp !         do i=1,nxnp !         II=i+IID*nxnp !         JJ=j+JID*nynp !         KK=k+KID*nznp !         GridCell_temp(II,JJ,KK)=beta(i,j,k) !           do il=0,tr_nPix-1 !             GridCellPix_temp(II,JJ,KK,il)=OpticalDepth(i,j,k,il) !           enddo !         enddo !       enddo !     enddo ! !$omp end parallel do !     call MPI_REDUCE(GridCell_temp,GridCell,nxc*nyc*nzc,MPI_DOUBLE_PRECISION,MPI_SUM,0,MPI_COMM_WORLD,ierror) !     call MPI_REDUCE(GridCellPix_temp,GridCellPix,nxc*nyc*nzc*tr_nPix,MPI_DOUBLE_PRECISION,MPI_SUM,0,MPI_COMM_WORLD,ierror) !     ! call MPI_ALLREDUCE(GridCell_temp,GridCell,nxc*nyc*nzc,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,ierror) !     ! call MPI_ALLREDUCE(GridCellPix_temp,GridCellPix,nxc*nyc*nzc*tr_nPix,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,ierror) !     ! find ray index !     max_dotprod = 0.0 !     xnode = 1.D0 !     ynode = 0.D0 !     znode = 0.D0 !     do ipix = 0,tr_nPix-1 !       call pix2ang_nest(tr_nSide, ipix, thfpix, phfpix) !       x = sin(thfpix)*cos(phfpix) !       y = sin(thfpix)*sin(phfpix) !       z = cos(thfpix) !       dotprod = x*xnode + y*ynode + z*znode !       if (dotprod > max_dotprod) then !         max_dotprod = dotprod !         iclosest = ipix !       endif !     enddo !     call pix2ang_nest(tr_nSide, iclosest, thfpix, phfpix) !     if(nrank==0) print*,'direction',iclosest,thfpix,phfpix !     if(nrank==0) then !       open(newunit=nUnit,file='escape.dat') !       do k = 1,nzc !         do j = 1,nyc !           do i = 1,nxc !             xc=(real(i,kind=RK)-0.5D0)*ndSize !             yc=(real(j,kind=RK)-0.5D0)*ndSize !             zc=(real(k,kind=RK)-0.5D0)*ndSize !             rr=radius-sqrt((xc-xp)**2.D0+(yc-yp)**2.D0+(zc-zp)**2.D0) !             if(k==nzc/2.and.j==nyc/2.and.i.ge.nxc/2) then !               write(nUnit,*) rr,GridCellPix(i,j,k,iclosest),GridCell(i,j,k) !             endif !           enddo !         enddo !       enddo !       close(nUnit) !       write(chFile,\"(A,I10.10)\") \"VisuForVolume_beta_\",ntime !       open(newunit=nUnit, file=chFile, status='replace', form='unformatted', access='stream') !         write(nUnit) GridCell !       close(nUnit) !     endif !     deallocate(GridCellPix,GridCellPix_temp) !     deallocate(GridCell,GridCell_temp) end subroutine dump_visu end module m_IOAndVisu","tags":"","url":"sourcefile/m_ioandvisu.f90.html"},{"title":"3DPDR.F90 – 3D-PDR","text":"This file depends on sourcefile~~3dpdr.f90~~EfferentGraph sourcefile~3dpdr.f90 3DPDR.F90 sourcefile~definitions.f90 definitions.F90 sourcefile~3dpdr.f90->sourcefile~definitions.f90 sourcefile~healpix_types.f90 healpix_types.F90 sourcefile~3dpdr.f90->sourcefile~healpix_types.f90 sourcefile~modules.f90 modules.F90 sourcefile~3dpdr.f90->sourcefile~modules.f90 sourcefile~healpix_types.f90->sourcefile~definitions.f90 sourcefile~modules.f90->sourcefile~definitions.f90 sourcefile~modules.f90->sourcefile~healpix_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program threedpdr use definitions use healpix_types use healpix_module use maincode_module use uclpdr_module , only : start use global_module #ifdef OPENMP use omp_lib #endif use chemistry_module use maincode_local !use m_IOAndVisu !call logo real ( kind = dp ) :: thfpix , phfpix call read_command_line call readparams #if defined RESTART && defined THERMALBALANCE restart_file = trim ( adjustl ( output )) // \"_restart.bin\" inquire ( file = restart_file , exist = restart ) if ( restart ) then write ( 6 , * ) ' ' write ( 6 , * ) ' *****************' write ( 6 , * ) ' *** [RESTART] ***' write ( 6 , * ) ' *****************' write ( 6 , * ) ' ' endif #endif v_turb = v_turb_inp * 1.0D5 start = . true . !call writeparams call readdensity call allocations call readcoolants call read_species ( nspec , species , init_abundance , mass ) call READ_RATES ( NREAC , REACTANT , PRODUCT , ALPHA , BETA , GAMMA , rate , DUPLICATE , RTMIN , RTMAX ) !HEALPix setup nside = 2 ** level nrays = 12 * nside ** 2 ns_max = 8192 allocate ( vector ( 1 : 3 )) allocate ( vertex ( 1 : 3 , 1 : 4 )) allocate ( vectors ( 1 : 3 , 0 : nrays - 1 )) call mk_xy2pix do i = 1 , nrays ipix = i - 1 !ipix is the ID of a HEALPix ray. Runs with values 0:nrays-1 call pix2vec_nest ( nside , ipix , pix2x , pix2y , vector , vertex ) vectors ( 1 : 3 , ipix ) = vector ( 1 : 3 ) !Stores in memory enddo call initialization !call InitVisu #ifdef OPENMP !$OMP PARALLEL !$OMP MASTER CPUs = OMP_GET_NUM_THREADS () write ( 6 , * ) \"Number of CPUs: \" , OMP_GET_NUM_THREADS () !$OMP END MASTER !$OMP END PARALLEL #else write ( 6 , * ) 'Processing in SERIAL' #endif write ( 6 , * ) 'Performing ray-tracing' call evaluation_points write ( 6 , * ) 'Calculating UV field' call calc_UVfield out_file = trim ( adjustl ( output )) // \".UV.fin\" out_file2 = trim ( adjustl ( out_file )) // \"]\" write ( 6 , '(\" Writing file [\",A)' ) trim ( adjustl ( out_file2 )) open ( unit = 21 , file = out_file , status = 'replace' ) do p = 1 , pdr_ptot write ( 21 , * ) pdr ( p )% x , pdr ( p )% y , pdr ( p )% z , pdr ( p )% rho , pdr ( p )% UVfield enddo close ( 21 ) out_file = trim ( adjustl ( output )) // \".rayDir.fin\" out_file2 = trim ( adjustl ( out_file )) // \"]\" write ( 6 , '(\" Writing file [\",A)' ) trim ( adjustl ( out_file2 )) open ( unit = 21 , file = out_file , status = 'replace' ) do p = 0 , nrays - 1 call pix2ang_nest ( nside , p , thfpix , phfpix ) write ( 21 , * ) thfpix , phfpix enddo close ( 21 ) out_file = trim ( adjustl ( output )) // \".rayAV.fin\" out_file2 = trim ( adjustl ( out_file )) // \"]\" write ( 6 , '(\" Writing file [\",A)' ) trim ( adjustl ( out_file2 )) open ( unit = 21 , file = out_file , status = 'replace' ) do p = 1 , pdr_ptot write ( 21 , * ) pdr ( p )% AV enddo close ( 21 ) #ifdef UVDEBUG stop #endif #ifdef CRATTENUATION write ( 6 , * ) 'Calculating CRIR attenuation' #else write ( 6 , * ) 'Setting CR ionization rate' #endif call calc_CRattenuation write ( 6 , * ) 'Setting dust temperatures' #ifdef DUST call calculate_dust_temperatures #else do p = 1 , pdr_ptot pdr ( p )% Tdust = dust_temperature enddo #endif #ifdef THERMALBALANCE first_time = . true . #endif write ( 6 , * ) 'Calculating column densities' referee = 0 call calc_columndens referee = 1 start_time = 0.0D0 #if defined RESTART && defined THERMALBALANCE if ( restart ) then open ( unit = 77 , file = restart_file , status = 'old' , form = 'unformatted' ) do p = 1 , pdr_ptot read ( 77 ) pdr ( p )% restconverged , pdr ( p )% Tgas , pdr ( p )% abundance pdr ( p )% nTgas = pdr ( p )% Tgas pdr ( p )% Tlow = pdr ( p )% Tgas / 2.0 pdr ( p )% Thigh = pdr ( p )% Tgas * 1.5 enddo endif #endif ITERATION = 0 !======== LTE LEVEL POPULATIONS ============ write ( 6 , * ) '' ; write ( 6 , * ) 'Calculating LTE level populations' call chemicaliterations ( 1 , CHEMITERATIONS ) do p = 1 , pdr_ptot do i = 1 , coo pdr ( p )% coolant ( i )% isconverged = . false . enddo pdr ( p )% levelconverged = . false . #ifdef THERMALBALANCE pdr ( p )% fullyconverged = . false . #ifndef ONEDIMENSIONAL if ( pdr ( p )% rho < 1.0 ) pdr ( p )% fullyconverged = . true . #endif pdr ( p )% doleveltmin = . false . #endif do i = 1 , coo allocate ( pdr ( p )% cooling ( i )) enddo do i = 1 , 12 allocate ( pdr ( p )% heating ( i )) enddo enddo write ( 6 , * ) '' write ( 6 , * ) '----------------' write ( 6 , * ) 'Iterations begin' write ( 6 , * ) '----------------' levpop_iteration = 0 do k = 1 , coo coolant ( k )% percentage = 0 enddo DO ITERATION = 1 , ITERTOT write_output = . false . write ( 6 , * ) '' write ( 6 , '(\" Iteration = \",I4)' ) iteration levpop_iteration = levpop_iteration + 1 write ( 6 , '(\" Level population iteration = \",I3)' ) levpop_iteration #if defined RESTART && defined THERMALBALANCE if ( level_conv . and . first_time ) then do p = 1 , pdr_ptot if ( pdr ( p )% restconverged ) pdr ( p )% fullyconverged = . true . enddo endif #endif !LTE/LVG computations IF ( iteration . gt . 1. and . levpop_iteration . eq . 1 ) THEN call chemicaliterations ( 2 , 3 ) ELSE call coolingfunctions ENDIF call changetemperature #ifdef THERMALBALANCE if ( level_conv . and . first_time ) first_time = . false . i = 0 do p = 1 , pdr_ptot if ( pdr ( p )% fullyconverged ) i = i + 1 enddo if ( level_conv ) then write ( 6 , * ) 'Resetting [level_conv=.false.]' level_conv = . false . write_output = . true . endif thermal_percentage = 10 0.D0 * real ( i , kind = dp ) / real ( pdr_ptot , kind = dp ) write ( * , '(\" Thermal balance is \",F5.1,\"% converged.\")' ) thermal_percentage !write(*,'(\" [\",I6,\"/\",I6,\"]\")') i,pdr_ptot if ( i . eq . pdr_ptot ) then write ( 6 , * ) '#### Converged through thermal balance ####' goto 2 endif #endif RELCH_conv = . true . do p = 1 , pdr_ptot pdr ( p )% levelconverged = . false . enddo call checkconvergence if (. not . relch_conv ) then goto 1 else write ( 6 , * ) '#### Converged through level populations ####' levpop_iteration = 0 #ifdef THERMALBALANCE #ifdef RESTART close ( 77 ); open ( unit = 77 , file = restart_file , status = 'replace' , form = 'unformatted' ) out_file2 = trim ( adjustl ( restart_file )) // \"]\" write ( 6 , '(\" Writing file [\",A)' ) trim ( adjustl ( out_file2 )) do p = 1 , pdr_ptot write ( 77 ) pdr ( p )% fullyconverged , pdr ( p )% Tgas , pdr ( p )% abundance enddo #endif write ( 6 , * ) 'Enabling thermal balance routine in next iteration' level_conv = . true . goto 1 #else goto 2 #endif endif 1 continue i = 0 do k = 1 , coo coolant ( k )% incr = 0 enddo do p = 1 , pdr_ptot if ( pdr ( p )% levelconverged ) i = i + 1 do k = 1 , coo if ( pdr ( p )% coolant ( k )% isconverged ) coolant ( k )% incr = coolant ( k )% incr + 1 enddo enddo levpop_percentage = 10 0.D0 * real ( i , kind = dp ) / real ( pdr_ptot , kind = dp ) do k = 1 , coo coolant ( k )% percentage = 10 0.D0 * real ( coolant ( k )% incr ) / real ( pdr_ptot ) write ( * , '(A, F6.2, A)' ) ' Coolant ' // trim ( adjustl ( coolant ( k )% cname )) // ' is ' , coolant ( k )% percentage , '% converged' !  write(*,*) trim(adjustl(coolant(k)%cname)),' %convergence: ',coolant(k)%percentage enddo write ( * , '(\" Level populations are \",F5.1,\"% converged.\")' ) levpop_percentage !write(*,'(\" [\",I6,\"/\",I6,\"]\")') i,pdr_ptot #ifdef THERMALBALANCE if ( int ( levpop_percentage , kind = i4b ). ge . 100 ) then do p = 1 , pdr_ptot pdr ( p )% levelconverged = . false . enddo write ( 6 , * ) 'Resetting [level_converged=.false.] array' endif #endif !write(6,*) 'Updating population densities...' #ifdef OPENMP !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(p,ilevel) #endif do p = 1 , pdr_ptot do k = 1 , coo DO ilevel = 1 , coolant ( k )% cnlev pdr ( p )% coolant ( k )% pop ( ilevel ) = pdr ( p )% coolant ( k )% solution ( ilevel ) ENDDO enddo enddo #ifdef OPENMP !$OMP END PARALLEL DO #endif END DO !ITERATIONS 2 continue if ( iteration . ge . 1 ) then if ( iteration . lt . itertot ) then WRITE ( 6 , * ) '3DPDR converged after ' , ITERATION - 1 , ' iterations' else write ( 6 , * ) 'Reached maximum number of iterations without convergence.' write ( 6 , * ) 'To reach convergence, increase the relative number in [params.dat]' endif write ( 6 , * ) 'Writing final outputs' call writeoutputs endif !#ifdef RAYTHEIA !call dump_visu !#endif write ( 6 , * ) '' #ifdef OPENMP write ( 6 , * ) \"Number of CPUs: \" , CPUs #endif write ( 6 , * ) 'Finished !' !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ !~~~~~~~~~~END OF MAIN PROGRAM~~~~~~~~~~~~~~~~ !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ end Program","tags":"","url":"sourcefile/3dpdr.f90.html"},{"title":"writeoutputs_h5.F90 – 3D-PDR","text":"This file depends on sourcefile~~writeoutputs_h5.f90~~EfferentGraph sourcefile~writeoutputs_h5.f90 writeoutputs_h5.F90 sourcefile~healpix_types.f90 healpix_types.F90 sourcefile~writeoutputs_h5.f90->sourcefile~healpix_types.f90 sourcefile~modules.f90 modules.F90 sourcefile~writeoutputs_h5.f90->sourcefile~modules.f90 sourcefile~definitions.f90 definitions.F90 sourcefile~healpix_types.f90->sourcefile~definitions.f90 sourcefile~modules.f90->sourcefile~healpix_types.f90 sourcefile~modules.f90->sourcefile~definitions.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code subroutine writeoutputs !for ASCII outputs use hdf5 use healpix_types use maincode_module use global_module integer :: error integer ( hid_t ) :: file_id , coolfile_id , heatfile_id , dset_id , dspace_id , x_id , xset_id , av6_id , av6set_id , y_id , yset_id , z_id , zset_id integer ( hid_t ) :: tgas_id , tgasset_id , tdust_id , tdustset_id , etype_id , etypeset_id , rho_id , rhoset_id , uvfield_id , uvfieldset_id integer ( hid_t ) :: abundance_id , abundanceset_id , av_id , avset_id , cool_id , coolset_id , totalcooling_id , totalcoolingset_id , dtype_id integer ( hid_t ) :: heat_id , heatset_id , line_id , lineset_id , linefile_id , spopfile_id , rtspopfile_id , network_id , networkset_id integer ( hid_t ) :: cooarray_id , cooarrayset_id , arrtype_id integer ( hsize_t ), dimension ( 2 ) :: dims_abundance integer ( hsize_t ), dimension ( 2 ) :: dims_av integer ( hsize_t ), dimension ( 2 ) :: dims_cool integer ( hsize_t ), dimension ( 2 ) :: dims_heat integer ( hsize_t ), dimension ( 2 ) :: dims_x integer ( hsize_t ), dimension ( 2 ) :: dims_line integer ( hsize_t ), dimension ( 1 ) :: dims_network integer ( hsize_t ), dimension ( 1 ) :: dims_cooarray real ( kind = dp ), dimension ( pdr_ptot , nspec ) :: abundance_data real ( kind = dp ), dimension ( pdr_ptot , nrays ) :: av_data real ( kind = dp ), dimension ( pdr_ptot , coo ) :: cool_data real ( kind = dp ), dimension ( pdr_ptot , coo ) :: coolant_data real ( kind = dp ), dimension ( pdr_ptot , 12 ) :: heat_data real ( kind = dp ), dimension ( pdr_ptot , 1 ) :: x_data , av6_data , y_data , z_data , tgas_data , tdust_data , rho_data , uvfield_data real ( kind = dp ), dimension ( pdr_ptot , 1 ) :: totalcooling_data real ( kind = dp ), allocatable :: line_data (:,:) integer ( kind = i4b ) , dimension ( pdr_ptot , nspec ) :: etype_data real ( kind = dp ), allocatable :: write_buffer (:) character ( len = 128 ), DIMENSION ( 1 ) :: string_array integer ( 8 ) :: str_size character ( len = 20 ), DIMENSION ( coo ) :: coo_array integer :: num_levels , ilevel , total_levels integer ( 8 ) :: var_size ! real, dimension(3, 3) :: data = reshape([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0], [3, 3]) character ( len = 256 ) :: out_file_h5 character ( len = 128 ) :: network_name integer :: access_flags , offset dims_network ( 1 ) = 1 dims_abundance ( 1 ) = pdr_ptot dims_abundance ( 2 ) = nspec dims_av ( 1 ) = pdr_ptot dims_av ( 2 ) = nrays dims_cool ( 1 ) = pdr_ptot dims_cool ( 2 ) = coo dims_heat ( 1 ) = pdr_ptot dims_heat ( 2 ) = 12 dims_x ( 1 ) = pdr_ptot dims_x ( 2 ) = 1 dims_cooarray ( 1 ) = 1 #ifdef PYWRAP out_file = trim ( adjustl ( output )) // \".pywrap\" out_file2 = trim ( adjustl ( out_file )) // \"]\" write ( 6 , '(\" Writing file [\",A)' ) trim ( adjustl ( out_file2 )) open ( unit = 21 , file = out_file , status = 'replace' ) write ( 21 , '(\"x Av Tgas Tdust nH fuv\")' , advance = 'no' ) do i = 1 , nspec write ( 21 , '(A6)' , advance = 'no' ) trim ( species ( i )) enddo write ( 21 , '(\" dummy1 photoelectric dummy2 Cionization H2formation H2photodis FUVpumping\")' , advance = 'no' ) write ( 21 , '(\" cosmicray turbulent chemical gasgrain totheat \")' , advance = 'no' ) do i = 1 , coo write ( 21 , '(A10)' , advance = 'no' ) trim ( adjustl ( coolant ( i )% cname )) // \"cool\" enddo write ( 21 , '(\" totcool\")' , advance = 'no' ) write ( 21 , * ) '' do p = 1 , pdr_ptot write ( 21 , '(300ES15.7)' ) pdr ( p )% x , pdr ( p )% AV ( 6 ), pdr ( p )% Tgas , pdr ( p )% Tdust , pdr ( p )% rho , pdr ( p )% UVfield ,& & pdr ( p )% abundance , pdr ( p )% heating , pdr ( p )% cooling , pdr ( p )% totalcooling enddo close ( 21 ) #endif !------------------------------------- !OUTPUT FOR CHEMICAL ANALYSIS !------------------------------------- !   do p=1,pdr_ptot !      call analyse_chemistry(p, end_time, pdr(p)%rho, pdr(p)%Tgas, & !        &12, pdr(p)%AV(6), nspec, species,pdr(p)%abundance(1:nspec),nreac, reactant, & !        & product, temp_rate(:,p)) !   enddo !------------------------------------- !OUTPUT FOR PDR PARAMETERS !------------------------------------- out_file = trim ( adjustl ( output )) // \".params\" out_file2 = trim ( adjustl ( out_file )) // \"]\" write ( 6 , '(\" Writing file [\",A)' ) trim ( adjustl ( out_file2 )) open ( unit = 21 , file = out_file , status = 'replace' ) write ( 21 , '(3ES11.3)' ) Gext ( 1 ), zeta * 1.3d-17 , metallicity close ( 21 ) !  Prepare output data do p = 1 , pdr_ptot x_data ( p , :) = pdr ( p )% x av6_data ( p , :) = pdr ( p )% AV ( 6 ) y_data ( p , :) = pdr ( p )% y z_data ( p , :) = pdr ( p )% z tgas_data ( p , :) = pdr ( p )% Tgas tdust_data ( p , :) = pdr ( p )% Tdust etype_data ( p , :) = pdr ( p )% etype rho_data ( p , :) = pdr ( p )% rho uvfield_data ( p , :) = pdr ( p )% UVfield abundance_data ( p , :) = pdr ( p )% abundance av_data ( p , :) = pdr ( p )% AV cool_data ( p , :) = pdr ( p )% cooling totalcooling_data ( p , :) = pdr ( p )% totalcooling heat_data ( p , :) = pdr ( p )% heating enddo call h5open_f ( error ) !------------------------------------- !OUTPUT FOR ABUNDANCES AND TEMPERATURE !------------------------------------- !  out_file = trim(adjustl(output))//\".pdr.fin\" !  out_file2 = trim(adjustl(out_file))//\"]\" !  write(6,'(\" Writing file [\",A)') trim(adjustl(out_file2)) !  open(unit=21,file=out_file,status='replace') out_file_h5 = trim ( adjustl ( output )) // \".pdr.h5\" out_file2 = trim ( adjustl ( out_file_h5 )) // \"]\" write ( 6 , '(\" Writing file [\",A)' ) trim ( adjustl ( out_file2 )) access_flags = H5F_ACC_TRUNC_F call h5fcreate_f ( out_file_h5 , access_flags , file_id , error ) if ( error /= 0 ) stop \"Error creating HDF5 file\" call h5screate_simple_f ( 2 , dims_x , x_id , error ) call h5screate_simple_f ( 2 , dims_x , tgas_id , error ) call h5screate_simple_f ( 2 , dims_x , tdust_id , error ) call h5screate_simple_f ( 2 , dims_x , etype_id , error ) call h5screate_simple_f ( 2 , dims_x , rho_id , error ) call h5screate_simple_f ( 2 , dims_x , uvfield_id , error ) call h5screate_simple_f ( 2 , dims_abundance , abundance_id , error ) !  call h5screate_simple_f(2, dims_simple, dspace_id, error) if ( error /= 0 ) stop \"Error creating data space\" !  call h5dcreate_f(file_id, \"abundance\", H5T_IEEE_F64LE, dspace_id, dset_id, error) call h5dcreate_f ( file_id , \"x\" , H5T_IEEE_F64LE , x_id , xset_id , error ) call h5dcreate_f ( file_id , \"tgas\" , H5T_IEEE_F64LE , tgas_id , tgasset_id , error ) call h5dcreate_f ( file_id , \"tdust\" , H5T_IEEE_F64LE , tdust_id , tdustset_id , error ) call h5dcreate_f ( file_id , \"etype\" , H5T_STD_I32LE , etype_id , etypeset_id , error ) call h5dcreate_f ( file_id , \"rho\" , H5T_IEEE_F64LE , rho_id , rhoset_id , error ) call h5dcreate_f ( file_id , \"uvfield\" , H5T_IEEE_F64LE , uvfield_id , uvfieldset_id , error ) call h5dcreate_f ( file_id , \"abundance\" , H5T_IEEE_F64LE , abundance_id , abundanceset_id , error ) if ( error /= 0 ) stop \"Error creating dataset\" ! do p=1,pdr_ptot #ifdef ONEDIMENSIONAL !  write(21,'(I7,4ES15.7,I5,300ES15.7)') p,pdr(p)%x, pdr(p)%AV(6), pdr(p)%Tgas,pdr(p)%Tdust,pdr(p)%etype,& !  &pdr(p)%rho,pdr(p)%UVfield,pdr(p)%abundance call h5screate_simple_f ( 2 , dims_x , av6_id , error ) call h5dcreate_f ( file_id , \"av6\" , H5T_IEEE_F64LE , av6_id , av6set_id , error ) call h5dwrite_f ( xset_id , H5T_IEEE_F64LE , x_data , dims_x , error ) call h5dwrite_f ( av6set_id , H5T_IEEE_F64LE , av6_data , dims_x , error ) call h5dwrite_f ( tgasset_id , H5T_IEEE_F64LE , tgas_data , dims_x , error ) call h5dwrite_f ( tdustset_id , H5T_IEEE_F64LE , tdust_data , dims_x , error ) call h5dwrite_f ( etypeset_id , H5T_STD_I32LE , etype_data , dims_x , error ) call h5dwrite_f ( rhoset_id , H5T_IEEE_F64LE , rho_data , dims_x , error ) call h5dwrite_f ( uvfieldset_id , H5T_IEEE_F64LE , uvfield_data , dims_x , error ) call h5dwrite_f ( abundanceset_id , H5T_IEEE_F64LE , abundance_data , dims_abundance , error ) call h5dclose_f ( av6set_id , error ) #else !  write(21,'(I7,5ES15.7,I5,300ES15.7)') p,pdr(p)%x, pdr(p)%y, pdr(p)%z, pdr(p)%Tgas,pdr(p)%Tdust,& !  &pdr(p)%etype,pdr(p)%rho,pdr(p)%UVfield,pdr(p)%abundance,pdr(p)%AV call h5screate_simple_f ( 2 , dims_x , y_id , error ) call h5dcreate_f ( file_id , \"y\" , H5T_IEEE_F64LE , y_id , yset_id , error ) call h5screate_simple_f ( 2 , dims_x , z_id , error ) call h5dcreate_f ( file_id , \"z\" , H5T_IEEE_F64LE , z_id , zset_id , error ) call h5screate_simple_f ( 2 , dims_av , av_id , error ) call h5dcreate_f ( file_id , \"av\" , H5T_IEEE_F64LE , av_id , avset_id , error ) call h5dwrite_f ( xset_id , H5T_IEEE_F64LE , x_data , dims_x , error ) call h5dwrite_f ( yset_id , H5T_IEEE_F64LE , y_data , dims_x , error ) call h5dwrite_f ( zset_id , H5T_IEEE_F64LE , z_data , dims_x , error ) call h5dwrite_f ( tgasset_id , H5T_IEEE_F64LE , tgas_data , dims_x , error ) call h5dwrite_f ( tdustset_id , H5T_IEEE_F64LE , tdust_data , dims_x , error ) call h5dwrite_f ( etypeset_id , H5T_STD_I32LE , etype_data , dims_x , error ) call h5dwrite_f ( rhoset_id , H5T_IEEE_F64LE , rho_data , dims_x , error ) call h5dwrite_f ( uvfieldset_id , H5T_IEEE_F64LE , uvfield_data , dims_x , error ) call h5dwrite_f ( abundanceset_id , H5T_IEEE_F64LE , abundance_data , dims_abundance , error ) call h5dwrite_f ( avset_id , H5T_IEEE_F64LE , av_data , dims_av , error ) call h5dclose_f ( yset_id , error ) call h5dclose_f ( zset_id , error ) call h5dclose_f ( avset_id , error ) #endif ! enddo ! call h5dclose_f(dset_id, error) call h5dclose_f ( xset_id , error ) call h5dclose_f ( tgasset_id , error ) call h5dclose_f ( tdustset_id , error ) call h5dclose_f ( etypeset_id , error ) call h5dclose_f ( rhoset_id , error ) call h5dclose_f ( uvfieldset_id , error ) call h5dclose_f ( abundanceset_id , error ) if ( error /= 0 ) stop \"Error closing dataset\" call h5fclose_f ( file_id , error ) if ( error /= 0 ) stop \"Error closing HDF5 file\" print * , \"Data written to HDF5 file successfully!\" ! close(21) !----------------------------------------- !END OUTPUT FOR ABUNDANCES AND TEMPERATURE !----------------------------------------- !--------------------------- !OUTPUT FOR COOLING FUNCTION !--------------------------- !  out_file = trim(adjustl(output))//trim(adjustl(\".cool\"))//\".fin\" !  out_file2 = trim(adjustl(out_file))//\"]\" !  write(6,'(\" Writing file [\",A)') trim(adjustl(out_file2)) !  open(unit=13,file=out_file,status='replace') out_file_h5 = trim ( adjustl ( output )) // trim ( adjustl ( \".cool\" )) // \".h5\" out_file2 = trim ( adjustl ( out_file_h5 )) // \"]\" write ( 6 , '(\" Writing file [\",A)' ) trim ( adjustl ( out_file2 )) access_flags = H5F_ACC_TRUNC_F call h5fcreate_f ( out_file_h5 , access_flags , coolfile_id , error ) if ( error /= 0 ) stop \"Error creating HDF5 file\" call h5screate_simple_f ( 2 , dims_x , x_id , error ) call h5screate_simple_f ( 2 , dims_cool , cool_id , error ) call h5screate_simple_f ( 2 , dims_x , totalcooling_id , error ) call h5dcreate_f ( coolfile_id , \"x\" , H5T_IEEE_F64LE , x_id , xset_id , error ) call h5dcreate_f ( coolfile_id , \"cooling\" , H5T_IEEE_F64LE , cool_id , coolset_id , error ) call h5dcreate_f ( coolfile_id , \"totalcooling\" , H5T_IEEE_F64LE , totalcooling_id , totalcoolingset_id , error ) !  do p=1,pdr_ptot #ifdef ONEDIMENSIONAL ! write(13,'(I7,200ES15.7)') p, pdr(p)%x, pdr(p)%AV(6), pdr(p)%cooling(:),pdr(p)%totalcooling call h5screate_simple_f ( 2 , dims_x , av6_id , error ) call h5dcreate_f ( coolfile_id , \"av6\" , H5T_IEEE_F64LE , av6_id , av6set_id , error ) call h5dwrite_f ( xset_id , H5T_IEEE_F64LE , x_data , dims_x , error ) call h5dwrite_f ( av6set_id , H5T_IEEE_F64LE , av6_data , dims_x , error ) call h5dwrite_f ( coolset_id , H5T_IEEE_F64LE , cool_data , dims_cool , error ) call h5dwrite_f ( totalcoolingset_id , H5T_IEEE_F64LE , totalcooling_data , dims_x , error ) call h5dclose_f ( av6set_id , error ) #else ! write(13,'(I7,200ES15.7)') p, pdr(p)%x, pdr(p)%y, pdr(p)%z, pdr(p)%cooling(:),pdr(p)%totalcooling, pdr(p)%AV(:) call h5screate_simple_f ( 2 , dims_x , y_id , error ) call h5screate_simple_f ( 2 , dims_x , z_id , error ) call h5screate_simple_f ( 2 , dims_av , av_id , error ) call h5dcreate_f ( coolfile_id , \"y\" , H5T_IEEE_F64LE , y_id , yset_id , error ) call h5dcreate_f ( coolfile_id , \"z\" , H5T_IEEE_F64LE , z_id , zset_id , error ) call h5dcreate_f ( coolfile_id , \"av\" , H5T_IEEE_F64LE , av_id , avset_id , error ) call h5dwrite_f ( xset_id , H5T_IEEE_F64LE , x_data , dims_x , error ) call h5dwrite_f ( yset_id , H5T_IEEE_F64LE , y_data , dims_x , error ) call h5dwrite_f ( zset_id , H5T_IEEE_F64LE , z_data , dims_x , error ) call h5dwrite_f ( coolset_id , H5T_IEEE_F64LE , cool_data , dims_cool , error ) call h5dwrite_f ( totalcoolingset_id , H5T_IEEE_F64LE , totalcooling_data , dims_x , error ) call h5dwrite_f ( avset_id , H5T_IEEE_F64LE , av_data , dims_av , error ) call h5dclose_f ( yset_id , error ) call h5dclose_f ( zset_id , error ) call h5dclose_f ( avset_id , error ) #endif !  enddo call h5dclose_f ( xset_id , error ) call h5dclose_f ( coolset_id , error ) call h5dclose_f ( totalcoolingset_id , error ) call h5fclose_f ( coolfile_id , error ) !------------------------------- !END OUTPUT FOR COOLING FUNCTION !------------------------------- !--------------------------- !OUTPUT FOR HEATING FUNCTION !--------------------------- !  out_file = trim(adjustl(output))//trim(adjustl(\".heat\"))//\".fin\" !  out_file2 = trim(adjustl(out_file))//\"]\" !  write(6,'(\" Writing file [\",A)') trim(adjustl(out_file2)) !  open(unit=14,file=out_file,status='replace') out_file_h5 = trim ( adjustl ( output )) // trim ( adjustl ( \".heat\" )) // \".h5\" out_file2 = trim ( adjustl ( out_file_h5 )) // \"]\" write ( 6 , '(\" Writing file [\",A)' ) trim ( adjustl ( out_file2 )) access_flags = H5F_ACC_TRUNC_F call h5fcreate_f ( out_file_h5 , access_flags , heatfile_id , error ) if ( error /= 0 ) stop \"Error creating HDF5 file\" call h5screate_simple_f ( 2 , dims_x , x_id , error ) call h5screate_simple_f ( 2 , dims_heat , heat_id , error ) call h5dcreate_f ( heatfile_id , \"x\" , H5T_IEEE_F64LE , x_id , xset_id , error ) call h5dcreate_f ( heatfile_id , \"heating\" , H5T_IEEE_F64LE , heat_id , heatset_id , error ) !  do p=1,pdr_ptot #ifdef ONEDIMENSIONAL ! write(14,'(I7,200ES15.7)') p, pdr(p)%x, pdr(p)%AV(6), pdr(p)%heating call h5screate_simple_f ( 2 , dims_x , av6_id , error ) call h5dcreate_f ( heatfile_id , \"av6\" , H5T_IEEE_F64LE , av6_id , av6set_id , error ) call h5dwrite_f ( xset_id , H5T_IEEE_F64LE , x_data , dims_x , error ) call h5dwrite_f ( av6set_id , H5T_IEEE_F64LE , av6_data , dims_x , error ) call h5dwrite_f ( heatset_id , H5T_IEEE_F64LE , heat_data , dims_heat , error ) call h5dclose_f ( av6set_id , error ) #else ! write(14,'(I7,200ES15.7)') p, pdr(p)%x, pdr(p)%y, pdr(p)%z, pdr(p)%heating, pdr(p)%AV call h5screate_simple_f ( 2 , dims_x , y_id , error ) call h5screate_simple_f ( 2 , dims_x , z_id , error ) call h5screate_simple_f ( 2 , dims_av , av_id , error ) call h5dcreate_f ( heatfile_id , \"y\" , H5T_IEEE_F64LE , y_id , yset_id , error ) call h5dcreate_f ( heatfile_id , \"z\" , H5T_IEEE_F64LE , z_id , zset_id , error ) call h5dcreate_f ( heatfile_id , \"av\" , H5T_IEEE_F64LE , av_id , avset_id , error ) call h5dwrite_f ( xset_id , H5T_IEEE_F64LE , x_data , dims_x , error ) call h5dwrite_f ( yset_id , H5T_IEEE_F64LE , y_data , dims_x , error ) call h5dwrite_f ( zset_id , H5T_IEEE_F64LE , z_data , dims_x , error ) call h5dwrite_f ( heatset_id , H5T_IEEE_F64LE , heat_data , dims_heat , error ) call h5dwrite_f ( avset_id , H5T_IEEE_F64LE , av_data , dims_av , error ) call h5dclose_f ( yset_id , error ) call h5dclose_f ( zset_id , error ) call h5dclose_f ( avset_id , error ) #endif !  enddo !  close(14) call h5dclose_f ( xset_id , error ) call h5dclose_f ( heatset_id , error ) call h5fclose_f ( heatfile_id , error ) !------------------------------- !END OUTPUT FOR HEATING FUNCTION !------------------------------- #ifdef ONEDIMENSIONAL !----------------------- !OUTPUT FOR EMISSIVITIES !----------------------- do k = 1 , coo !  out_file = trim(adjustl(output))//\".\"//trim(adjustl(coolant(k)%cname))//trim(adjustl(\".line\"))//\".fin\" !  out_file2 = trim(adjustl(out_file))//\"]\" !  write(6,'(\" Writing file [\",A)') trim(adjustl(out_file2)) !  open(unit=16,file=out_file,status='replace') out_file_h5 = trim ( adjustl ( output )) // \".\" // trim ( adjustl ( coolant ( k )% cname )) // trim ( adjustl ( \".line\" )) // \".h5\" out_file2 = trim ( adjustl ( out_file_h5 )) // \"]\" write ( 6 , '(\" Writing file [\",A)' ) trim ( adjustl ( out_file2 )) access_flags = H5F_ACC_TRUNC_F call h5fcreate_f ( out_file_h5 , access_flags , linefile_id , error ) dims_line ( 1 ) = pdr_ptot dims_line ( 2 ) = coolant ( k )% cnlev - 1 if ( error /= 0 ) stop \"Error creating HDF5 file\" call h5screate_simple_f ( 2 , dims_x , x_id , error ) call h5screate_simple_f ( 2 , dims_x , av6_id , error ) call h5screate_simple_f ( 2 , dims_line , line_id , error ) call h5dcreate_f ( linefile_id , \"x\" , H5T_IEEE_F64LE , x_id , xset_id , error ) call h5dcreate_f ( linefile_id , \"av6\" , H5T_IEEE_F64LE , av6_id , av6set_id , error ) call h5dcreate_f ( linefile_id , \"line\" , H5T_IEEE_F64LE , line_id , lineset_id , error ) num_levels = coolant ( k )% cnlev - 1 allocate ( line_data ( pdr_ptot , num_levels )) allocate ( write_buffer ( num_levels )) do p = 1 , pdr_ptot do ilevel = 1 , num_levels IF ( pdr ( p )% coolant ( k )% line ( ilevel + 1 , ilevel ) . LT . 1 D - 99 ) THEN pdr ( p )% coolant ( k )% line ( ilevel + 1 , ilevel ) = 0.0D0 endif write_buffer ( ilevel ) = pdr ( p )% coolant ( k )% line ( ilevel + 1 , ilevel ) end do line_data ( p , :) = write_buffer end do call h5dwrite_f ( xset_id , H5T_IEEE_F64LE , x_data , dims_x , error ) call h5dwrite_f ( av6set_id , H5T_IEEE_F64LE , av6_data , dims_x , error ) call h5dwrite_f ( lineset_id , H5T_IEEE_F64LE , line_data , dims_line , error ) call h5dclose_f ( xset_id , error ) call h5dclose_f ( av6set_id , error ) call h5dclose_f ( lineset_id , error ) deallocate ( write_buffer ) deallocate ( line_data ) !experimental [1D models only] !  do p = 1, pdr_ptot !   num_levels = coolant(k)%cnlev - 1 !   allocate(write_buffer(num_levels)) !   do ilevel = 1, num_levels !    IF (pdr(p)%coolant(k)%line(ilevel+1, ilevel) .LT. 1D-99) THEN !      pdr(p)%coolant(k)%line(ilevel+1, ilevel) = 0.0D0 !    endif !      write_buffer(ilevel) = pdr(p)%coolant(k)%line(ilevel+1, ilevel) !   end do !   write(16, '(I5, 1X, ES15.7, 1X, ES15.7, 1X)', advance='no') p,pdr(p)%x, pdr(p)%AV(6) !   write(16, '(100ES15.7)') write_buffer !   deallocate(write_buffer) ! write(16, *) !    write(16, '(I5, 1X, ES15.7, 1X, ES15.7, 1X)', advance='no') p,pdr(p)%x, pdr(p)%AV(6) !    do ilevel=1,coolant(k)%cnlev-1 !      if (pdr(p)%coolant(k)%line(ilevel+1,ilevel).lt.1d-99) pdr(p)%coolant(k)%line(ilevel+1,ilevel)=0.0D0 !      write(16, '(100ES15.7)', advance='no') pdr(p)%coolant(k)%line(ilevel+1,ilevel) !    end do !    write(16, *) end do !  close(16) ! close(16) !  enddo !--------------------------- !END OUTPUT FOR EMISSIVITIES !--------------------------- !---------------------------- !OUTPUT FOR LEVEL POPULATIONS !---------------------------- do k = 1 , coo !  out_file = trim(adjustl(output))//\".\"//trim(adjustl(coolant(k)%cname))//trim(adjustl(\".spop\"))//\".fin\" !  out_file2 = trim(adjustl(out_file))//\"]\" !  write(6,'(\" Writing file [\",A)') trim(adjustl(out_file2)) !  open(unit=16,file=out_file,status='replace') out_file_h5 = trim ( adjustl ( output )) // \".\" // trim ( adjustl ( coolant ( k )% cname )) // trim ( adjustl ( \".spop\" )) // \".h5\" out_file2 = trim ( adjustl ( out_file_h5 )) // \"]\" write ( 6 , '(\" Writing file [\",A)' ) trim ( adjustl ( out_file2 )) access_flags = H5F_ACC_TRUNC_F call h5fcreate_f ( out_file_h5 , access_flags , spopfile_id , error ) dims_line ( 1 ) = pdr_ptot dims_line ( 2 ) = coolant ( k )% cnlev if ( error /= 0 ) stop \"Error creating HDF5 file\" call h5screate_simple_f ( 2 , dims_x , x_id , error ) call h5screate_simple_f ( 2 , dims_x , av6_id , error ) call h5screate_simple_f ( 2 , dims_line , line_id , error ) call h5dcreate_f ( spopfile_id , \"x\" , H5T_IEEE_F64LE , x_id , xset_id , error ) call h5dcreate_f ( spopfile_id , \"av6\" , H5T_IEEE_F64LE , av6_id , av6set_id , error ) call h5dcreate_f ( spopfile_id , \"spop\" , H5T_IEEE_F64LE , line_id , lineset_id , error ) num_levels = coolant ( k )% cnlev allocate ( line_data ( pdr_ptot , num_levels )) !experimental [1D models only] do p = 1 , pdr_ptot !  write(16, '(I5, 1X, ES15.7, 1X, ES15.7, 1X)', advance='no') p,pdr(p)%x, pdr(p)%AV(6) do ilevel = 1 , coolant ( k )% cnlev if ( pdr ( p )% coolant ( k )% pop ( ilevel ). lt . 1 d - 99 ) pdr ( p )% coolant ( k )% pop ( ilevel ) = 0.0D0 end do !  write(16, '(100ES15.7)', advance='no') pdr(p)%coolant(k)%pop !  write(16, *) line_data ( p , :) = pdr ( p )% coolant ( k )% pop end do !  close(16) call h5dwrite_f ( xset_id , H5T_IEEE_F64LE , x_data , dims_x , error ) call h5dwrite_f ( av6set_id , H5T_IEEE_F64LE , av6_data , dims_x , error ) call h5dwrite_f ( lineset_id , H5T_IEEE_F64LE , line_data , dims_line , error ) call h5dclose_f ( xset_id , error ) call h5dclose_f ( av6set_id , error ) call h5dclose_f ( lineset_id , error ) deallocate ( line_data ) enddo !-------------------------------- !END OUTPUT FOR LEVEL POPULATIONS !-------------------------------- #endif !---------------------------- !OUTPUT FOR RTtool !---------------------------- !  out_file = trim(adjustl(output))//trim(adjustl(\".RTspop\"))//\".fin\" !  out_file2 = trim(adjustl(out_file))//\"]\" !  write(6,'(\" Writing file [\",A)') trim(adjustl(out_file2)) !  open(unit=16,file=out_file,status='replace') out_file_h5 = trim ( adjustl ( output )) // trim ( adjustl ( \".RTspop\" )) // \".h5\" out_file2 = trim ( adjustl ( out_file_h5 )) // \"]\" write ( 6 , '(\" Writing file [\",A)' ) trim ( adjustl ( out_file2 )) access_flags = H5F_ACC_TRUNC_F call h5fcreate_f ( out_file_h5 , access_flags , rtspopfile_id , error ) #ifdef REDUCED !  write(16,*) 'REDUCED' network_name = 'REDUCED' #endif #ifdef MEDIUM !  write(16,*) 'MEDIUM' network_name = 'MEDIUM' #endif #ifdef FULL !  write(16,*) 'FULL' network_name = 'FULL' #endif do k = 1 , coo !  write(16,*) coolfile(k) coo_array ( k ) = coolfile ( k ) enddo write ( 16 , * ) 'ENDCOOLFILES' string_array ( 1 ) = adjustl ( network_name ) call h5screate_simple_f ( 1 , dims_network , network_id , error ) call h5screate_simple_f ( 1 , dims_cooarray , cooarray_id , error ) call h5tcopy_f ( H5T_C_S1 , dtype_id , error ) call h5tcopy_f ( H5T_C_S1 , arrtype_id , error ) str_size = 32 call h5tset_size_f ( dtype_id , str_size , error ) call h5tset_size_f ( arrtype_id , str_size * coo , error ) call h5dcreate_f ( rtspopfile_id , \"network\" , dtype_id , network_id , networkset_id , error ) call h5dcreate_f ( rtspopfile_id , \"coolfiles\" , arrtype_id , cooarray_id , cooarrayset_id , error ) call h5dwrite_f ( networkset_id , dtype_id , string_array , dims_network , error ) call h5dwrite_f ( cooarrayset_id , arrtype_id , coo_array , dims_cooarray , error ) call h5dclose_f ( cooarrayset_id , error ) call h5dclose_f ( networkset_id , error ) total_levels = 0 do k = 1 , coo total_levels = total_levels + coolant ( k )% cnlev end do allocate ( line_data ( pdr_ptot , coo * total_levels )) line_data = 0.0D0 do p = 1 , pdr_ptot offset = 0 do k = 1 , coo do ilevel = 1 , coolant ( k )% cnlev if ( pdr ( p )% coolant ( k )% pop ( ilevel ). lt . 1 d - 99 ) pdr ( p )% coolant ( k )% pop ( ilevel ) = 0.0D0 end do line_data ( p , offset + 1 : offset + coolant ( k )% cnlev ) = pdr ( p )% coolant ( k )% pop ( 1 : coolant ( k )% cnlev ) offset = offset + coolant ( k )% cnlev end do !  do k = 1, coo !    write(16, '(100ES15.7)', advance='no') pdr(p)%coolant(k)%pop(1:coolant(k)%cnlev) !  end do !  write(16, *) end do dims_line ( 1 ) = pdr_ptot dims_line ( 2 ) = total_levels call h5screate_simple_f ( 2 , dims_line , line_id , error ) call h5dcreate_f ( rtspopfile_id , \"allpop\" , H5T_IEEE_F64LE , line_id , lineset_id , error ) call h5dwrite_f ( lineset_id , H5T_IEEE_F64LE , line_data , dims_line , error ) call h5dclose_f ( lineset_id , error ) deallocate ( line_data ) !  close(16) !-------------------------------- !END OUTPUT FOR LEVEL POPULATIONS !-------------------------------- return end subroutine","tags":"","url":"sourcefile/writeoutputs_h5.f90.html"},{"title":"m_writeoutputs.F90 – 3D-PDR","text":"This file depends on sourcefile~~m_writeoutputs.f90~~EfferentGraph sourcefile~m_writeoutputs.f90 m_writeoutputs.F90 sourcefile~m_paramters.f90 m_paramters.F90 sourcefile~m_writeoutputs.f90->sourcefile~m_paramters.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~m_writeoutputs.f90~~AfferentGraph sourcefile~m_writeoutputs.f90 m_writeoutputs.F90 sourcefile~convert_fin2h5.f90 convert_fin2h5.F90 sourcefile~convert_fin2h5.f90->sourcefile~m_writeoutputs.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module m_writeoutputs use hdf5 use m_paramters implicit none integer :: h5err integer :: coords ( 3 ) character ( len = 256 ) :: fin_file , out_file_h5 integer ( HID_T ) :: file_id , filespace , filespace2 , filespace3 integer ( HID_T ) :: dset_id_network , dset_id_cooarray , dset_id_allpop , dtype_id , arrtype_id integer ( HSIZE_T ), dimension ( 3 ) :: dims integer ( HSIZE_T ), dimension ( 4 ) :: dims3 real ( RK ), allocatable :: temp_real (:,:,:) contains subroutine writeoutputs implicit none !locals integer :: i , j , k , isp , ipix , ico , ilevel , offset , file_unit integer :: access_flags real ( RK ), allocatable :: allpop (:,:,:,:) integer ( hsize_t ), dimension ( 1 ) :: dims_network , dims_cooarray character ( len = 128 ) :: network_name character ( len = 128 ), allocatable :: coo_array (:) character ( len = 128 ), DIMENSION ( 1 ) :: string_array character ( len = 128 ) :: file_name , file_index integer :: total_levels integer ( 8 ) :: str_size logical :: file_exists dims = ( / nxc , nyc , nzc / ) allocate ( temp_real ( nxc , nyc , nzc )) call h5open_f ( h5err ) !------------------------------------- !outname FOR ABUNDANCES AND TEMPERATURE !------------------------------------- fin_file = \"../\" // trim ( adjustl ( outname )) // \".pdr.fin\" out_file_h5 = trim ( adjustl ( outname )) // \".pdr.h5\" inquire ( file = trim ( fin_file ), exist = file_exists ) if ( file_exists ) then access_flags = H5F_ACC_TRUNC_F call h5fcreate_f ( out_file_h5 , access_flags , file_id , h5err ) call write_h5_one_r3d ( file_id , dims , pdr % x , \"x\" ) call write_h5_one_r3d ( file_id , dims , pdr % y , \"y\" ) call write_h5_one_r3d ( file_id , dims , pdr % z , \"z\" ) call write_h5_one_r3d ( file_id , dims , pdr % Tgas , \"tgas\" ) call write_h5_one_r3d ( file_id , dims , pdr % Tdust , \"tdust\" ) call write_h5_one_r3d ( file_id , dims , DBLE ( pdr % etype ), \"etype\" ) call write_h5_one_r3d ( file_id , dims , pdr % rho , \"rho\" ) call write_h5_one_r3d ( file_id , dims , pdr % UVfield , \"uv\" ) do isp = 1 , nspec write ( file_index , '(I3.3)' ) isp file_name = \"abundance\" // trim ( adjustl ( file_index )) do k = 1 , nzc do j = 1 , nyc do i = 1 , nxc temp_real ( i , j , k ) = pdr ( i , j , k )% abundance ( isp ) enddo enddo enddo call write_h5_one_r3d ( file_id , dims , temp_real , file_name ) enddo do ipix = 0 , nrays - 1 write ( file_index , '(I3.3)' ) ipix file_name = \"av\" // trim ( adjustl ( file_index )) do k = 1 , nzc do j = 1 , nyc do i = 1 , nxc temp_real ( i , j , k ) = pdr ( i , j , k )% AV ( ipix ) enddo enddo enddo call write_h5_one_r3d ( file_id , dims , temp_real , file_name ) enddo call h5fclose_f ( file_id , h5err ) endif !----------------------------------------- !END outname FOR ABUNDANCES AND TEMPERATURE !----------------------------------------- !------------------------- !outname FOR LOCAL CR VALUE !------------------------- fin_file = \"../\" // trim ( adjustl ( outname )) // \".cr.fin\" out_file_h5 = trim ( adjustl ( outname )) // \".cr.h5\" inquire ( file = trim ( fin_file ), exist = file_exists ) if ( file_exists ) then access_flags = H5F_ACC_TRUNC_F call h5fcreate_f ( out_file_h5 , access_flags , file_id , h5err ) call write_h5_one_r3d ( file_id , dims , pdr % zetalocal , \"zetalocal\" ) call h5fclose_f ( file_id , h5err ) endif !----------------------------- !END outname FOR LOCAL CR VALUE !----------------------------- !--------------------------- !outname FOR COOLING FUNCTION !--------------------------- fin_file = \"../\" // trim ( adjustl ( outname )) // trim ( adjustl ( \".cool\" )) // \".fin\" out_file_h5 = trim ( adjustl ( outname )) // \".cool.h5\" inquire ( file = trim ( fin_file ), exist = file_exists ) if ( file_exists ) then access_flags = H5F_ACC_TRUNC_F call h5fcreate_f ( out_file_h5 , access_flags , file_id , h5err ) do ico = 1 , coo write ( file_index , '(I3.3)' ) ico file_name = \"cool\" // trim ( adjustl ( file_index )) do k = 1 , nzc do j = 1 , nyc do i = 1 , nxc temp_real ( i , j , k ) = pdr ( i , j , k )% cooling ( ico ) enddo enddo enddo call write_h5_one_r3d ( file_id , dims , temp_real , file_name ) enddo call write_h5_one_r3d ( file_id , dims , pdr % totalcooling , \"totalcool\" ) call h5fclose_f ( file_id , h5err ) endif !------------------------------- !END outname FOR COOLING FUNCTION !------------------------------- !--------------------------- !outname FOR HEATING FUNCTION !--------------------------- fin_file = \"../\" // trim ( adjustl ( outname )) // trim ( adjustl ( \".heat\" )) // \".fin\" out_file_h5 = trim ( adjustl ( outname )) // \".heat.h5\" inquire ( file = trim ( fin_file ), exist = file_exists ) if ( file_exists ) then access_flags = H5F_ACC_TRUNC_F call h5fcreate_f ( out_file_h5 , access_flags , file_id , h5err ) do ico = 1 , 12 write ( file_index , '(I3.3)' ) ico file_name = \"heat\" // trim ( adjustl ( file_index )) do k = 1 , nzc do j = 1 , nyc do i = 1 , nxc temp_real ( i , j , k ) = pdr ( i , j , k )% heating ( ico ) enddo enddo enddo call write_h5_one_r3d ( file_id , dims , temp_real , file_name ) enddo call h5fclose_f ( file_id , h5err ) endif !------------------------------- !END outname FOR HEATING FUNCTION !------------------------------- !---------------------------- !outname FOR RTtool !---------------------------- fin_file = \"../\" // trim ( adjustl ( outname )) // trim ( adjustl ( \".RTspop\" )) // \".fin\" out_file_h5 = trim ( adjustl ( outname )) // trim ( adjustl ( \".RTspop\" )) // \".h5\" inquire ( file = trim ( fin_file ), exist = file_exists ) if ( file_exists ) then access_flags = H5F_ACC_TRUNC_F call h5fcreate_f ( out_file_h5 , access_flags , file_id , h5err ) allocate ( coo_array ( coo )) network_name = coolfile ( 1 ) string_array ( 1 ) = adjustl ( network_name ) do ico = 1 , coo coo_array ( ico ) = adjustl ( coolfile ( ico + 1 )) enddo total_levels = 0 do k = 1 , coo total_levels = total_levels + cnlev ( k ) end do allocate ( allpop ( nxc , nyc , nzc , total_levels )) do k = 1 , nzc do j = 1 , nyc do i = 1 , nxc offset = 0 do ico = 1 , coo do ilevel = 1 , cnlev ( ico ) if ( pdr ( i , j , k )% coolant ( ico )% pop ( ilevel ). lt . 1 d - 99 ) pdr ( i , j , k )% coolant ( ico )% pop ( ilevel ) = 0.0D0 end do allpop ( i , j , k , offset + 1 : offset + cnlev ( ico )) = pdr ( i , j , k )% coolant ( ico )% pop ( 1 : cnlev ( ico )) offset = offset + cnlev ( ico ) end do enddo enddo enddo dims_network ( 1 ) = 1 dims_cooarray ( 1 ) = coo dims3 = ( / nxc , nyc , nzc , total_levels / ) call h5screate_simple_f ( 4 , dims3 , filespace , h5err ) call h5screate_simple_f ( 1 , dims_network , filespace2 , h5err ) call h5screate_simple_f ( 1 , dims_cooarray , filespace3 , h5err ) call h5tcopy_f ( H5T_C_S1 , dtype_id , h5err ) call h5tcopy_f ( H5T_C_S1 , arrtype_id , h5err ) str_size = 128 call h5tset_size_f ( dtype_id , str_size , h5err ) call h5tset_size_f ( arrtype_id , str_size , h5err ) call h5dcreate_f ( file_id , \"network\" , dtype_id , filespace2 , dset_id_network , h5err ) call h5dcreate_f ( file_id , \"coolfiles\" , arrtype_id , filespace3 , dset_id_cooarray , h5err ) call h5dcreate_f ( file_id , \"allpop\" , H5T_IEEE_F64LE , filespace , dset_id_allpop , h5err ) call h5dwrite_f ( dset_id_network , dtype_id , string_array , dims_network , h5err ) call h5dwrite_f ( dset_id_cooarray , arrtype_id , coo_array , dims_cooarray , h5err ) call h5dwrite_f ( dset_id_allpop , H5T_IEEE_F64LE , allpop , dims3 , h5err ) call h5sclose_f ( filespace , h5err ) call h5sclose_f ( filespace2 , h5err ) call h5sclose_f ( filespace3 , h5err ) call h5dclose_f ( dset_id_network , h5err ) call h5dclose_f ( dset_id_cooarray , h5err ) call h5dclose_f ( dset_id_allpop , h5err ) call h5fclose_f ( file_id , h5err ) deallocate ( allpop ) endif !-------------------------------- !END outname FOR LEVEL POPULATIONS !-------------------------------- !--------------------------- !outname FOR VELOCITY !--------------------------- fin_file = \"../\" // trim ( adjustl ( outname )) // trim ( adjustl ( \".velocity\" )) // \".dat\" out_file_h5 = trim ( adjustl ( outname )) // \".velocity.h5\" inquire ( file = trim ( fin_file ), exist = file_exists ) if ( file_exists ) then access_flags = H5F_ACC_TRUNC_F call h5fcreate_f ( out_file_h5 , access_flags , file_id , h5err ) call write_h5_one_r3d ( file_id , dims , pdr % vx , \"vx\" ) call write_h5_one_r3d ( file_id , dims , pdr % vy , \"vy\" ) call write_h5_one_r3d ( file_id , dims , pdr % vz , \"vz\" ) call h5fclose_f ( file_id , h5err ) endif !-------------------------------- !END outname FOR VELOCITY !-------------------------------- deallocate ( temp_real ) call h5close_f ( h5err ) end subroutine writeoutputs subroutine write_h5_one_r3d ( file_id , dims , temp_real , name ) implicit none integer ( HID_T ), intent ( in ) :: file_id integer ( HSIZE_T ), dimension ( 3 ), intent ( in ) :: dims real ( RK ), intent ( in ) :: temp_real (:,:,:) character ( len =* ), intent ( in ) :: name !locals integer ( HID_T ) :: filespace , dset_id integer :: h5err call h5screate_simple_f ( 3 , dims , filespace , h5err ) call h5dcreate_f ( file_id , trim ( name ), H5T_IEEE_F64LE , filespace , dset_id , h5err ) call h5dwrite_f ( dset_id , H5T_IEEE_F64LE , temp_real , dims , h5err ) if ( h5err /= 0 ) print * , \"h5dwrite_f failed with error:\" , name , h5err call h5sclose_f ( filespace , h5err ) call h5dclose_f ( dset_id , h5err ) end subroutine write_h5_one_r3d end module m_writeoutputs","tags":"","url":"sourcefile/m_writeoutputs.f90.html"},{"title":"m_paramters.F90 – 3D-PDR","text":"Files dependent on this one sourcefile~~m_paramters.f90~~AfferentGraph sourcefile~m_paramters.f90 m_paramters.F90 sourcefile~convert_fin2h5.f90 convert_fin2h5.F90 sourcefile~convert_fin2h5.f90->sourcefile~m_paramters.f90 sourcefile~m_visual.f90 m_visual.F90 sourcefile~convert_fin2h5.f90->sourcefile~m_visual.f90 sourcefile~m_writeoutputs.f90 m_writeoutputs.F90 sourcefile~convert_fin2h5.f90->sourcefile~m_writeoutputs.f90 sourcefile~m_visual.f90->sourcefile~m_paramters.f90 sourcefile~m_writeoutputs.f90->sourcefile~m_paramters.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module m_paramters implicit none integer , parameter :: RK = KIND ( 0.D0 ) integer , parameter :: coo = 4 integer , parameter :: nspec = 33 integer , parameter :: nrays = 12 integer , parameter , dimension ( coo ) :: cnlev = [ 41 , 5 , 5 , 5 ] integer , parameter :: nxc = 32 , nyc = 32 , nzc = 32 real ( RK ), parameter :: xlx = 3.94156170 , yly = 3.93756294 , zlz = 3.93856335 character ( len = 50 ), parameter :: outname = 'test' real ( RK ) :: dx , dy , dz character ( len = 20 ) :: cfile , coolfile ( 1 : 10 ) type pdr_excit real ( RK ), pointer :: pop (:) end type pdr_excit type pdr_node integer :: etype real ( RK ) :: x , y , z , vx , vy , vz , Tgas , Tdust , rho , UVfield , totalcooling real ( RK ), pointer :: AV (:) real ( RK ), pointer :: abundance (:) real ( RK ), pointer :: cooling (:) real ( RK ), pointer :: heating (:) type ( pdr_excit ), allocatable :: coolant (:) real ( RK ) :: zetalocal end type pdr_node type ( pdr_node ), allocatable :: pdr (:,:,:) end module m_paramters","tags":"","url":"sourcefile/m_paramters.f90.html"},{"title":"modules.F90 – 3D-PDR","text":"This file depends on sourcefile~~modules.f90~~EfferentGraph sourcefile~modules.f90 modules.F90 sourcefile~definitions.f90 definitions.F90 sourcefile~modules.f90->sourcefile~definitions.f90 sourcefile~healpix_types.f90 healpix_types.F90 sourcefile~modules.f90->sourcefile~healpix_types.f90 sourcefile~healpix_types.f90->sourcefile~definitions.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~modules.f90~~AfferentGraph sourcefile~modules.f90 modules.F90 sourcefile~3dpdr.f90 3DPDR.F90 sourcefile~3dpdr.f90->sourcefile~modules.f90 sourcefile~allocations.f90 allocations.F90 sourcefile~allocations.f90->sourcefile~modules.f90 sourcefile~analyse_chem.f90 analyse_chem.F90 sourcefile~analyse_chem.f90->sourcefile~modules.f90 sourcefile~calc_reac_rates.f90 calc_reac_rates.F90 sourcefile~calc_reac_rates.f90->sourcefile~modules.f90 sourcefile~changetemperature.f90 changetemperature.F90 sourcefile~changetemperature.f90->sourcefile~modules.f90 sourcefile~checkconvergence.f90 checkconvergence.F90 sourcefile~checkconvergence.f90->sourcefile~modules.f90 sourcefile~chemicaliterations.f90 chemicaliterations.F90 sourcefile~chemicaliterations.f90->sourcefile~modules.f90 sourcefile~columndensity.f90 columndensity.F90 sourcefile~columndensity.f90->sourcefile~modules.f90 sourcefile~coolingfunctions.f90 coolingfunctions.F90 sourcefile~coolingfunctions.f90->sourcefile~modules.f90 sourcefile~crattenuation.f90 CRattenuation.F90 sourcefile~crattenuation.f90->sourcefile~modules.f90 sourcefile~dust_t.f90 dust_t.F90 sourcefile~dust_t.f90->sourcefile~modules.f90 sourcefile~escape_probability.f90 escape_probability.F90 sourcefile~escape_probability.f90->sourcefile~modules.f90 sourcefile~eval_points.f90 eval_points.F90 sourcefile~eval_points.f90->sourcefile~modules.f90 sourcefile~h2_form.f90 h2_form.F90 sourcefile~h2_form.f90->sourcefile~modules.f90 sourcefile~healpix.f90 healpix.F90 sourcefile~healpix.f90->sourcefile~modules.f90 sourcefile~initialization.f90 initialization.F90 sourcefile~initialization.f90->sourcefile~modules.f90 sourcefile~input_parameters.f90 input_parameters.F90 sourcefile~input_parameters.f90->sourcefile~modules.f90 sourcefile~m_ioandvisu.f90 m_IOAndVisu.F90 sourcefile~m_ioandvisu.f90->sourcefile~modules.f90 sourcefile~m_ray_box.f90~2 m_Ray_box.F90 sourcefile~m_ray_box.f90~2->sourcefile~modules.f90 sourcefile~read_command_line.f90 read_command_line.F90 sourcefile~read_command_line.f90->sourcefile~modules.f90 sourcefile~read_coolants.f90 read_coolants.F90 sourcefile~read_coolants.f90->sourcefile~modules.f90 sourcefile~read_rates.f90 read_rates.F90 sourcefile~read_rates.f90->sourcefile~modules.f90 sourcefile~read_species.f90 read_species.F90 sourcefile~read_species.f90->sourcefile~modules.f90 sourcefile~readdensity.f90 readdensity.F90 sourcefile~readdensity.f90->sourcefile~modules.f90 sourcefile~shield.f90 shield.F90 sourcefile~shield.f90->sourcefile~modules.f90 sourcefile~solvlevpop.f90 solvlevpop.F90 sourcefile~solvlevpop.f90->sourcefile~modules.f90 sourcefile~uvfield.f90 UVfield.F90 sourcefile~uvfield.f90->sourcefile~modules.f90 sourcefile~writeoutputs.f90 writeoutputs.F90 sourcefile~writeoutputs.f90->sourcefile~modules.f90 sourcefile~writeoutputs_h5.f90 writeoutputs_h5.F90 sourcefile~writeoutputs_h5.f90->sourcefile~modules.f90 sourcefile~writeparams.f90 writeparams.F90 sourcefile~writeparams.f90->sourcefile~modules.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module maincode_local use definitions use healpix_types logical :: write_output integer ( kind = i4b ) :: mmpdr , j , newmaxpoints , ilevel , jlevel real ( kind = dp ), allocatable :: temp_abundance (:,:), temp_density (:) real ( kind = dp ), allocatable :: temp_temperature (:) real ( kind = dp ) :: t1 , t2 integer ( kind = i4b ) :: NRGR , NRH2 , NRHD , NRCO , NRCI , NRSI real ( kind = dp ) :: uvfieldaux !reversing rows declaration real ( kind = dp ), allocatable :: x_rev (:), y_rev (:), z_rev (:), n_rev (:) integer :: pp_debug real :: xp , yp , zp real :: dist , Avis integer :: proj , pproj end module MODULE healpix_module !T.Bisbas use definitions use healpix_types integer ( kind = i4b ) :: ns_max ! .. integer ( kind = i4b ), dimension ( 0 : 1023 ) :: pix2x ! .. integer ( kind = i4b ), dimension ( 0 : 1023 ) :: pix2y ! .. real ( kind = DP ) :: x2pix ( 0 : 1023 ) ! .. real ( kind = DP ) :: y2pix ( 0 : 1023 ) ! .. real ( kind = DP ), allocatable :: vertex (:,:) ! .. real ( kind = DP ), allocatable :: vector (:) ! .. END MODULE healpix_module MODULE maincode_module USE ISO_C_BINDING use definitions use healpix_types integer ( kind = I4B ) :: i ! counter integer :: ii ! counter integer ( kind = I4B ) :: k ! counter integer ( kind = I4B ) :: kk ! counter integer ( kind = I4B ) :: p ! counter integer ( kind = I4B ) :: ipix ! pix id integer ( kind = I4B ) :: level ! current level integer ( kind = I4B ) :: nrays ! no. of rays on current level integer ( kind = I4B ) :: nside ! refer to healpix manual integer ( kind = I4B ) :: itot ! total number of grid points integer ( kind = I4B ) :: ktot ! total number of grid points integer ( kind = I4B ) :: tot_eval ! total number of evaluation points INTEGER ( KIND = I4B ) :: NLEV , NTEMP integer ( kind = i4b ) :: iteration , ITERTOT integer ( kind = i4b ) :: iterstep ! output interval (per how many iterations) integer ( kind = i4b ) :: NSPEC , NREAC integer ( kind = i4b ) :: maxpoints integer ( kind = i4b ) :: suma integer :: CHEMITERATIONS integer :: pdr_tot logical :: writeiterations logical :: SPH #ifdef RESTART logical :: restart character ( len = 100 ) :: restart_file #endif character ( len = 1 ) :: crfieldchoice real ( kind = dp ) :: crattennorm , crattenslope , crattenn0 integer ( kind = I4B ), allocatable :: rb (:) ! ray with the IDs of the input file integer ( kind = I4B ), allocatable :: rrb (:) ! ray with the IDs of the input file integer ( kind = I4B ) :: iwork ( 1 : 1000 ) real ( kind = dp ) :: rwork ( 1 : 1000000 ) character ( len = 50 ) :: indir , outdir real ( kind = dp ) :: ZETA real ( kind = DP ) :: angle_los ! line-of-sight angle real ( kind = dp ) :: radius ! maximum distance from the origin(1:3) real ( kind = dp ) :: theta_crit ! critical theta angle to produce evaluation point real ( kind = DP ) :: rvec ( 1 : 3 ) ! local 3 column array for the x,y,z coordinates of the grid point real ( kind = DP ) :: theta , phi ! used from healpix to convert cartesian -> spherical real ( kind = dp ) :: adaptive_step !adaptive step for calculations of UVfield and column density. real ( kind = dp ) :: rhs1 ! right-hand-side 1 (to make integration calculation simpler) real ( kind = DP ) :: rhs2 ! -ditto- real ( kind = DP ) :: points ! dummy variable used to find itot real ( kind = DP ) :: origin ( 1 : 3 ) ! grid point at which we perform calculation real ( kind = DP ) :: healpixvector ( 1 : 3 ) ! Healpix rays real ( kind = dp ) :: ENERGY , WEIGHT , EINSTEINA , FREQUENCY real ( kind = dp ) :: Tguess real ( kind = dp ) :: n_H real ( kind = dp ) :: Z_increment real ( kind = dp ) :: frac1 , frac2 , frac3 , tau_increment real ( kind = dp ) :: beta_ij_ray , beta_ij_sum , beta_ij real ( kind = dp ) :: TPOP , TMP2 , BB_ij real ( kind = dp ) :: relch , v_turb , v_turb_inp real ( kind = dp ) :: Tlow0 real ( kind = dp ) :: Thigh0 real ( kind = dp ) :: Tmin real ( kind = dp ) :: Tmax real ( kind = dp ) :: Fcrit real ( kind = dp ) :: Tdiff real ( kind = dp ) :: dust_temperature real ( kind = dp ) :: avmax !  character(len=3) :: fieldchoice real ( kind = dp ) :: Gext ( 1 : 3 ) character ( len = 2 ) :: UVdirchoice real ( kind = sp ) :: user_UVAngle ( 2 ) real ( kind = sp ) :: UVdir ( 1 : 3 ) real ( kind = dp ) :: Xext ( 1 : 3 ) real ( kind = dp ) :: AV_fac , UV_fac real ( kind = dp ) :: redshift , Tcmb real ( kind = dp ) :: Av_crit , v_alfv real ( kind = DP ), allocatable :: vectors (:,:) ! Healpix rays real ( kind = DP ), allocatable :: ep (:,:) ! evaluation point along each ray (local) real ( kind = dp ), allocatable :: ra (:) ! distance real ( kind = dp ), allocatable :: density (:) ! density of each grid point - from input real ( kind = DP ), allocatable :: c_dens (:) ! column density real ( kind = dp ), allocatable :: rra (:) ! distance real ( kind = dp ), allocatable :: tau_ij (:) real ( kind = dp ), allocatable :: field (:,:) character ( len = 50 ) :: input character ( len = 50 ) :: output integer ( kind = i4b ), allocatable :: DUPLICATE (:) real ( kind = dp ), allocatable :: ALPHA (:), BETA (:), GAMMA (:), RATE (:), RTMIN (:), RTMAX (:) CHARACTER ( len = 10 ), allocatable :: REACTANT (:,:), PRODUCT (:,:) real ( kind = dp ), allocatable :: MASS (:), init_abundance (:) !,abundances(:,:) CHARACTER ( len = 10 ), allocatable :: SPECIES (:) real ( kind = dp ), bind ( c , name = 'maincode_module_mp_start_time_' ) :: start_time real ( kind = dp ), bind ( c , name = 'maincode_module_mp_end_time_' ) :: end_time integer ( kind = i4b ) :: status #ifdef THERMALBALANCE real ( kind = dp ) :: temp_Tgas #endif character ( len = 50 ) :: paramFile character ( len = 50 ) :: coolfile ( 1 : 30 ) integer :: coo , cur_nlev , cur_ntemp real ( kind = dp ), allocatable :: temp_pop (:) type coolant_node real ( kind = dp ), pointer :: COEFF (:) real ( kind = dp ), pointer :: ENERGIES (:), WEIGHTS (:) real ( kind = dp ), pointer :: A_COEFFS (:,:), B_COEFFS (:,:), C_COEFFS (:,:) real ( kind = dp ), pointer :: FREQUENCIES (:,:), TEMPERATURES (:,:) real ( kind = dp ), pointer :: HP_COL (:,:,:) real ( kind = dp ), pointer :: H_COL (:,:,:) real ( kind = dp ), pointer :: EL_COL (:,:,:) real ( kind = dp ), pointer :: HE_COL (:,:,:) real ( kind = dp ), pointer :: H2_COL (:,:,:) real ( kind = dp ), pointer :: PH2_COL (:,:,:) real ( kind = dp ), pointer :: OH2_COL (:,:,:) real ( kind = dp ) :: molweight integer :: cnlev , cntemp , cspec character ( len = 10 ) :: cname integer :: incr real :: percentage end type coolant_node type ( coolant_node ), allocatable :: coolant (:) real ( kind = dp ) :: temp_Z_function real ( kind = dp ), allocatable :: temp_C_COEFFS (:,:), temp_line (:,:) real ( kind = dp ), allocatable :: temp_transition (:,:), temp_solution (:) type cpop_node real ( kind = dp ), pointer :: evalpop (:,:,:) end type cpop_node type ( cpop_node ), allocatable :: cpop (:) type pdr_excit real ( kind = dp ), pointer :: pop (:) !level populations real ( kind = dp ), pointer :: line (:,:) !emissivity real ( kind = dp ), pointer :: solution (:) !ODE solution real ( kind = dp ), pointer :: relativechange (:) !relative change for convergence logical :: isconverged end type pdr_excit #ifdef RAYTHEIA_MO integer ( kind = i4b ), allocatable :: epray (:) integer ( kind = i4b ), allocatable :: projected (:,:) real ( kind = dp ), allocatable :: plength (:,:) #endif type pdr_node #ifndef RAYTHEIA_MO integer ( kind = i4b ), pointer :: epray (:) !population of evaluation points per ray integer ( kind = i4b ), pointer :: projected (:,:) !ID of projected grid points in the line of sight real ( kind = dp ), pointer :: length (:,:) #endif integer ( kind = i4b ), pointer :: raytype (:) !raytype real ( kind = dp ), pointer :: epoint (:,:,:) !co-ordinates of each evaluation point real ( kind = dp ), pointer :: AV (:) !AV real ( kind = dp ), pointer :: rad_surface (:) !rad_surface real ( kind = dp ), pointer :: abundance (:) !abundance of species real ( kind = dp ), pointer :: cooling (:) real ( kind = dp ), pointer :: heating (:) real ( kind = dp ), pointer :: column_NH2 (:) real ( kind = dp ), pointer :: column_NHD (:) real ( kind = dp ), pointer :: column_NCO (:) real ( kind = dp ), pointer :: column_NC (:) real ( kind = dp ), pointer :: column_NS (:) real ( kind = dp ) :: totalcooling type ( pdr_excit ), allocatable :: coolant (:) real ( kind = dp ) :: UVfield !attenuated UV field of element real ( kind = dp ) :: zetalocal !local cosmic-ray ionization rate real ( kind = dp ) :: rho !density of element real ( kind = dp ) :: smoo !smoothing length (if SPH = .TRUE. in params.dat) real ( kind = dp ) :: x , y , z !position of element integer ( kind = i4b ) :: etype !element type (1 = PDR, 2 = ION, 3 = DARK) real ( kind = dp ) :: Tdust !Dust temperature real ( kind = dp ) :: nTgas !next gas temperature (use this for the initialization) real ( kind = dp ) :: Tgas !current gas temperature (final output) real ( kind = dp ), pointer :: solution (:,:) logical :: levelconverged character ( len = 1 ) :: previouschange #ifdef RESTART logical :: restconverged #endif #ifdef THERMALBALANCE logical :: dobinarychop logical :: fullyconverged real ( kind = dp ) :: Fmean real ( kind = dp ) :: Fratio real ( kind = dp ) :: Tlow real ( kind = dp ) :: Thigh logical :: doleveltmin #endif end type pdr_node type ( pdr_node ), allocatable :: pdr (:) !main 3DPDR array for each grid point p integer ( kind = i4b ) :: levpop_iteration #ifdef GUESS_TEMP #endif #ifdef CHEMANALYSIS real ( kind = dp ), allocatable :: temp_rate (:,:) #endif !================================ !================================ !================================ real ( kind = dp ) :: thermal_percentage real ( kind = dp ) :: levpop_percentage real ( kind = dp ) :: rad_tot character ( len = 100 ) :: out_file , out_file2 character ( len = 7 ) :: file_ext character ( len = 6 ) :: file_numb integer ( kind = i4b ) :: referee , id logical :: level_conv , first_time logical :: relch_conv #ifdef OPENMP integer :: CPUs #endif logical , allocatable :: expanded (:) integer ( kind = i4b ) :: pdr_ptot real ( kind = DP ), allocatable :: pdrpoint (:,:) ! coordinates of pdr element real ( kind = dp ) :: xpos , ypos , zpos , denst !================================ !================================ !================================ END MODULE maincode_module module uclpdr_module use definitions use healpix_types integer ( kind = i4b ), save :: NUMH2 = 105 real ( kind = dp ), dimension ( 105 ), save :: COL_GRID = ( / & & 0.000D+00 , 3.690D+11 , 3.715D+12 , 3.948D+13 , 1.233D+14 , & & 2.536D+14 , 4.342D+14 , 6.653D+14 , 6.689D+14 , 9.075D+14 , & & 1.234D+15 , 1.631D+15 , 2.105D+15 , 2.363D+15 , 2.899D+15 , & & 3.207D+15 , 3.848D+15 , 4.636D+15 , 5.547D+15 , 6.604D+15 , & & 7.855D+15 , 9.368D+15 , 1.122D+16 , 1.352D+16 , 1.643D+16 , & & 2.017D+16 , 2.515D+16 , 3.190D+16 , 4.128D+16 , 5.439D+16 , & & 7.315D+16 , 1.009D+17 , 1.432D+17 , 2.092D+17 , 3.123D+17 , & & 4.738D+17 , 5.388D+17 , 8.935D+17 , 1.381D+18 , 2.164D+18 , & & 3.330D+18 , 5.024D+18 , 7.404D+18 , 9.029D+18 , 1.316D+19 , & & 1.813D+19 , 2.453D+19 , 3.248D+19 , 4.216D+19 , 5.370D+19 , & & 6.722D+19 , 8.277D+19 , 9.894D+19 , 1.186D+20 , 1.404D+20 , & & 1.644D+20 , 1.908D+20 , 2.197D+20 , 2.510D+20 , 2.849D+20 , & & 3.214D+20 , 3.604D+20 , 4.019D+20 , 4.456D+20 , 4.915D+20 , & & 5.393D+20 , 5.886D+20 , 6.392D+20 , 6.909D+20 , 7.433D+20 , & & 7.965D+20 , 8.505D+20 , 9.056D+20 , 9.627D+20 , 1.011D+21 , & & 1.068D+21 , 1.125D+21 , 1.185D+21 , 1.250D+21 , 1.327D+21 , & & 1.428D+21 , 1.578D+21 , 1.851D+21 , 2.128D+21 , 2.298D+21 , & & 2.389D+21 , 2.459D+21 , 2.519D+21 , 2.571D+21 , 2.618D+21 , & & 2.707D+21 , 2.790D+21 , 2.887D+21 , 3.001D+21 , 3.139D+21 , & & 3.303D+21 , 3.497D+21 , 3.722D+21 , 3.983D+21 , 4.283D+21 , & & 4.644D+21 , 5.127D+21 , 5.945D+21 , 8.205D+21 , 1.015D+22 / ) real ( kind = dp ), dimension ( 105 ), save :: SH2_GRID = ( / & & 1.000D+00 , 9.983D-01 , 9.853D-01 , 8.761D-01 , 7.199D-01 , & & 5.728D-01 , 4.455D-01 , 3.431D-01 , 3.418D-01 , 2.732D-01 , & & 2.110D-01 , 1.619D-01 , 1.236D-01 , 1.084D-01 , 8.447D-02 , & & 7.410D-02 , 5.774D-02 , 4.416D-02 , 3.390D-02 , 2.625D-02 , & & 2.048D-02 , 1.606D-02 , 1.264D-02 , 9.987D-03 , 7.937D-03 , & & 6.343D-03 , 5.088D-03 , 4.089D-03 , 3.283D-03 , 2.640D-03 , & & 2.130D-03 , 1.725D-03 , 1.397D-03 , 1.129D-03 , 9.097D-04 , & & 7.340D-04 , 6.883D-04 , 5.377D-04 , 4.352D-04 , 3.475D-04 , & & 2.771D-04 , 2.205D-04 , 1.753D-04 , 1.549D-04 , 1.210D-04 , & & 9.666D-05 , 7.705D-05 , 6.148D-05 , 4.904D-05 , 3.909D-05 , & & 3.112D-05 , 2.473D-05 , 1.997D-05 , 1.578D-05 , 1.244D-05 , & & 9.769D-06 , 7.634D-06 , 5.932D-06 , 4.581D-06 , 3.515D-06 , & & 2.679D-06 , 2.029D-06 , 1.527D-06 , 1.144D-06 , 8.523D-07 , & & 6.332D-07 , 4.693D-07 , 3.475D-07 , 2.574D-07 , 1.907D-07 , & & 1.413D-07 , 1.047D-07 , 7.739D-08 , 5.677D-08 , 4.386D-08 , & & 3.227D-08 , 2.385D-08 , 1.750D-08 , 1.248D-08 , 8.389D-09 , & & 5.026D-09 , 2.382D-09 , 6.259D-10 , 1.653D-10 , 7.399D-11 , & & 4.824D-11 , 3.474D-11 , 2.633D-11 , 2.069D-11 , 1.663D-11 , & & 1.099D-11 , 7.506D-12 , 4.825D-12 , 2.864D-12 , 1.534D-12 , & & 7.324D-13 , 3.087D-13 , 1.135D-13 , 3.591D-14 , 9.689D-15 , & & 2.045D-15 , 2.618D-16 , 8.918D-18 , 3.041D-21 , 1.739D-23 / ) logical :: start integer ( kind = i4b ), save :: DIMH2 = 6 integer ( kind = i4b ), save :: DIMCO = 8 real ( kind = dp ), dimension ( 8 ), save :: NCO_GRID = ( / & & 1 2.0D0 , 1 3.0D0 , 1 4.0D0 , 1 5.0D0 , 1 6.0D0 , 1 7.0D0 , 1 8.0D0 , 1 9.0D0 / ) real ( kind = dp ), dimension ( 6 ), save :: NH2_GRID = ( / & & 1 8.0D0 , 1 9.0D0 , 2 0.0D0 , 2 1.0D0 , 2 2.0D0 , 2 3.0D0 / ) real ( kind = dp ) :: SCO_GRID ( 1 : 8 , 1 : 6 ) integer ( kind = i4b ), save :: N_GRID = 30 real ( kind = dp ), dimension ( 30 ), save :: L_GRID = ( / & & 91 0.0D0 , 95 0.0D0 , 100 0.0D0 , 105 0.0D0 , 111 0.0D0 , & & 118 0.0D0 , 125 0.0D0 , 139 0.0D0 , 149 0.0D0 , 160 0.0D0 , & & 170 0.0D0 , 180 0.0D0 , 190 0.0D0 , 200 0.0D0 , 210 0.0D0 , & & 219 0.0D0 , 230 0.0D0 , 240 0.0D0 , 250 0.0D0 , 274 0.0D0 , & & 344 0.0D0 , 400 0.0D0 , 440 0.0D0 , 550 0.0D0 , 700 0.0D0 , & & 900 0.0D0 , 1250 0.0D0 , 2200 0.0D0 , 3400 0.0D0 , 1.0D9 / ) real ( kind = dp ), dimension ( 30 ), save :: X_GRID = ( / & & 5.76D0 , 5.18D0 , 4.65D0 , 4.16D0 , 3.73D0 , & & 3.40D0 , 3.11D0 , 2.74D0 , 2.63D0 , 2.62D0 , & & 2.54D0 , 2.50D0 , 2.58D0 , 2.78D0 , 3.01D0 , & & 3.12D0 , 2.86D0 , 2.58D0 , 2.35D0 , 2.00D0 , & & 1.58D0 , 1.42D0 , 1.32D0 , 1.00D0 , 0.75D0 , & & 0.48D0 , 0.28D0 , 0.12D0 , 0.05D0 , 0.00D0 / ) real ( kind = dp ) :: SH2_DERIV ( 1 : 105 ), SCO_DERIV ( 1 : 8 , 1 : 6 ), X_DERIV ( 1 : 30 ) end module uclpdr_module module global_module USE ISO_C_BINDING use definitions use healpix_types INTEGER ( kind = i4b ) :: NH , ND , NH2 , NHD , NC , NCx , NCO , NO , NPROTON , NH2O , NHe , & & NMG , NMGx , NN , NFE , NFEx , NSI , NSIx , NCA , NCAx , NCAxx , NS , NSx , NCS , & & NOSH , NCL , NCLx , NH2x , NHEx , NOx , NNx , NNA , NNAx , NCH , NCH2 , NOH , NO2 , & & NH3x , NH3Ox , NHCOx , NCHx , NCN , NOHx , NSiO , NC2H , NHCN , NHNC , NN2Hx integer ( kind = i4b ), bind ( c , name = 'global_module_mp_nelect_' ) :: NELECT REAL ( kind = dp ) :: metallicity REAL ( kind = dp ) :: omega REAL ( kind = dp ) :: grain_radius real ( kind = dp ), allocatable :: allheating (:) end module global_module module functions_module use definitions use healpix_types implicit none interface function H2PDRATE ( K0 , G0 , AV , NH2 ) use definitions use healpix_types real ( kind = dp ) :: H2PDRATE real ( kind = dp ), intent ( in ) :: k0 , g0 , av real ( kind = dp ), intent ( in ) :: nh2 real ( kind = dp ) :: lambda , scatter , h2shield2 end function H2PDRATE function COPDRATE ( K0 , G0 , AV , NCO , NH2 ) use definitions use healpix_types real ( kind = dp ) :: copdrate real ( kind = dp ), intent ( in ) :: k0 , g0 , av , nco real ( kind = dp ), intent ( in ) :: nh2 real ( kind = dp ) :: lambda , lbar , coshield , scatter end function copdrate function CIPDRATE ( K0 , G0 , AV , KAV , NCI , NH2 , TGAS ) use definitions use healpix_types real ( kind = dp ) :: cipdrate real ( kind = dp ), intent ( in ) :: K0 , G0 , AV , KAV , NCI , TGAS real ( kind = dp ), intent ( in ) :: nh2 real ( kind = dp ) :: tauc end function cipdrate function SIPDRATE ( K0 , G0 , AV , KAV , NSI ) use definitions use healpix_types real ( kind = dp ) :: sipdrate real ( kind = dp ), intent ( in ) :: K0 , G0 , AV , KAV , NSI real ( kind = dp ) :: taus end function sipdrate function H2SHIELD1 ( NH2 , DOPW , RADW ) use definitions use healpix_types real ( kind = dp ) :: h2shield1 real ( kind = dp ), intent ( in ) :: nh2 real ( kind = dp ), intent ( in ) :: DOPW , RADW real ( kind = dp ) :: FPARA , FOSC , TAUD , R , T , U , JD , JR end function h2shield1 function h2shield2 ( nh2 ) use definitions use healpix_types use uclpdr_module , only : start , numh2 , COL_GRID , SH2_GRID , SH2_DERIV real ( kind = dp ) :: h2shield2 real ( kind = dp ), intent ( in ) :: nh2 end function h2shield2 function COSHIELD ( NCO , NH2 ) use definitions use healpix_types use uclpdr_module , only : start , NCO_GRID , NH2_GRID , SCO_GRID , SCO_DERIV real ( kind = dp ) :: COSHIELD real ( kind = dp ) :: LOGNCO , LOGNH2 real ( kind = dp ), intent ( in ) :: NCO , NH2 end function COSHIELD function SCATTER ( AV , LAMBDA ) use definitions use healpix_types real ( kind = dp ) :: scatter real ( kind = dp ), intent ( in ) :: AV , LAMBDA real ( kind = dp ), dimension ( 0 : 5 ), save :: A = ( / & & 1.000D0 , 2.006D0 , - 1.438D0 , 0.7364D0 , - 0.5076D0 , - 0.0592D0 / ) real ( kind = dp ), dimension ( 0 : 5 ), save :: K = ( / & & 0.7514D0 , 0.8490D0 , 1.013D0 , 1.282D0 , 2.005D0 , 5.832D0 / ) real ( kind = dp ) :: EXPONENT , XLAMBDA end function scatter function XLAMBDA ( LAMBDA ) use definitions use healpix_types use uclpdr_module , only : start , N_GRID , L_GRID , X_GRID , X_DERIV real ( kind = dp ) :: xlambda real ( kind = dp ), intent ( in ) :: lambda end function xlambda function LBAR ( NCO , NH2 ) use definitions use healpix_types real ( kind = dp ) :: lbar real ( kind = dp ) :: U , W real ( kind = dp ) :: NCO , NH2 end function LBAR function calculate_heating ( density , gas_temperature , dust_temperature , UV_field , & & v_turb , nspec , init_abundance , nreac , rate ) use definitions use healpix_types real ( kind = dp ) :: calculate_heating integer ( kind = i4b ) :: nspec , nreac real ( kind = dp ) :: density , gas_temperature , dust_temperature , UV_field , v_turb real ( kind = dp ) :: init_abundance ( 1 : nspec ), rate ( 1 : nreac ) end function calculate_heating #ifdef H2FORM_CT02 FUNCTION H2_FORMATION_RATE ( GAS_TEMPERATURE , GRAIN_TEMPERATURE ) RESULT ( RATE ) USE DEFINITIONS USE HEALPIX_TYPES IMPLICIT NONE REAL ( KIND = DP ) :: RATE REAL ( KIND = DP ), INTENT ( IN ) :: GAS_TEMPERATURE , GRAIN_TEMPERATURE END FUNCTION H2_FORMATION_RATE #endif end interface end module functions_module module chemistry_module USE ISO_C_BINDING use healpix_types real ( kind = dp ), bind ( c , name = 'chemistry_module_mp_relative_abundance_tolerance_' ) :: relative_abundance_tolerance real ( kind = dp ), bind ( c , name = 'chemistry_module_mp_absolute_abundance_tolerance_' ) :: absolute_abundance_tolerance end module chemistry_module","tags":"","url":"sourcefile/modules.f90.html"},{"title":"CRattenuation.F90 – 3D-PDR","text":"This file depends on sourcefile~~crattenuation.f90~~EfferentGraph sourcefile~crattenuation.f90 CRattenuation.F90 sourcefile~definitions.f90 definitions.F90 sourcefile~crattenuation.f90->sourcefile~definitions.f90 sourcefile~healpix_types.f90 healpix_types.F90 sourcefile~crattenuation.f90->sourcefile~healpix_types.f90 sourcefile~modules.f90 modules.F90 sourcefile~crattenuation.f90->sourcefile~modules.f90 sourcefile~healpix_types.f90->sourcefile~definitions.f90 sourcefile~modules.f90->sourcefile~definitions.f90 sourcefile~modules.f90->sourcefile~healpix_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !Calculate CR attenuation subroutine calc_CRattenuation use healpix_types use maincode_module use global_module implicit none integer :: j real ( kind = dp ) :: coltest , crfieldaux #ifdef CRATTENUATION DO p = 1 , pdr_ptot pdr ( p )% zetalocal = 0 d0 #ifndef ONEDIMENSIONAL coltest = 0 d0 DO j = 0 , nrays - 1 coltest = coltest + EXP ( - 3.5 * pdr ( p )% AV ( j )) ENDDO coltest = ( - 1.0 / 3.5 ) * LOG (( 1.0 / real ( nrays , kind = dp )) * coltest ) coltest = coltest / AV_fac coltest = max ( coltest , 5e17 ) #if CRATTENUATION == 1 call zetafuncPad ( coltest , pdr ( p )% zetalocal ) #else call zetafuncPoly ( coltest , pdr ( p )% zetalocal ) #endif pdr ( p )% zetalocal = pdr ( p )% zetalocal #else #if CRATTENUATION == 1 call zetafuncPad ( pdr ( p )% AV ( 6 ) / AV_fac , pdr ( p )% zetalocal ) #else call zetafuncPoly ( pdr ( p )% AV ( 6 ) / AV_fac , pdr ( p )% zetalocal ) #endif #endif pdr ( p )% zetalocal = pdr ( p )% zetalocal / 1.3d-17 enddo #else do p = 1 , pdr_ptot pdr ( p )% zetalocal = zeta end do #endif return contains subroutine zetafuncPad ( ncol , zetalocal ) use definitions implicit none real ( kind = DP ), intent ( in ) :: ncol real ( kind = DP ), intent ( out ) :: zetalocal integer :: ii real ( kind = DDP ), dimension ( 0 : 9 ) :: fl = ( / - 3.331056497233d6 , & & 1.207744586503d6 , - 1.913914106234d5 , 1.731822350618d4 , & & - 9.790557206178d2 , 3.543830893824d1 , - 8.03486945420d-01 , & & 1.048808593086d-02 , - 6.188760100997d-05 , 3.122820990797d-08 / ) real ( kind = DDP ), dimension ( 0 : 9 ) :: fh = ( / 1.001098610761d7 , & & - 4.231294690194d6 , 7.921914432011d5 , - 8.623677095423d4 , & & 6.015889127529d3 , - 2.789238383353d2 , 8.595814402406d0 , & & - 1.698029737474d-1 , 1.951179287567d-3 , - 9.937499546711d-6 / ) real ( kind = DDP ) :: craux real ( kind = DDP ) :: lcol craux = 0 d0 lcol = LOG10 ( MAX ( ncol , 5E18 )) do ii = 0 , 9 if (( crfieldchoice . eq . \"L\" ) . or . ( crfieldchoice . eq . \"l\" )) then craux = craux + fl ( ii ) * lcol ** ii endif if (( crfieldchoice . eq . \"H\" ) . or . ( crfieldchoice . eq . \"h\" )) then craux = craux + fh ( ii ) * lcol ** ii endif end do zetalocal = 10 ** craux return end subroutine subroutine zetafuncPoly ( ncol , zetalocal ) use definitions use maincode_module , only : crattennorm , crattenslope , crattenn0 implicit none real ( kind = DP ), intent ( in ) :: ncol real ( kind = DP ), intent ( out ) :: zetalocal real ( kind = DP ) :: craux , critsurface critsurface = 4.182e25 ! This is 98 g/cm&#94;3 zetalocal = crattennorm * (( 1.0 + ncol / crattenn0 ) ** crattenslope ) * EXP ( - 1.0 * ncol / critsurface ) end subroutine end subroutine","tags":"","url":"sourcefile/crattenuation.f90.html"},{"title":"m_Ray_box.F90 – 3D-PDR","text":"This file depends on sourcefile~~m_ray_box.f90~~EfferentGraph sourcefile~m_ray_box.f90 m_Ray_box.F90 sourcefile~m_mesh.f90 m_Mesh.F90 sourcefile~m_ray_box.f90->sourcefile~m_mesh.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~m_ray_box.f90~~AfferentGraph sourcefile~m_ray_box.f90 m_Ray_box.F90 sourcefile~columndensity.f90 columndensity.F90 sourcefile~columndensity.f90->sourcefile~m_ray_box.f90 sourcefile~coolingfunctions.f90 coolingfunctions.F90 sourcefile~coolingfunctions.f90->sourcefile~m_ray_box.f90 sourcefile~escape_probability.f90 escape_probability.F90 sourcefile~escape_probability.f90->sourcefile~m_ray_box.f90 sourcefile~eval_points.f90 eval_points.F90 sourcefile~eval_points.f90->sourcefile~m_ray_box.f90 sourcefile~init3dpdr.f90 init3DPDR.F90 sourcefile~init3dpdr.f90->sourcefile~m_ray_box.f90 sourcefile~readdensity.f90 readdensity.F90 sourcefile~readdensity.f90->sourcefile~m_ray_box.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module m_Ray_box use m_Mesh implicit none private real ( RK ), parameter , public :: PC = 3.08568025D+18 type , public :: box real ( RK ) :: min ( 3 ), max ( 3 ) end type box type :: slab real ( RK ) :: origin ( 3 ), dir ( 3 ), dir_inv ( 3 ) end type slab type , public :: HEALPix_ray integer :: eval real ( RK ) :: length real ( RK ) :: origin ( 3 ), angle ( 2 ) end type HEALPix_ray public :: octree contains logical function isfinite ( x ) real ( RK ), intent ( in ) :: x isfinite = ( abs ( x ) < huge ( x ) . and . x == x ) end function isfinite subroutine intersections ( ray , box_in , length ) implicit none type ( slab ), intent ( in ) :: ray type ( box ), intent ( in ) :: box_in real ( RK ), intent ( inout ) :: length integer :: i , d real ( RK ) :: tmin , tmax , t1 , t2 real ( RK ) :: Pmin ( 3 ), Pmax ( 3 ) real ( RK ) :: distance , diff real ( RK ) :: temp ! 初始化 tmin 和 tmax tmin = 0.0 tmax = huge ( 0.0 ) ! 设置 tmax 为无穷大 ! 遍历 x, y, z 三个维度 do d = 1 , 3 if ( isfinite ( ray % dir_inv ( d ))) then ! 计算 t1 和 t2 t1 = ( box_in % min ( d ) - ray % origin ( d )) * ray % dir_inv ( d ) t2 = ( box_in % max ( d ) - ray % origin ( d )) * ray % dir_inv ( d ) ! 确保 t1 是较小值，t2 是较大值 if ( t1 > t2 ) then temp = t1 t1 = t2 t2 = temp end if ! 更新 tmin 和 tmax tmin = max ( tmin , t1 ) tmax = min ( tmax , t2 ) else if ( ray % origin ( d ) < box_in % min ( d ) . or . ray % origin ( d ) > box_in % max ( d )) then ! 射线与某个维度的边界盒平行且射线起点不在盒子内 tmin = huge ( 0.0 ) exit end if end do ! 判断射线是否与盒子相交 if ( tmin <= tmax ) then ! 计算交点坐标 do d = 1 , 3 Pmin ( d ) = ray % origin ( d ) + tmin / ray % dir_inv ( d ) Pmax ( d ) = ray % origin ( d ) + tmax / ray % dir_inv ( d ) end do ! 计算欧几里得距离 distance = 0.0 do d = 1 , 3 diff = Pmax ( d ) - Pmin ( d ) distance = distance + diff ** 2 end do length = sqrt ( distance ) ! 射线穿过盒子的欧几里得距离 else length = 0.0 ! 如果不相交，长度为 0 end if end subroutine intersections recursive subroutine octree ( ray , parent , level , contribution , contribution_1D , density_3D , density_1D ) type ( HEALPix_ray ), intent ( in ) :: ray type ( slab ) :: ray_xyz type ( box ), intent ( in ) :: parent type ( box ) :: children ( 0 : 7 ) integer , intent ( in ) :: level real ( RK ), intent ( inout ) :: contribution , contribution_1D integer :: i , j , k , d , m , parent_index , ir , node_count , start_index , p real ( RK ) :: mid ( 3 ), extent ( 3 ), center ( 3 ) logical :: intersect real ( RK ) :: x , y , z , r , xnode , ynode , znode real ( RK ) :: Aij , c , nu , pc2cm , f , g_i , g_j , thfpix , phfpix , length real ( RK ) :: density_3D (:,:,:) real ( RK ) :: density_1D (:) if ( level > 0 ) then ray_xyz % origin = ray % origin thfpix = ray % angle ( 1 ) phfpix = ray % angle ( 2 ) ray_xyz % dir ( 1 ) = sin ( thfpix ) * cos ( phfpix ) ray_xyz % dir ( 2 ) = sin ( thfpix ) * sin ( phfpix ) ray_xyz % dir ( 3 ) = cos ( thfpix ) do m = 1 , 3 if ( abs ( ray_xyz % dir ( m )) > 1.0e-6 ) then ray_xyz % dir_inv ( m ) = 1.0 / ray_xyz % dir ( m ) else ray_xyz % dir_inv ( m ) = huge ( 0.D0 ) ! 避免除以零 end if end do length = 0.0 call intersections ( ray_xyz , parent , length ) intersect = . false . if ( length > 0.0 ) then intersect = . true . endif if ( intersect ) then ! generate eight child boxes start_index = 0 do i = 0 , 7 do d = 1 , 3 mid ( d ) = ( parent % min ( d ) + parent % max ( d )) / 2.0 if ( btest ( i , d - 1 )) then children ( start_index )% min ( d ) = mid ( d ) children ( start_index )% max ( d ) = parent % max ( d ) else children ( start_index )% min ( d ) = parent % min ( d ) children ( start_index )% max ( d ) = mid ( d ) endif enddo start_index = start_index + 1 enddo do i = 0 , 7 call octree ( ray , children ( i ), level - 1 , contribution , contribution_1D , density_3D , density_1D ) enddo endif endif ! leaf nodes calculations if ( level == 0 ) then I = nint ( parent % max ( 1 ) / dx ) J = nint ( parent % max ( 2 ) / dy ) K = nint ( parent % max ( 3 ) / dz ) p = I + ( J - 1 ) * nxc + ( K - 1 ) * ( nxc * nyc ) ! penetrate length ray_xyz % origin = ray % origin thfpix = ray % angle ( 1 ) phfpix = ray % angle ( 2 ) ray_xyz % dir ( 1 ) = sin ( thfpix ) * cos ( phfpix ) ray_xyz % dir ( 2 ) = sin ( thfpix ) * sin ( phfpix ) ray_xyz % dir ( 3 ) = cos ( thfpix ) do m = 1 , 3 if ( abs ( ray_xyz % dir ( m )) > 1.0e-6 ) then ray_xyz % dir_inv ( m ) = 1.0 / ray_xyz % dir ( m ) else ray_xyz % dir_inv ( m ) = huge ( 0.D0 ) ! 避免除以零 end if end do length = 0.0 call intersections ( ray_xyz , parent , length ) if ( I . eq . 3 3. and . J . eq . 1. and . K . eq . 32 ) print * , ray_xyz % origin , ray_xyz % dir , parent % min , parent % max , length if ( length . ne . 0 ) print * , I , J , K , length contribution = contribution + density_3D ( I , J , K ) * length * pc contribution_1D = contribution_1D + density_1D ( p ) * length * pc endif end subroutine octree end module m_Ray_box","tags":"","url":"sourcefile/m_ray_box.f90.html"},{"title":"read_command_line.F90 – 3D-PDR","text":"This file depends on sourcefile~~read_command_line.f90~~EfferentGraph sourcefile~read_command_line.f90 read_command_line.F90 sourcefile~definitions.f90 definitions.F90 sourcefile~read_command_line.f90->sourcefile~definitions.f90 sourcefile~modules.f90 modules.F90 sourcefile~read_command_line.f90->sourcefile~modules.f90 sourcefile~modules.f90->sourcefile~definitions.f90 sourcefile~healpix_types.f90 healpix_types.F90 sourcefile~modules.f90->sourcefile~healpix_types.f90 sourcefile~healpix_types.f90->sourcefile~definitions.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code SUBROUTINE read_command_line !T.Bisbas, T.Bell use definitions use maincode_module , only : paramFile integer :: commandLineCount , iarg , argIndex character ( len = 50 ) :: arg , param , val character :: delim delim = '=' commandLineCount = command_argument_count () if ( commandLineCount . gt . 0 ) then do iarg = 1 , commandLineCount param = '' val = '' call get_command_argument ( iarg , arg ) arg = trim ( arg ) argIndex = index ( arg , delim ) if ( argIndex . eq . 0 ) then param = trim ( arg ) else param = trim ( arg (: argIndex - 1 )) val = trim ( arg ( argIndex + 1 :)) endif select case ( param ) case ( '-p' , '--param' ) if ( val . eq . '' ) then write ( 6 , * ) \"User must provide param file as -p=paramName.dat\" stop endif paramFile = val write ( 6 , * ) \"Using user provided param file: \" , paramFile case ( '-h' , '--help' ) write ( 6 , * ) \"Allowed parameters to be passed into 3DPDR: \" write ( 6 , * ) \"============================================\" write ( 6 , * ) \"-h, --help        Write out the help menu\" write ( 6 , * ) \"-p, --params      Provide a parameter file (50 char max)\" write ( 6 , * ) \"                  e.g. -p=paramInput.dat\" write ( 6 , * ) \"============================================\" stop case default write ( 6 , * ) \"Unrecognized command line option: \" , param write ( 6 , * ) \"Use -h or --help to see allowed options\" STOP end select end do else write ( 6 , * ) \"Using default parameter file: params.dat\" paramFile = 'params.dat' endif end subroutine read_command_line","tags":"","url":"sourcefile/read_command_line.f90.html"},{"title":"allocations.F90 – 3D-PDR","text":"This file depends on sourcefile~~allocations.f90~~EfferentGraph sourcefile~allocations.f90 allocations.F90 sourcefile~healpix_types.f90 healpix_types.F90 sourcefile~allocations.f90->sourcefile~healpix_types.f90 sourcefile~modules.f90 modules.F90 sourcefile~allocations.f90->sourcefile~modules.f90 sourcefile~definitions.f90 definitions.F90 sourcefile~healpix_types.f90->sourcefile~definitions.f90 sourcefile~modules.f90->sourcefile~healpix_types.f90 sourcefile~modules.f90->sourcefile~definitions.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code subroutine allocations use healpix_types use maincode_module use global_module use uclpdr_module !use maincode_local, only : prev_cooling !load SCO_GRID data SCO_GRID ( 1 : 8 , 1 ) = ( / 0.000D+00 , - 1.408D-02 , - 1.099D-01 , - 4.400D-01 , - 1.154D+00 , - 1.888D+00 , - 2.760D+00 , - 4.001D+00 / ) SCO_GRID ( 1 : 8 , 2 ) = ( /- 8.539D-02 , - 1.015D-01 , - 2.104D-01 , - 5.608D-01 , - 1.272D+00 , - 1.973D+00 , - 2.818D+00 , - 4.055D+00 / ) SCO_GRID ( 1 : 8 , 3 ) = ( /- 1.451D-01 , - 1.612D-01 , - 2.708D-01 , - 6.273D-01 , - 1.355D+00 , - 2.057D+00 , - 2.902D+00 , - 4.122D+00 / ) SCO_GRID ( 1 : 8 , 4 ) = ( /- 4.559D-01 , - 4.666D-01 , - 5.432D-01 , - 8.665D-01 , - 1.602D+00 , - 2.303D+00 , - 3.146D+00 , - 4.421D+00 / ) SCO_GRID ( 1 : 8 , 5 ) = ( /- 1.303D+00 , - 1.312D+00 , - 1.367D+00 , - 1.676D+00 , - 2.305D+00 , - 3.034D+00 , - 3.758D+00 , - 5.077D+00 / ) SCO_GRID ( 1 : 8 , 6 ) = ( /- 3.883D+00 , - 3.888D+00 , - 3.936D+00 , - 4.197D+00 , - 4.739D+00 , - 5.165D+00 , - 5.441D+00 , - 6.446D+00 / ) allocate ( species ( 1 : nspec )) allocate ( init_abundance ( 1 : nspec )) allocate ( mass ( 1 : nspec )) allocate ( reactant ( 1 : nreac , 1 : 3 )) allocate ( product ( 1 : nreac , 1 : 4 )) allocate ( rate ( 1 : nreac )) allocate ( alpha ( 1 : nreac )) allocate ( beta ( 1 : nreac )) allocate ( gamma ( 1 : nreac )) allocate ( rtmin ( 1 : nreac )) allocate ( rtmax ( 1 : nreac )) allocate ( duplicate ( 1 : nreac )) #ifdef CHEMANALYSIS allocate ( temp_rate ( 1 : nreac , 1 : pdr_ptot )) #endif return end subroutine allocations","tags":"","url":"sourcefile/allocations.f90.html"},{"title":"lte_population.F90 – 3D-PDR","text":"This file depends on sourcefile~~lte_population.f90~~EfferentGraph sourcefile~lte_population.f90 lte_population.F90 sourcefile~healpix_types.f90 healpix_types.F90 sourcefile~lte_population.f90->sourcefile~healpix_types.f90 sourcefile~definitions.f90 definitions.F90 sourcefile~healpix_types.f90->sourcefile~definitions.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Calculate the LTE level populations for the given species SUBROUTINE CALCULATE_LTE_POPULATIONS ( NLEV , LEVEL_POP , ENERGIES , WEIGHTS , PARTITION_FUNCTION , DENSITY , TEMPERATURE ) USE HEALPIX_TYPES IMPLICIT NONE INTEGER ( KIND = I4B ), INTENT ( IN ) :: NLEV REAL ( KIND = DP ), INTENT ( IN ) :: ENERGIES ( 1 : NLEV ), WEIGHTS ( 1 : NLEV ) REAL ( KIND = DP ), INTENT ( IN ) :: PARTITION_FUNCTION REAL ( KIND = DP ), INTENT ( IN ) :: DENSITY , TEMPERATURE REAL ( KIND = DP ), INTENT ( OUT ) :: LEVEL_POP ( 1 : NLEV ) INTEGER ( KIND = I4B ) :: ILEVEL REAL ( KIND = DP ) :: TOTAL_POP TOTAL_POP = 0.0D0 DO ILEVEL = 1 , NLEV LEVEL_POP ( ILEVEL ) = DENSITY * WEIGHTS ( ILEVEL ) * EXP ( - ENERGIES ( ILEVEL ) / KB / TEMPERATURE ) / PARTITION_FUNCTION TOTAL_POP = TOTAL_POP + LEVEL_POP ( ILEVEL ) ENDDO ! Check that the sum of the level populations adds up to the total density IF ( ABS ( TOTAL_POP - DENSITY ) / DENSITY . GT . 1.0D-3 ) THEN WRITE ( 6 , * ) 'ERROR! Sum of LTE level populations differs from the total density by ' , & & INT ( 1.0D2 * ABS ( TOTAL_POP - DENSITY ) / DENSITY ), '%' STOP ENDIF RETURN END SUBROUTINE CALCULATE_LTE_POPULATIONS","tags":"","url":"sourcefile/lte_population.f90.html"},{"title":"healpix_types.F90 – 3D-PDR","text":"This file depends on sourcefile~~healpix_types.f90~~EfferentGraph sourcefile~healpix_types.f90 healpix_types.F90 sourcefile~definitions.f90 definitions.F90 sourcefile~healpix_types.f90->sourcefile~definitions.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~healpix_types.f90~~AfferentGraph sourcefile~healpix_types.f90 healpix_types.F90 sourcefile~3dpdr.f90 3DPDR.F90 sourcefile~3dpdr.f90->sourcefile~healpix_types.f90 sourcefile~modules.f90 modules.F90 sourcefile~3dpdr.f90->sourcefile~modules.f90 sourcefile~allocations.f90 allocations.F90 sourcefile~allocations.f90->sourcefile~healpix_types.f90 sourcefile~allocations.f90->sourcefile~modules.f90 sourcefile~analyse_chem.f90 analyse_chem.F90 sourcefile~analyse_chem.f90->sourcefile~healpix_types.f90 sourcefile~analyse_chem.f90->sourcefile~modules.f90 sourcefile~calc_reac_rates.f90 calc_reac_rates.F90 sourcefile~calc_reac_rates.f90->sourcefile~healpix_types.f90 sourcefile~calc_reac_rates.f90->sourcefile~modules.f90 sourcefile~checkconvergence.f90 checkconvergence.F90 sourcefile~checkconvergence.f90->sourcefile~healpix_types.f90 sourcefile~checkconvergence.f90->sourcefile~modules.f90 sourcefile~chemicaliterations.f90 chemicaliterations.F90 sourcefile~chemicaliterations.f90->sourcefile~healpix_types.f90 sourcefile~chemicaliterations.f90->sourcefile~modules.f90 sourcefile~columndensity.f90 columndensity.F90 sourcefile~columndensity.f90->sourcefile~healpix_types.f90 sourcefile~columndensity.f90->sourcefile~modules.f90 sourcefile~coolingfunctions.f90 coolingfunctions.F90 sourcefile~coolingfunctions.f90->sourcefile~healpix_types.f90 sourcefile~coolingfunctions.f90->sourcefile~modules.f90 sourcefile~crattenuation.f90 CRattenuation.F90 sourcefile~crattenuation.f90->sourcefile~healpix_types.f90 sourcefile~crattenuation.f90->sourcefile~modules.f90 sourcefile~dust_t.f90 dust_t.F90 sourcefile~dust_t.f90->sourcefile~healpix_types.f90 sourcefile~dust_t.f90->sourcefile~modules.f90 sourcefile~escape_probability.f90 escape_probability.F90 sourcefile~escape_probability.f90->sourcefile~healpix_types.f90 sourcefile~escape_probability.f90->sourcefile~modules.f90 sourcefile~eval_points.f90 eval_points.F90 sourcefile~eval_points.f90->sourcefile~healpix_types.f90 sourcefile~eval_points.f90->sourcefile~modules.f90 sourcefile~h2_form.f90 h2_form.F90 sourcefile~h2_form.f90->sourcefile~healpix_types.f90 sourcefile~h2_form.f90->sourcefile~modules.f90 sourcefile~healpix.f90 healpix.F90 sourcefile~healpix.f90->sourcefile~healpix_types.f90 sourcefile~healpix.f90->sourcefile~modules.f90 sourcefile~heapsort.f90 heapsort.F90 sourcefile~heapsort.f90->sourcefile~healpix_types.f90 sourcefile~input_parameters.f90 input_parameters.F90 sourcefile~input_parameters.f90->sourcefile~healpix_types.f90 sourcefile~input_parameters.f90->sourcefile~modules.f90 sourcefile~lte_population.f90 lte_population.F90 sourcefile~lte_population.f90->sourcefile~healpix_types.f90 sourcefile~m_ray_box.f90~2 m_Ray_box.F90 sourcefile~m_ray_box.f90~2->sourcefile~healpix_types.f90 sourcefile~m_ray_box.f90~2->sourcefile~modules.f90 sourcefile~modules.f90->sourcefile~healpix_types.f90 sourcefile~partition_function.f90 partition_function.F90 sourcefile~partition_function.f90->sourcefile~healpix_types.f90 sourcefile~read_input.f90 read_input.F90 sourcefile~read_input.f90->sourcefile~healpix_types.f90 sourcefile~read_rates.f90 read_rates.F90 sourcefile~read_rates.f90->sourcefile~healpix_types.f90 sourcefile~read_rates.f90->sourcefile~modules.f90 sourcefile~read_species.f90 read_species.F90 sourcefile~read_species.f90->sourcefile~healpix_types.f90 sourcefile~read_species.f90->sourcefile~modules.f90 sourcefile~readdensity.f90 readdensity.F90 sourcefile~readdensity.f90->sourcefile~healpix_types.f90 sourcefile~readdensity.f90->sourcefile~modules.f90 sourcefile~shield.f90 shield.F90 sourcefile~shield.f90->sourcefile~healpix_types.f90 sourcefile~shield.f90->sourcefile~modules.f90 sourcefile~solvlevpop.f90 solvlevpop.F90 sourcefile~solvlevpop.f90->sourcefile~healpix_types.f90 sourcefile~solvlevpop.f90->sourcefile~modules.f90 sourcefile~spline.f90 spline.F90 sourcefile~spline.f90->sourcefile~healpix_types.f90 sourcefile~uvfield.f90 UVfield.F90 sourcefile~uvfield.f90->sourcefile~healpix_types.f90 sourcefile~uvfield.f90->sourcefile~modules.f90 sourcefile~writeoutputs.f90 writeoutputs.F90 sourcefile~writeoutputs.f90->sourcefile~healpix_types.f90 sourcefile~writeoutputs.f90->sourcefile~modules.f90 sourcefile~writeoutputs_h5.f90 writeoutputs_h5.F90 sourcefile~writeoutputs_h5.f90->sourcefile~healpix_types.f90 sourcefile~writeoutputs_h5.f90->sourcefile~modules.f90 sourcefile~writeparams.f90 writeparams.F90 sourcefile~writeparams.f90->sourcefile~healpix_types.f90 sourcefile~writeparams.f90->sourcefile~modules.f90 sourcefile~changetemperature.f90 changetemperature.F90 sourcefile~changetemperature.f90->sourcefile~modules.f90 sourcefile~initialization.f90 initialization.F90 sourcefile~initialization.f90->sourcefile~modules.f90 sourcefile~m_ioandvisu.f90 m_IOAndVisu.F90 sourcefile~m_ioandvisu.f90->sourcefile~modules.f90 sourcefile~read_command_line.f90 read_command_line.F90 sourcefile~read_command_line.f90->sourcefile~modules.f90 sourcefile~read_coolants.f90 read_coolants.F90 sourcefile~read_coolants.f90->sourcefile~modules.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !----------------------------------------------------------------------------- ! !  Copyright (C) 1997-2005 Krzysztof M. Gorski, Eric Hivon, !                          Benjamin D. Wandelt, Anthony J. Banday, !                          Matthias Bartelmann, Hans K. Eriksen, !                          Frode K. Hansen, Martin Reinecke ! ! !  This file is part of HEALPix. ! !  HEALPix is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 2 of the License, or !  (at your option) any later version. ! !  HEALPix is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with HEALPix; if not, write to the Free Software !  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA ! !  For more information about HEALPix see http://healpix.jpl.nasa.gov ! !----------------------------------------------------------------------------- MODULE healpix_types ! This module sets the types used in the Fortran 90 modules ! of the HEALPIX distribution and follows the example of Numerical Recipes ! ! Benjamin D. Wandelt October 1997 ! Eric Hivon June 1998 ! Eric Hivon Oct  2001, edited to be compatible with 'F' compiler ! Eric Hivon July 2002, addition of i8b, i2b, i1b !                       addition of max_i8b, max_i2b and max_i1b !            Jan 2005, explicit form of max_i1b because of ifc 8.1.021 !            June 2005, redefine i8b as 16 digit integer because of Nec f90 compiler ! Include definitions module for universal definition of DP, PR, SP use definitions INTEGER , PARAMETER , public :: i8b = SELECTED_INT_KIND ( 16 ) INTEGER , PARAMETER , public :: i4b = SELECTED_INT_KIND ( 9 ) INTEGER , PARAMETER , public :: i2b = SELECTED_INT_KIND ( 4 ) INTEGER , PARAMETER , public :: i1b = SELECTED_INT_KIND ( 2 ) INTEGER , PARAMETER , public :: lgt = KIND (. TRUE .) INTEGER , PARAMETER , public :: spc = KIND (( 1.0_sp , 1.0_sp )) INTEGER , PARAMETER , public :: dpc = KIND (( 1.0_dp , 1.0_dp )) ! INTEGER ( I8B ), PARAMETER , public :: max_i8b = HUGE ( 1_i8b ) INTEGER , PARAMETER , public :: max_i4b = HUGE ( 1_i4b ) INTEGER , PARAMETER , public :: max_i2b = HUGE ( 1_i2b ) INTEGER , PARAMETER , public :: max_i1b = 127 REAL ( kind = sp ), PARAMETER , public :: max_sp = HUGE ( 1.0_sp ) REAL ( kind = dp ), PARAMETER , public :: max_dp = HUGE ( 1.0_dp ) ! Numerical Constant (Double precision) REAL ( kind = dp ), PARAMETER , public :: QUARTPI = 0.785398163397448309615660845819875721049_dp REAL ( kind = dp ), PARAMETER , public :: HALFPI = 1.570796326794896619231321691639751442099_dp REAL ( kind = dp ), PARAMETER , public :: PI = 3.141592653589793238462643383279502884197_dp REAL ( kind = dp ), PARAMETER , public :: TWOPI = 6.283185307179586476925286766559005768394_dp REAL ( kind = dp ), PARAMETER , public :: FOURPI = 1 2.56637061435917295385057353311801153679_dp REAL ( kind = dp ), PARAMETER , public :: SQRT2 = 1.41421356237309504880168872420969807856967_dp REAL ( kind = dp ), PARAMETER , public :: SQ4PI_INV = 0.2820947917738781434740397257803862929220_dp REAL ( kind = dp ), PARAMETER , public :: TWOTHIRD = 0.6666666666666666666666666666666666666666_dp real ( kind = DP ), parameter , public :: RAD2DEG = 18 0.0_DP / PI real ( kind = DP ), parameter , public :: DEG2RAD = PI / 18 0.0_DP real ( kind = SP ), parameter , public :: hpx_sbadval = - 1.6375e30_sp real ( kind = DP ), parameter , public :: hpx_dbadval = - 1.6375e30_dp ! Maximum length of filenames integer , parameter :: filenamelen = 1024 ! ---- Normalisation and convention ---- ! normalisation of spin weighted functions real ( kind = dp ), parameter , public :: KvS = 1.0_dp ! 1.0 : CMBFAST (Healpix 1.2) ! sign of Q real ( kind = dp ), parameter , public :: sgQ = - 1.0_dp ! -1 : CMBFAST (Healpix 1.2) ! sign of spin weighted function ! real ( kind = dp ), parameter , public :: SW1 = - 1.0_dp ! -1 : Healpix 1.2, bug correction real ( kind = dp ), parameter , public :: iKvS = 1.0_dp / KvS ! inverse of KvS !parameters for 3DPDR real ( kind = dp ), parameter , public :: KB = 1.38065040D-16 !Boltzmann constant cgs real ( kind = dp ), parameter , public :: C = 2.99792458D+10 !speed of light cgs real ( kind = dp ), parameter , public :: MP = 1.67262164D-24 !proton mass cgs real ( kind = dp ), parameter , public :: HP = 6.62606896D-27 !Planck's constant cgs real ( kind = dp ), parameter , public :: HB = 1.05457163D-27 !Planck's constant / 2pi real ( kind = dp ), parameter , public :: HK = 4.79923734D-11 !Planck's constant / Boltzmann constant real ( kind = dp ), parameter , public :: NA = 6.02214179D+23 !Avogadro's number real ( kind = dp ), parameter , public :: AU = 1.66053878D-24 !atomic mass unit real ( kind = dp ), parameter , public :: MH = 1.67372346D-24 !hydrogen mass cgs real ( kind = dp ), parameter , public :: ME = 9.10938215D-28 !electron mass cgs real ( kind = dp ), parameter , public :: EC = 4.80320427D-10 !elementary charge in esu real ( kind = dp ), parameter , public :: PC = 3.08568025D+18 !pc in cm real ( kind = dp ), parameter , public :: EV = 1.60217646D-12 !electron volt in erg END MODULE healpix_types","tags":"","url":"sourcefile/healpix_types.f90.html"},{"title":"columndensity.F90 – 3D-PDR","text":"This file depends on sourcefile~~columndensity.f90~~EfferentGraph sourcefile~columndensity.f90 columndensity.F90 sourcefile~healpix_types.f90 healpix_types.F90 sourcefile~columndensity.f90->sourcefile~healpix_types.f90 sourcefile~m_ray_box.f90 m_Ray_box.F90 sourcefile~columndensity.f90->sourcefile~m_ray_box.f90 sourcefile~modules.f90 modules.F90 sourcefile~columndensity.f90->sourcefile~modules.f90 sourcefile~definitions.f90 definitions.F90 sourcefile~healpix_types.f90->sourcefile~definitions.f90 sourcefile~m_mesh.f90 m_Mesh.F90 sourcefile~m_ray_box.f90->sourcefile~m_mesh.f90 sourcefile~modules.f90->sourcefile~healpix_types.f90 sourcefile~modules.f90->sourcefile~definitions.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code subroutine calc_columndens use healpix_types use maincode_module use global_module use m_Ray_box !calculation of column density !T.Bisbas #ifdef RAYTHEIA_MO #ifdef OPENMP !$OMP PARALLEL DO DEFAULT(SHARED) SCHEDULE(GUIDED) PRIVATE(p,adaptive_step,j,i,k) & !$OMP PRIVATE(thfpix,phfpix,ray,box1,epray,projected,plength) #endif #else #ifdef OPENMP !$OMP PARALLEL DO DEFAULT(SHARED) SCHEDULE(GUIDED) PRIVATE(p,adaptive_step,j,i,k) #endif #endif do p = 1 , pdr_ptot #ifdef THERMALBALANCE if ( pdr ( p )% fullyconverged ) cycle #endif #ifdef RAYTHEIA_MO box1 % min = corner_min box1 % max = corner_max epray = 0 projected = p plength = 0.D0 do j = 0 , nrays - 1 call pix2ang_nest ( nside , j , thfpix , phfpix ) ray % origin = [ pdr ( p )% x , pdr ( p )% y , pdr ( p )% z ] ray % angle = [ thfpix , phfpix ] call raytheia ( ray , box1 , levels - 1 , j , epray , projected , plength ) enddo #else pdr ( p )% projected (:, 0 ) = p #endif if ( referee . eq . 0 ) then allocate ( pdr ( p )% column_NH2 ( 0 : nrays - 1 )) allocate ( pdr ( p )% column_NHD ( 0 : nrays - 1 )) allocate ( pdr ( p )% column_NCO ( 0 : nrays - 1 )) allocate ( pdr ( p )% column_NC ( 0 : nrays - 1 )) allocate ( pdr ( p )% column_NS ( 0 : nrays - 1 )) endif pdr ( p )% column_NH2 = 0.0D0 pdr ( p )% column_NHD = 0.0D0 pdr ( p )% column_NCO = 0.0D0 pdr ( p )% column_NC = 0.0D0 pdr ( p )% column_NS = 0.0D0 do j = 0 , nrays - 1 #ifdef RAYTHEIA_MO if ( epray ( j ). eq . 0 ) cycle do i = 1 , epray ( j ) adaptive_step = plength ( j , i ) do k = 1 , nspec if ( k . eq . NH2 ) pdr ( p )% column_NH2 ( j ) = pdr ( p )% column_NH2 ( j ) + adaptive_step * PC * & & pdr ( int ( projected ( j , i )))% rho * pdr ( int ( projected ( j , i )))% abundance ( k ) if ( k . eq . NHD ) pdr ( p )% column_NHD ( j ) = pdr ( p )% column_NHD ( j ) + adaptive_step * PC * & & pdr ( int ( projected ( j , i )))% rho * pdr ( int ( projected ( j , i )))% abundance ( k ) if ( k . eq . NCO ) pdr ( p )% column_NCO ( j ) = pdr ( p )% column_NCO ( j ) + adaptive_step * PC * & & pdr ( int ( projected ( j , i )))% rho * pdr ( int ( projected ( j , i )))% abundance ( k ) if ( k . eq . NC ) pdr ( p )% column_NC ( j ) = pdr ( p )% column_NC ( j ) + adaptive_step * PC * & & pdr ( int ( projected ( j , i )))% rho * pdr ( int ( projected ( j , i )))% abundance ( k ) if ( k . eq . NS ) pdr ( p )% column_NS ( j ) = pdr ( p )% column_NS ( j ) + adaptive_step * PC * & & pdr ( int ( projected ( j , i )))% rho * pdr ( int ( projected ( j , i )))% abundance ( k ) enddo ! End of loop over species (n) enddo #else if ( pdr ( p )% epray ( j ). eq . 0 ) cycle do i = 1 , pdr ( p )% epray ( j ) !nb_projected_points #ifdef RAYTHEIA adaptive_step = pdr ( p )% length ( j , i ) do k = 1 , nspec if ( k . eq . NH2 ) pdr ( p )% column_NH2 ( j ) = pdr ( p )% column_NH2 ( j ) + adaptive_step * PC * & & pdr ( int ( projected ( j , i )))% rho * pdr ( int ( projected ( j , i )))% abundance ( k ) if ( k . eq . NHD ) pdr ( p )% column_NHD ( j ) = pdr ( p )% column_NHD ( j ) + adaptive_step * PC * & & pdr ( int ( projected ( j , i )))% rho * pdr ( int ( projected ( j , i )))% abundance ( k ) if ( k . eq . NCO ) pdr ( p )% column_NCO ( j ) = pdr ( p )% column_NCO ( j ) + adaptive_step * PC * & & pdr ( int ( projected ( j , i )))% rho * pdr ( int ( projected ( j , i )))% abundance ( k ) if ( k . eq . NC ) pdr ( p )% column_NC ( j ) = pdr ( p )% column_NC ( j ) + adaptive_step * PC * & & pdr ( int ( projected ( j , i )))% rho * pdr ( int ( projected ( j , i )))% abundance ( k ) if ( k . eq . NS ) pdr ( p )% column_NS ( j ) = pdr ( p )% column_NS ( j ) + adaptive_step * PC * & & pdr ( int ( projected ( j , i )))% rho * pdr ( int ( projected ( j , i )))% abundance ( k ) enddo ! End of loop over species (n) #else adaptive_step = sqrt (( pdr ( p )% epoint ( 1 , j , i - 1 ) - pdr ( p )% epoint ( 1 , j , i )) ** 2 + & &( pdr ( p )% epoint ( 2 , j , i - 1 ) - pdr ( p )% epoint ( 2 , j , i )) ** 2 + & &( pdr ( p )% epoint ( 3 , j , i - 1 ) - pdr ( p )% epoint ( 3 , j , i )) ** 2 ) do k = 1 , nspec if ( k . eq . NH2 ) pdr ( p )% column_NH2 ( j ) = pdr ( p )% column_NH2 ( j ) + adaptive_step * PC * & & ( pdr ( int ( pdr ( p )% projected ( j , i - 1 )))% rho * pdr ( int ( pdr ( p )% projected ( j , i - 1 )))% abundance ( k ) + & & pdr ( int ( pdr ( p )% projected ( j , i )))% rho * pdr ( int ( pdr ( p )% projected ( j , i )))% abundance ( k )) / 2. if ( k . eq . NHD ) pdr ( p )% column_NHD ( j ) = pdr ( p )% column_NHD ( j ) + adaptive_step * PC * & & ( pdr ( int ( pdr ( p )% projected ( j , i - 1 )))% rho * pdr ( int ( pdr ( p )% projected ( j , i - 1 )))% abundance ( k ) + & & pdr ( int ( pdr ( p )% projected ( j , i )))% rho * pdr ( int ( pdr ( p )% projected ( j , i )))% abundance ( k )) / 2. if ( k . eq . NCO ) pdr ( p )% column_NCO ( j ) = pdr ( p )% column_NCO ( j ) + adaptive_step * PC * & & ( pdr ( int ( pdr ( p )% projected ( j , i - 1 )))% rho * pdr ( int ( pdr ( p )% projected ( j , i - 1 )))% abundance ( k ) + & & pdr ( int ( pdr ( p )% projected ( j , i )))% rho * pdr ( int ( pdr ( p )% projected ( j , i )))% abundance ( k )) / 2. if ( k . eq . NC ) pdr ( p )% column_NC ( j ) = pdr ( p )% column_NC ( j ) + adaptive_step * PC * & & ( pdr ( int ( pdr ( p )% projected ( j , i - 1 )))% rho * pdr ( int ( pdr ( p )% projected ( j , i - 1 )))% abundance ( k ) + & & pdr ( int ( pdr ( p )% projected ( j , i )))% rho * pdr ( int ( pdr ( p )% projected ( j , i )))% abundance ( k )) / 2. if ( k . eq . NS ) pdr ( p )% column_NS ( j ) = pdr ( p )% column_NS ( j ) + adaptive_step * PC * & & ( pdr ( int ( pdr ( p )% projected ( j , i - 1 )))% rho * pdr ( int ( pdr ( p )% projected ( j , i - 1 )))% abundance ( k ) + & & pdr ( int ( pdr ( p )% projected ( j , i )))% rho * pdr ( int ( pdr ( p )% projected ( j , i )))% abundance ( k )) / 2. enddo ! End of loop over species (n) #endif enddo ! End of loop over evaluation points along ray (i) #endif enddo ! End of j loop over rays (j) enddo ! End of ii loop over pdr (ii) #ifdef OPENMP !$OMP END PARALLEL DO #endif return end subroutine calc_columndens","tags":"","url":"sourcefile/columndensity.f90.html"},{"title":"healpix_types.F90 – 3D-PDR","text":"Source Code !----------------------------------------------------------------------------- ! !  Copyright (C) 1997-2008 Krzysztof M. Gorski, Eric Hivon, !                          Benjamin D. Wandelt, Anthony J. Banday, !                          Matthias Bartelmann, Hans K. Eriksen, !                          Frode K. Hansen, Martin Reinecke ! ! !  This file is part of HEALPix. ! !  HEALPix is free software; you can redistribute it and/or modify !  it under the terms of the GNU General Public License as published by !  the Free Software Foundation; either version 2 of the License, or !  (at your option) any later version. ! !  HEALPix is distributed in the hope that it will be useful, !  but WITHOUT ANY WARRANTY; without even the implied warranty of !  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !  GNU General Public License for more details. ! !  You should have received a copy of the GNU General Public License !  along with HEALPix; if not, write to the Free Software !  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA ! !  For more information about HEALPix see http://healpix.jpl.nasa.gov ! !----------------------------------------------------------------------------- MODULE healpix_types ! This module sets the types used in the Fortran 90 modules ! of the HEALPIX distribution and follows the example of Numerical Recipes ! ! Benjamin D. Wandelt October 1997 ! Eric Hivon June 1998 ! Eric Hivon Oct  2001, edited to be compatible with 'F' compiler ! Eric Hivon July 2002, addition of i8b, i2b, i1b !                       addition of max_i8b, max_i2b and max_i1b !            Jan 2005, explicit form of max_i1b because of ifc 8.1.021 !            June 2005, redefine i8b as 16 digit integer because of Nec f90 compiler !            Mars 2008: i8b same as i4b on machines not supporting 64 bits (NO64BITS flag set) !            Feb  2009: introduce healpix_version ! character ( len =* ), PARAMETER , public :: healpix_version = '2.12a' INTEGER , PARAMETER , public :: i4b = SELECTED_INT_KIND ( 9 ) #ifdef NO64BITS INTEGER , PARAMETER , public :: i8b = i4b #else INTEGER , PARAMETER , public :: i8b = SELECTED_INT_KIND ( 16 ) #endif INTEGER , PARAMETER , public :: i2b = SELECTED_INT_KIND ( 4 ) INTEGER , PARAMETER , public :: i1b = SELECTED_INT_KIND ( 2 ) INTEGER , PARAMETER , public :: sp = SELECTED_REAL_KIND ( 5 , 30 ) INTEGER , PARAMETER , public :: dp = SELECTED_REAL_KIND ( 12 , 200 ) INTEGER , PARAMETER , public :: lgt = KIND (. TRUE .) INTEGER , PARAMETER , public :: spc = KIND (( 1.0_sp , 1.0_sp )) INTEGER , PARAMETER , public :: dpc = KIND (( 1.0_dp , 1.0_dp )) ! INTEGER ( I8B ), PARAMETER , public :: max_i8b = HUGE ( 1_i8b ) INTEGER , PARAMETER , public :: max_i4b = HUGE ( 1_i4b ) INTEGER , PARAMETER , public :: max_i2b = HUGE ( 1_i2b ) INTEGER , PARAMETER , public :: max_i1b = 127 REAL ( kind = sp ), PARAMETER , public :: max_sp = HUGE ( 1.0_sp ) REAL ( kind = dp ), PARAMETER , public :: max_dp = HUGE ( 1.0_dp ) ! Numerical Constant (Double precision) REAL ( kind = dp ), PARAMETER , public :: QUARTPI = 0.785398163397448309615660845819875721049_dp REAL ( kind = dp ), PARAMETER , public :: HALFPI = 1.570796326794896619231321691639751442099_dp REAL ( kind = dp ), PARAMETER , public :: PI = 3.141592653589793238462643383279502884197_dp REAL ( kind = dp ), PARAMETER , public :: TWOPI = 6.283185307179586476925286766559005768394_dp REAL ( kind = dp ), PARAMETER , public :: FOURPI = 1 2.56637061435917295385057353311801153679_dp REAL ( kind = dp ), PARAMETER , public :: SQRT2 = 1.41421356237309504880168872420969807856967_dp REAL ( kind = dp ), PARAMETER , public :: EULER = 0.5772156649015328606065120900824024310422_dp REAL ( kind = dp ), PARAMETER , public :: SQ4PI_INV = 0.2820947917738781434740397257803862929220_dp REAL ( kind = dp ), PARAMETER , public :: TWOTHIRD = 0.6666666666666666666666666666666666666666_dp real ( kind = DP ), parameter , public :: RAD2DEG = 18 0.0_DP / PI real ( kind = DP ), parameter , public :: DEG2RAD = PI / 18 0.0_DP real ( kind = SP ), parameter , public :: hpx_sbadval = - 1.6375e30_sp real ( kind = DP ), parameter , public :: hpx_dbadval = - 1.6375e30_dp ! Maximum length of filenames integer , parameter :: filenamelen = 1024 !   ! ---- Normalisation and convention ---- ! normalisation of spin weighted functions real ( kind = dp ), parameter , public :: KvS = 1.0_dp ! 1.0 : CMBFAST (Healpix 1.2) !   ! sign of Q !   real(kind=dp), parameter, public :: sgQ = -1.0_dp ! -1 : CMBFAST (Healpix 1.2) !   ! sign of spin weighted function ! !   real(kind=dp), parameter, public :: SW1 = -1.0_dp ! -1 : Healpix 1.2, bug correction ! !  ! normalisation of spin weighted functions ! !  real(kind=dp), parameter, public ::  KvS = 2.0_dp ! 2.0 : KKS  (Healpix 1.1) ! !  ! sign of Q ! !  real(kind=dp), parameter, public :: sgQ = +1.0_dp ! +1 : KKS (Healpix 1.1) ! !  ! sign of spin weighted function ! ! !  real(kind=dp), parameter, public :: SW1 = +1.0_dp ! +1 : Healpix 1.1 !   real(kind=dp), parameter, public :: iKvS = 1.0_dp / KvS  ! inverse of KvS END MODULE healpix_types","tags":"","url":"sourcefile/healpix_types.f90~2.html"},{"title":"convert_fin2h5.F90 – 3D-PDR","text":"This file depends on sourcefile~~convert_fin2h5.f90~~EfferentGraph sourcefile~convert_fin2h5.f90 convert_fin2h5.F90 sourcefile~m_paramters.f90 m_paramters.F90 sourcefile~convert_fin2h5.f90->sourcefile~m_paramters.f90 sourcefile~m_visual.f90 m_visual.F90 sourcefile~convert_fin2h5.f90->sourcefile~m_visual.f90 sourcefile~m_writeoutputs.f90 m_writeoutputs.F90 sourcefile~convert_fin2h5.f90->sourcefile~m_writeoutputs.f90 sourcefile~m_visual.f90->sourcefile~m_paramters.f90 sourcefile~m_writeoutputs.f90->sourcefile~m_paramters.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program convert_fin2h5 use m_paramters use m_visual use m_writeoutputs implicit none integer :: pdr_ptot , unit integer :: i , j , k , II , JJ , KK , p , pp , ilevel , ico character ( len = 7 ) :: first_col logical :: file_exists pdr_ptot = nxc * nyc * nzc allocate ( pdr ( nxc , nyc , nzc )) do k = 1 , nzc do j = 1 , nyc do i = 1 , nxc allocate ( pdr ( i , j , k )% coolant ( 1 : coo )) allocate ( pdr ( i , j , k )% AV ( 0 : nrays - 1 )) allocate ( pdr ( i , j , k )% abundance ( 1 : nspec )) do ii = 1 , coo allocate ( pdr ( i , j , k )% cooling ( ii )) allocate ( pdr ( i , j , k )% coolant ( ii )% pop ( cnlev ( ii ))) enddo do ii = 1 , 12 allocate ( pdr ( i , j , k )% heating ( ii )) enddo enddo enddo enddo ! read fin fin_file = \"../\" // trim ( adjustl ( outname )) // \".pdr.fin\" inquire ( file = trim ( fin_file ), exist = file_exists ) if ( file_exists ) then open ( newunit = unit , file = fin_file , status = 'old' ) do i = 1 , nxc do j = 1 , nyc do k = 1 , nzc read ( unit , '(A7,5ES15.7,I5,300ES15.7)' ) first_col , pdr ( i , j , k )% x , pdr ( i , j , k )% y , pdr ( i , j , k )% z , pdr ( i , j , k )% Tgas , pdr ( i , j , k )% Tdust ,& & pdr ( i , j , k )% etype , pdr ( i , j , k )% rho , pdr ( i , j , k )% UVfield , pdr ( i , j , k )% abundance , pdr ( i , j , k )% AV enddo enddo enddo close ( unit ) endif fin_file = \"../\" // trim ( adjustl ( outname )) // \".cr.fin\" inquire ( file = trim ( fin_file ), exist = file_exists ) if ( file_exists ) then open ( newunit = unit , file = fin_file , status = 'old' ) do i = 1 , nxc do j = 1 , nyc do k = 1 , nzc read ( unit , '(ES15.7)' ) pdr ( i , j , k )% zetalocal enddo enddo enddo close ( unit ) endif fin_file = \"../\" // trim ( adjustl ( outname )) // trim ( adjustl ( \".cool\" )) // \".fin\" inquire ( file = trim ( fin_file ), exist = file_exists ) if ( file_exists ) then open ( newunit = unit , file = fin_file , status = 'old' ) do i = 1 , nxc do j = 1 , nyc do k = 1 , nzc read ( unit , '(A7,200ES15.7)' ) first_col , pdr ( i , j , k )% x , pdr ( i , j , k )% y , pdr ( i , j , k )% z , pdr ( i , j , k )% cooling (:), pdr ( i , j , k )% totalcooling , pdr ( i , j , k )% AV (:) enddo enddo enddo close ( unit ) endif fin_file = \"../\" // trim ( adjustl ( outname )) // trim ( adjustl ( \".heat\" )) // \".fin\" inquire ( file = trim ( fin_file ), exist = file_exists ) if ( file_exists ) then open ( newunit = unit , file = fin_file , status = 'old' ) do i = 1 , nxc do j = 1 , nyc do k = 1 , nzc read ( unit , '(A7,200ES15.7)' ) first_col , pdr ( i , j , k )% x , pdr ( i , j , k )% y , pdr ( i , j , k )% z , pdr ( i , j , k )% heating , pdr ( i , j , k )% AV enddo enddo enddo close ( unit ) endif fin_file = \"../\" // trim ( adjustl ( outname )) // trim ( adjustl ( \".RTspop\" )) // \".fin\" inquire ( file = trim ( fin_file ), exist = file_exists ) if ( file_exists ) then open ( newunit = unit , file = fin_file , status = 'old' ) ico = 0 do read ( unit , '(A)' ) cfile cfile = trim ( adjustl ( cfile )) if ( cfile == 'ENDCOOLFILES' ) exit ico = ico + 1 coolfile ( ico ) = cfile enddo ! print*,coolfile do i = 1 , nxc do j = 1 , nyc do k = 1 , nzc do ico = 1 , coo read ( unit , '(100ES15.7)' , advance = 'no' ) pdr ( i , j , k )% coolant ( ico )% pop ( 1 : cnlev ( ico )) end do read ( unit , * ) enddo enddo enddo close ( unit ) endif fin_file = \"../\" // trim ( adjustl ( outname )) // trim ( adjustl ( \".velocity\" )) // \".dat\" inquire ( file = trim ( fin_file ), exist = file_exists ) if ( file_exists ) then open ( newunit = unit , file = fin_file , status = 'old' ) do i = 1 , nxc do j = 1 , nyc do k = 1 , nzc read ( unit , * ) pdr ( i , j , k )% vx , pdr ( i , j , k )% vy , pdr ( i , j , k )% vz enddo enddo enddo close ( unit ) endif print * , 'Finish reading fin' ! write h5 call writeoutputs print * , 'Finish writing h5' ! write xmf dx = xlx / real ( nxc , kind = RK ) dy = yly / real ( nyc , kind = RK ) dz = zlz / real ( nzc , kind = RK ) call initvisual ! print*,pdr(nxc,nyc,nzc-1)%coolant(4)%pop(cnlev(4)-1) print * , 'Done' end program convert_fin2h5","tags":"","url":"sourcefile/convert_fin2h5.f90.html"},{"title":"shield.F90 – 3D-PDR","text":"This file depends on sourcefile~~shield.f90~~EfferentGraph sourcefile~shield.f90 shield.F90 sourcefile~definitions.f90 definitions.F90 sourcefile~shield.f90->sourcefile~definitions.f90 sourcefile~healpix_types.f90 healpix_types.F90 sourcefile~shield.f90->sourcefile~healpix_types.f90 sourcefile~modules.f90 modules.F90 sourcefile~shield.f90->sourcefile~modules.f90 sourcefile~healpix_types.f90->sourcefile~definitions.f90 sourcefile~modules.f90->sourcefile~definitions.f90 sourcefile~modules.f90->sourcefile~healpix_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !C======================================================================= !C !C     H2 photodissociation rate taking into account !C     self-shielding and grain extinction !C !C----------------------------------------------------------------------- !C !C     Input parameters: !C     K0  = Unattenuated photodissociation rate (in cm&#94;3/s) !C     G0  = Incident FUV field (in Draine units) !C     AV  = visual extinction (in magnitudes) !C     NH2 = H2 column density (in cm&#94;-2) !C !C     Program variables: !C     H2PDRATE = H2 photodissociation rate taking into !C                account self-shielding and grain extinction !C     DOPW     = Doppler linewidth (in Hz) of a typical transition !C                (assuming turbulent broadening with b=3 km/s) !C     RADW     = radiative linewidth (in Hz) of a typical transition !C     LAMBDA   = wavelength (in Å) of a typical transition !C !C     Functions called: !C     H2SHIELD = H2 self-shielding function !C     S!CATTER  = attenuation due to scattering by dust !C !C----------------------------------------------------------------------- FUNCTION H2PDRATE ( K0 , G0 , AV , NH2 ) !      IMPLICIT NONE !      real(kind=dp) :: K0,G0,AV,NH2 !      real(kind=dp) :: LAMBDA,SCATTER !!C      DOUBLE PRECISION DOPW,RADW !!C      DOUBLE PRECISION H2SHIELD1 !      real(kind=dp) :: H2SHIELD2 use definitions use healpix_types use maincode_module , only : v_turb !     use global_module, only : nh2 implicit none real ( kind = dp ) :: H2PDRATE real ( kind = dp ), intent ( in ) :: k0 , g0 , av !     integer(kind=i4b), intent(in) :: nh2 real ( kind = dp ), intent ( in ) :: nh2 real ( kind = dp ) :: lambda , scatter !, h2shield2 real ( kind = dp ) :: dopw , radw , h2shield1 LAMBDA = 100 0.0D0 DOPW = V_TURB / ( LAMBDA * 1.0D-8 ) RADW = 8.0D7 !     Calculate the H2 photodissociation rate (H2PDRATE) H2PDRATE = K0 * G0 * H2SHIELD1 ( NH2 , DOPW , RADW ) * SCATTER ( AV , LAMBDA ) !/2.0 !      H2PDRATE=K0*G0*H2SHIELD2(NH2)*SCATTER(AV,LAMBDA)/2.0 RETURN END !C======================================================================= !C======================================================================= !C !C     !CO photodissociation rate taking into !C     account shielding and grain extinction !C !C----------------------------------------------------------------------- !C !C     Input parameters: !C     K0  = Unattenuated photodissociation rate (in cm&#94;3/s) !C     G0  = Incident FUV field (in Draine units) !C     AV  = visual extinction (in magnitudes) !C     N!CO = !CO column density (in cm&#94;-2) !C     NH2 = H2 column density (in cm&#94;-2) !C !C     Program variables: !C     !COPDRATE = !CO photodissociation rate taking into !C                account self-shielding and grain extinction !C     LAMBDA   = wavelength (in Å) of a typical transition !C !C     Functions called: !C     LBAR     = function to determine the wavelength !C     !COSHIELD = !CO shielding function !C     S!CATTER  = attenuation due to scattering by dust !C !C----------------------------------------------------------------------- FUNCTION COPDRATE ( K0 , G0 , AV , NCO , NH2 ) !      IMPLICIT NONE !      real(kind=dp) :: K0,G0,AV,NCO,NH2 !      real(kind=dp) :: LAMBDA,LBAR !      real(kind=dp) :: COSHIELD,SCATTER use definitions use healpix_types !     use global_module, only : nh2 implicit none real ( kind = dp ) :: copdrate real ( kind = dp ), intent ( in ) :: k0 , g0 , av , nco !     integer(kind=i4b), intent(in) :: nh2 real ( kind = dp ), intent ( in ) :: nh2 real ( kind = dp ) :: lambda , lbar , coshield , scatter LAMBDA = LBAR ( NCO , NH2 ) !C     Calculate the CO photodissociation rate (COPDRATE) COPDRATE = K0 * G0 * COSHIELD ( NCO , NH2 ) * SCATTER ( AV , LAMBDA ) RETURN END !C======================================================================= !C======================================================================= !C !C     !CI photoionization rate taking into account grain extinction !C     and shielding by !CI and H2 lines, adopting the treatment of !C     Kamp & Bertoldi (2000, A&A, 353, 276, Equation 8) !C !C----------------------------------------------------------------------- !C !C     Input parameters: !C     K0   = Unattenuated photoionization rate (in cm&#94;3/s) !C     G0   = Incident FUV field (in Draine units) !C     AV   = visual extinction (in magnitudes) !C     KAV  = tau(λ)/tau(V) correction factor !C     N!CI  = !CI column density (in cm&#94;-2) !C     NH2  = H2 column density (in cm&#94;-2) !C     TGAS = gas temperature (in K) !C !C     Program variables: !C     !CIPDRATE = !CI photoionization rate taking into !C                account shielding and grain extinction !C     TAU!C     = optical depth in the !CI absorption band !C !C----------------------------------------------------------------------- FUNCTION CIPDRATE ( K0 , G0 , AV , KAV , NCI , NH2 , TGAS ) !      IMPLICIT NONE !      real(kind=dp) :: K0,G0,AV,KAV,NCI,NH2,TGAS !      real(kind=dp) :: TAUC use definitions use healpix_types !     use global_module, only : nh2 implicit none real ( kind = dp ) :: cipdrate real ( kind = dp ), intent ( in ) :: K0 , G0 , AV , KAV , NCI , TGAS !     integer(kind=i4b), intent(in) :: nh2 real ( kind = dp ), intent ( in ) :: nh2 real ( kind = dp ) :: tauc !C     !Calculate the optical depth in the !CI absorption band, accounting !C     for grain extinction and shielding by !CI and overlapping H2 lines TAUC = KAV * AV + 1.1D-17 * NCI + ( 0.9D0 * TGAS ** 0.27D0 * ( NH2 / 1.59D21 ) ** 0.45D0 ) !C     Calculate the CI photoionization rate (CIPDRATE) CIPDRATE = K0 * G0 * EXP ( - TAUC ) !/2.0 RETURN END !C======================================================================= !C======================================================================= !C !C     SI photoionization rate -- needs to be implemented! !C     For now, use the standard expression for photorates !C !C----------------------------------------------------------------------- !C !C     Input parameters: !C     K0   = Unattenuated photoionization rate (in cm&#94;3/s) !C     G0   = Incident FUV field (in Draine units) !C     AV   = visual extinction (in magnitudes) !C     KAV  = tau(λ)/tau(V) correction factor !C     NSI  = SI column density (in cm&#94;-2) !C !C     Program variables: !C     SIPDRATE = SI photoionization rate taking into !C                account shielding and grain extinction !C     TAUS     = optical depth in the SI absorption band !C !C----------------------------------------------------------------------- FUNCTION SIPDRATE ( K0 , G0 , AV , KAV ) !,NSI) !      IMPLICIT NONE !      real(kind=dp) K0,G0,AV,KAV,NSI !      real(kind=dp) TAUS use definitions use healpix_types implicit none real ( kind = dp ) :: sipdrate real ( kind = dp ), intent ( in ) :: K0 , G0 , AV , KAV !,NSI real ( kind = dp ) :: taus !C     Calculate the optical depth in the SI absorption band, accounting !C     for grain extinction and shielding by ??? TAUS = KAV * AV !C     Calculate the SI photoionization rate (SIPDRATE) SIPDRATE = K0 * G0 * EXP ( - TAUS ) / 2.0 RETURN END !C======================================================================= !C======================================================================= !C !C     H2 line self-shielding, adopting the treatment of !C     Federman, Glassgold & Kwan (1979, ApJ, 227, 466) !C !C----------------------------------------------------------------------- !C !C     Input parameters: !C     NH2  = H2 column density (in cm&#94;-2) !C     DOPW = Doppler linewidth (in Hz) !C     RADW = radiative linewidth (in Hz) !C !C     Program variables: !C     H2SHIELD1 = total self-shielding function containing !C                 both Doppler and radiative contributions !C     FPARA     = fraction of H2 in para state: 1/(1+o/p ratio) !C     FOS!C      = oscillator strength of a typical transition !C     TAUD      = parameter tauD (eq. A7) in Federman's paper !C                 (optical depth at line centre) !C     R         = parameter r  (eq. A2) in Federman's paper !C     T         = parameter t1 (eq. A6) in Federman's paper !C     U         = parameter u1 (eq. A6) in Federman's paper !C     JD        = parameter JD (eq. A8) in Federman's paper !C                 (Doppler contribution to self-shielding) !C     JR        = parameter JR (eq. A9) in Federman's paper !C                (radiative contribution to self-shielding) !C !C----------------------------------------------------------------------- FUNCTION H2SHIELD1 ( NH2 , DOPW , RADW ) !      IMPLICIT NONE !      real(kind=dp) ::  NH2,DOPW,RADW !      real(kind=dp) ::  FPARA,FOSC,TAUD !      real(kind=dp) ::  R,T,U,JD,JR use definitions use healpix_types !     use global_module, only : nh2 implicit none real ( kind = dp ) :: h2shield1 !     integer(kind=i4b), intent(in) :: nh2 real ( kind = dp ), intent ( in ) :: nh2 real ( kind = dp ), intent ( in ) :: DOPW , RADW real ( kind = dp ) :: FPARA , FOSC , TAUD , R , T , U , JD , JR !C     Calculate the optical depth at line centre = N(H2)*f_para*(πe&#94;2/mc)*f/(√πß) ≈ N(H2)*f_para*(1.5E-2)*f/ß FPARA = 0.5D0 ! (assume o/p ratio=1) FOSC = 1.0D-2 TAUD = NH2 * FPARA * ( 1.497358985D-2 ) * FOSC / DOPW !C     Calculate the Doppler core contribution to the self-shielding (JD) IF ( TAUD . EQ . 0.0D0 ) THEN JD = 1.0D0 ELSE IF ( TAUD . LT . 2.0D0 ) THEN JD = EXP ( - ( 0.666666667D0 * TAUD )) ELSE IF ( TAUD . LT . 1 0.0D0 ) THEN JD = 0.638D0 * TAUD ** ( - 1.25D0 ) ELSE IF ( TAUD . LT . 10 0.0D0 ) THEN JD = 0.505D0 * TAUD ** ( - 1.15D0 ) ELSE JD = 0.344D0 * TAUD ** ( - 1.0667D0 ) ENDIF !C     Calculate the radiative wing contribution to self-shielding (JR) IF ( RADW . EQ . 0.0D0 ) THEN JR = 0.0D0 ELSE R = RADW / ( 1.772453851D0 * DOPW ) T = 3.02D0 * (( R * 1.0D3 ) ** ( - 0.064D0 )) U = SQRT ( TAUD * R ) / T JR = R / ( T * SQRT ( 0.785398163D0 + U ** 2 )) ENDIF !C     Calculate the total self-shielding function (H2SHIELD1) H2SHIELD1 = JD + JR RETURN END !C======================================================================= !C======================================================================= !C !C     H2 line shielding, using the computed values listed in !C     Lee et al. (1996, A&A, 311, 690, Table 10) !C !C----------------------------------------------------------------------- !C !C     Input parameters: !C     NH2 = H2 column density (in cm&#94;-2) !C !C     Program variables: !C     H2SHIELD2 = total H2 shielding factor containing !C                 contributions from both H2 and H lines !C                 from spline interpolation over the grid !C     SH2_GRID  = H2 shielding factors from Lee et al. (1996) !C                 as a function of H2 column density !C     SH2_DERIV = 2nd derivative of SH2_GRID values from SPLINE !C     !COL_GRID  = H2 column densities (in cm&#94;-2) !C     NUMH2     = number of entries in the table !C     START     = .TRUE. when H2SHIELD2 is first called !C !C     Functions called: !C     SPLINE = !C     SPLINT = !C !C----------------------------------------------------------------------- FUNCTION H2SHIELD2 ( NH2 ) !      IMPLICIT NONE !      LOGICAL :: START !      INTEGER(kind=i4b) :: NUMH2 !      real(kind=dp) ::  NH2 !      real(kind=dp) ::  COL_GRID(105),SH2_GRID(105),SH2_DERIV(105) !      COMMON /STATUS/START !      COMMON /H2GRID/SH2_GRID,SH2_DERIV,COL_GRID,NUMH2 use definitions use healpix_types use uclpdr_module , only : start , numh2 , COL_GRID , SH2_GRID , SH2_DERIV !     use global_module, only : nh2 implicit none real ( kind = dp ) :: h2shield2 !     integer(kind=i4b), intent(in) :: nh2 real ( kind = dp ), intent ( inout ) :: nh2 IF ( START ) CALL SPLINE ( COL_GRID , SH2_GRID , NUMH2 , & & 1.0D30 , 1.0D30 , SH2_DERIV ) IF ( NH2 . LT . COL_GRID ( 1 )) NH2 = COL_GRID ( 1 ) IF ( NH2 . GT . COL_GRID ( NUMH2 )) NH2 = COL_GRID ( NUMH2 ) CALL SPLINT ( COL_GRID , SH2_GRID , SH2_DERIV , NUMH2 , NH2 , H2SHIELD2 ) IF ( H2SHIELD2 . LT . 0.0D0 ) H2SHIELD2 = 0.0D0 RETURN END !C======================================================================= !C======================================================================= !C !C     12!CO line shielding, using the computed values listed in !C     van Dishoeck & Black (1988, ApJ, 334, 771, Table 5) !C !C     Appropriate shielding factors are determined by performing a !C     2-dimensional spline interpolation over the values listed in !C     Table 5 of van Dishoeck & Black, which include contributions !C     from self-shielding and H2 screening !C !C----------------------------------------------------------------------- !C !C     Input parameters: !C     N!CO = !CO column density (in cm&#94;-2) !C     NH2 = H2 column density (in cm&#94;-2) !C !C     Program variables: !C     !COSHIELD  = total 12!CO shielding factor containing !C                 contributions from both H2 and !CO lines !C                 from 2D spline interpolation over the grid !C     S!CO_GRID  = log10 values of the 12!CO shielding factors !C                 from van Dishoeck & Black (1988) as a function !C                 of !CO column density (1st index) and H2 column !C                 density (2nd index) !C     S!CO_DERIV = 2nd derivative of S!CO_GRID values from SPLIE2 !C     N!CO_GRID  = log10 values of !CO column densities (in cm&#94;-2) !C     NH2_GRID  = log10 values of H2 column densities (in cm&#94;-2) !C     DIM!CO     = number of !CO column densities !C     DIMH2     = number of H2 column densities !C     START     = .TRUE. when !COSHIELD is first called !C !C     Functions called: !C     SPLIE2 = !C     SPLIN2 = !C !C----------------------------------------------------------------------- FUNCTION COSHIELD ( NCO , NH2 ) !      IMPLICIT NONE !      LOGICAL :: START !      INTEGER(kind=i4b) :: DIMCO,DIMH2 !      real(kind=dp) ::  NCO,NH2 !      real(kind=dp) ::  LOGNCO,LOGNH2 !      real(kind=dp) ::  NCO_GRID(8),NH2_GRID(6) !      real(kind=dp) ::  SCO_GRID(8,6),SCO_DERIV(8,6) !      COMMON /STATUS/START !      COMMON /COGRID/SCO_GRID,SCO_DERIV,NCO_GRID,NH2_GRID,DIMCO,DIMH2 use definitions use healpix_types !     use global_module, only : NCO, NH2 use uclpdr_module , only : start , NCO_GRID , NH2_GRID , SCO_GRID , & & DIMCO , SCO_DERIV , DIMH2 , SCO_DERIV implicit none real ( kind = dp ) :: COSHIELD real ( kind = dp ) :: LOGNCO , LOGNH2 !     integer(kind=i4b), intent(in) :: NCO, NH2 real ( kind = dp ), intent ( in ) :: nh2 , nco IF ( START ) THEN CALL SPLIE2 ( NCO_GRID , NH2_GRID , SCO_GRID , DIMCO , DIMH2 , SCO_DERIV ) START = . FALSE . ENDIF LOGNCO = DLOG10 ( NCO + 1.0D0 ) LOGNH2 = DLOG10 ( NH2 + 1.0D0 ) IF ( LOGNCO . LT . NCO_GRID ( 1 )) LOGNCO = NCO_GRID ( 1 ) IF ( LOGNH2 . LT . NH2_GRID ( 1 )) LOGNH2 = NH2_GRID ( 1 ) IF ( LOGNCO . GT . NCO_GRID ( DIMCO )) LOGNCO = NCO_GRID ( DIMCO ) IF ( LOGNH2 . GT . NH2_GRID ( DIMH2 )) LOGNH2 = NH2_GRID ( DIMH2 ) CALL SPLIN2 ( NCO_GRID , NH2_GRID , SCO_GRID , SCO_DERIV ,& & DIMCO , DIMH2 , LOGNCO , LOGNH2 , COSHIELD ) COSHIELD = 1 0.0D0 ** COSHIELD RETURN END !C======================================================================= !C======================================================================= !C !C     Scattering by dust grains, adopting the treatment of !C     Wagenblast & Hartquist (1989, MNRAS, 237, 1019) and !C     Flannery, Roberge & Rybicki (1980, ApJ, 236, 598) !C !C----------------------------------------------------------------------- !C !C     Input parameters: !C     AV     = visual extinction (in magnitudes) !C     LAMBDA = wavelength (in Å) of incident radiation !C !C     Program variables: !C     S!CATTER = attenuation factor describing the influence of !C               grain scattering on the FUV flux, dependening !C               on the total column density and wavelength of !C               light (assuming albedo=0.3 gscat=0.8) !C     TAUV    = optical depth at visual wavelength (λ=5500Å) !C     TAUL    = optical depth at wavelength LAMBDA !C     A(0)    = a(0)*exp(-k(0)*tau) !C             = relative intensity decrease for 0 < tau < 1 !C     A(I)    = ∑ a(i)*exp(-k(i)*tau) for i=1,5 !C               relative intensity decrease for tau ≥ 1 !C     K(0)    = see A0 !C     K(I)    = see A(I) !C !C     Functions called: !C     XLAMBDA = function to determine tau(λ)/tau(V) !C !C----------------------------------------------------------------------- FUNCTION SCATTER ( AV , LAMBDA ) !      IMPLICIT NONE !      INTEGER(kind=i4b) :: I !      real(kind=dp) ::  AV,LAMBDA !      real(kind=dp) ::  TAUV,TAUL !      real(kind=dp) ::  A(0:5),K(0:5),EXPONENT !      real(kind=dp) ::  XLAMBDA !      DATA A/1.000D0,2.006D0,-1.438D0,0.7364D0,-0.5076D0,-0.0592D0/ !      DATA K/0.7514D0,0.8490D0,1.013D0,1.282D0,2.005D0,5.832D0/ use definitions use healpix_types implicit none real ( kind = dp ) :: scatter , LAMBDAVAR real ( kind = dp ), intent ( in ) :: AV , LAMBDA real ( kind = dp ), dimension ( 0 : 5 ), save :: A = ( / & & 1.000D0 , 2.006D0 , - 1.438D0 , 0.7364D0 , - 0.5076D0 , - 0.0592D0 / ) real ( kind = dp ), dimension ( 0 : 5 ), save :: K = ( / & & 0.7514D0 , 0.8490D0 , 1.013D0 , 1.282D0 , 2.005D0 , 5.832D0 / ) real ( kind = dp ) :: EXPONENT , XLAMBDA integer ( kind = i4b ) :: i real ( kind = dp ) :: TAUL , TAUV !C     Calculate the optical depth at visual wavelength TAUV = AV / 1.086D0 !C     Convert the optical depth to that at the desired wavelength LAMBDAVAR = LAMBDA TAUL = TAUV * XLAMBDA ( LAMBDAVAR ) !C     Calculate the attenuation due to scattering by dust (SCATTER) SCATTER = 0.0D0 IF ( TAUL . LT . 1.0D0 ) THEN EXPONENT = K ( 0 ) * TAUL IF ( EXPONENT . LT . 10 0.0D0 ) THEN SCATTER = A ( 0 ) * EXP ( - EXPONENT ) ENDIF ELSE DO I = 1 , 5 EXPONENT = K ( I ) * TAUL IF ( EXPONENT . LT . 10 0.0D0 ) THEN SCATTER = SCATTER + A ( I ) * EXP ( - EXPONENT ) ENDIF ENDDO ENDIF RETURN END !C======================================================================= !C======================================================================= !C !C     Determine the ratio of the optical depth at a given wavelength to !C     that at visual wavelength (λ=5500Å) using the extinction curve of !C     Savage & Mathis (1979, ARA&A, 17, 73, Table 2) !C !C----------------------------------------------------------------------- !C !C     Input parameters: !C     LAMBDA  = wavelength (in Å) !C !C     Program variables: !C     XLAMBDA = value of tau(λ)/tau(V) at the desired wavelength !C               (by spline interpolation over a table of values) !C     L_GRID  = wavelengths listed in Table 2 of Savage & Mathis !C     X_GRID  = tau(λ)/tau(V) values, determined by dividing the !C               Aλ/E(B-V) values in Table 2 by R=AV/E(B-V)=3.1 !C     X_DERIV = 2nd derivative of X_GRID values from SPLINE !C     N_GRID  = number of wavelengths !C !C     Functions called: !C     SPLIE = !C     SPLIN = !C !C----------------------------------------------------------------------- FUNCTION XLAMBDA ( LAMBDA ) !      IMPLICIT NONE !      LOGICAL :: START !      INTEGER(kind=i4b) ::  N_GRID !      real(kind=dp) ::  LAMBDA !      real(kind=dp) ::  L_GRID(30),X_GRID(30),X_DERIV(30) !      COMMON /STATUS/START !      COMMON /TAUGRID/L_GRID,X_GRID,X_DERIV,N_GRID use definitions use healpix_types use uclpdr_module , only : start , N_GRID , L_GRID , X_GRID , X_DERIV implicit none real ( kind = dp ) :: xlambda real ( kind = dp ), intent ( inout ) :: lambda !C     Find the appropriate value for XLAMBDA using spline interpolation IF ( START ) CALL SPLINE ( L_GRID , X_GRID , N_GRID , 1.0D30 , 1.0D30 , X_DERIV ) IF ( LAMBDA . LT . L_GRID ( 1 )) LAMBDA = L_GRID ( 1 ) IF ( LAMBDA . GT . L_GRID ( N_GRID )) LAMBDA = L_GRID ( N_GRID ) CALL SPLINT ( L_GRID , X_GRID , X_DERIV , N_GRID , LAMBDA , XLAMBDA ) RETURN END !C======================================================================= !C======================================================================= !C !C     !Calculate the mean wavelength (in Å) of the 33 dissociating bands, !C     weighted by their fractional contribution to the total shielding !C     van Dishoeck & Black (1988, ApJ, 334, 771, Equation 4) !C !C----------------------------------------------------------------------- !C !C     Input parameters: !C     N!CO = !CO column density (in cm&#94;-2) !C     NH2 = H2 column density (in cm&#94;-2) !C !C     Program variables: !C     LBAR = mean wavelength (in Å) !C     U    = log10(N!CO) !C     W    = log10(NH2) !C !C----------------------------------------------------------------------- FUNCTION LBAR ( NCO , NH2 ) !      IMPLICIT NONE !      real(kind=dp) ::  NCO,NH2 !      real(kind=dp) ::  U,W use definitions use healpix_types !     use global_module, only : NCO, NH2 implicit none real ( kind = dp ) :: lbar real ( kind = dp ) :: U , W !     integer(kind=i4b), intent(in) :: NCO, NH2 real ( kind = dp ), intent ( in ) :: nh2 , nco U = DLOG10 ( NCO + 1.0D0 ) W = DLOG10 ( NH2 + 1.0D0 ) LBAR = ( 567 5.0D0 - 20 0.6D0 * W ) & & - ( 57 1.6D0 - 2 4.09D0 * W ) * U & & + ( 1 8.22D0 - 0.7664D0 * W ) * U ** 2 !C     LBAR cannot be larger than the wavelength of band 33 (1076.1Å) !C     and cannot be smaller than the wavelength of band 1 (913.6Å) IF ( LBAR . LT . 91 3.6D0 ) LBAR = 91 3.6D0 IF ( LBAR . GT . 107 6.1D0 ) LBAR = 107 6.1D0 RETURN END !C=======================================================================","tags":"","url":"sourcefile/shield.f90.html"},{"title":"escape_probability.F90 – 3D-PDR","text":"This file depends on sourcefile~~escape_probability.f90~~EfferentGraph sourcefile~escape_probability.f90 escape_probability.F90 sourcefile~definitions.f90 definitions.F90 sourcefile~escape_probability.f90->sourcefile~definitions.f90 sourcefile~healpix_types.f90 healpix_types.F90 sourcefile~escape_probability.f90->sourcefile~healpix_types.f90 sourcefile~m_mesh.f90 m_Mesh.F90 sourcefile~escape_probability.f90->sourcefile~m_mesh.f90 sourcefile~m_ray_box.f90 m_Ray_box.F90 sourcefile~escape_probability.f90->sourcefile~m_ray_box.f90 sourcefile~modules.f90 modules.F90 sourcefile~escape_probability.f90->sourcefile~modules.f90 sourcefile~healpix_types.f90->sourcefile~definitions.f90 sourcefile~m_ray_box.f90->sourcefile~m_mesh.f90 sourcefile~modules.f90->sourcefile~definitions.f90 sourcefile~modules.f90->sourcefile~healpix_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code #ifdef RAYTHEIA_MO subroutine escape_probability ( transition , dust_temperature , nrays , nlev , & & A_COEFFS , B_COEFFS , C_COEFFS , & & frequencies , s_evalpop , maxpoints , Tguess , v_turb ,& & s_jjr , s_pop , weights , cooling_rate , line , density , metallicity , molmass , length ) #else #ifdef RAYTHEIA subroutine escape_probability ( transition , dust_temperature , nrays , nlev , & & A_COEFFS , B_COEFFS , C_COEFFS , & & frequencies , s_evalpop , maxpoints , Tguess , v_turb ,& & s_jjr , s_pop , weights , cooling_rate , line , density , metallicity , molmass , length ) #else subroutine escape_probability ( transition , dust_temperature , nrays , nlev , & & A_COEFFS , B_COEFFS , C_COEFFS , & & frequencies , s_evalpop , maxpoints , Tguess , v_turb ,& & s_jjr , s_pop , s_evalpoint , weights , cooling_rate , line , density , metallicity , molmass ) #endif #endif use definitions use healpix_types use healpix_module use maincode_module , only : Tcmb , nside , pdr use m_Mesh use m_Ray_box implicit none integer ( kind = i4b ), intent ( in ) :: nrays integer ( kind = i4b ), intent ( in ) :: nlev integer ( kind = i4b ), intent ( in ) :: maxpoints integer ( kind = i4b ), intent ( in ) :: s_jjr ( 0 : nrays - 1 ) real ( kind = dp ), intent ( inout ) :: transition ( 1 : nlev , 1 : nlev ) real ( kind = dp ), intent ( in ) :: A_COEFFS ( 1 : nlev , 1 : nlev ) real ( kind = dp ), intent ( in ) :: B_COEFFS ( 1 : nlev , 1 : nlev ) real ( kind = dp ), intent ( in ) :: C_COEFFS ( 1 : nlev , 1 : nlev ) real ( kind = dp ), intent ( in ) :: frequencies ( 1 : nlev , 1 : nlev ) real ( kind = dp ), intent ( in ) :: s_evalpop ( 0 : nrays - 1 , 0 : maxpoints , 1 : nlev ) #ifdef RAYTHEIA_MO real ( kind = dp ), intent ( in ) :: length ( 0 : nrays - 1 , 0 : maxpoints ) #else #ifdef RAYTHEIA real ( kind = dp ), intent ( in ) :: length ( 0 : nrays - 1 , 0 : maxpoints ) #else real ( kind = dp ), intent ( in ) :: s_evalpoint ( 1 : 3 , 0 : nrays - 1 , 0 : maxpoints ) #endif #endif real ( kind = dp ), intent ( in ) :: Tguess , v_turb real ( kind = dp ), intent ( in ) :: weights ( 1 : nlev ) real ( kind = dp ), intent ( in ) :: s_pop ( 1 : nlev ) real ( kind = dp ), intent ( in ) :: dust_temperature , density , metallicity real ( kind = dp ), intent ( in ) :: molmass integer ( kind = i4b ) :: i , j integer ( kind = i4b ) :: ilevel , jlevel real ( kind = dp ) :: beta_ij , beta_ij_sum real ( kind = dp ) :: frac1 , frac2 , frac3 , rhs2 real ( kind = dp ) :: tpop , tmp2 real ( kind = dp ) :: S_ij , BB_ij real ( kind = dp ) :: tau_increment real ( kind = dp ), allocatable :: tau_ij (:) real ( kind = dp ), allocatable :: field (:,:) real ( kind = dp ) :: beta_ij_ray ( 0 : nrays - 1 ) real ( kind = dp ), intent ( out ) :: line ( 1 : nlev , 1 : nlev ) real ( kind = dp ), intent ( out ) :: cooling_rate real ( kind = dp ) :: emissivity , bb_ij_dust , ngrain , rho_grain line = 0.0D0 cooling_rate = 0.0D0 allocate ( tau_ij ( 0 : nrays - 1 )) allocate ( field ( 1 : nlev , 1 : nlev )) field = 0.0D0 frac2 = 1.0D0 / sqrt ( 2.0 * KB * Tguess / MP / molmass + v_turb ** 2 ) do ilevel = 1 , nlev do jlevel = 1 , nlev !i>j if ( jlevel . ge . ilevel ) exit if ( A_COEFFS ( ilevel , jlevel ). eq . 0.0D0 ) cycle !if Aij=0 cycle tau_ij = 0.0D0 ; beta_ij = 0.0D0 ; beta_ij_ray = 0.0D0 ; beta_ij_sum = 0.0D0 frac1 = ( A_COEFFS ( ilevel , jlevel ) * ( C ** 3 )) / ( 8.0 * pi * ( frequencies ( ilevel , jlevel ) ** 3 )) TMP2 = 2.0D0 * HP * ( FREQUENCIES ( ilevel , jlevel ) ** 3 ) / ( C ** 2 ) BB_ij = TMP2 * ( 1.0D0 / ( EXP ( HP * frequencies ( ilevel , jlevel ) / KB / Tcmb ) - 1.0D0 )) NGRAIN = 2.0D-12 * density * metallicity !densityofgas depth depented rho_grain = 2.0D0 EMISSIVITY = ( RHO_GRAIN * NGRAIN ) * ( 0.01 * ( 1.3 * FREQUENCIES ( ilevel , jlevel ) / 3.0D11 )) BB_ij_dust = TMP2 * ( 1.0D0 / ( EXP ( HP * frequencies ( ilevel , jlevel ) / KB / DUST_TEMPERATURE ) - 1.D0 ) * EMISSIVITY ) BB_ij = BB_ij + BB_ij_dust if ( s_pop ( ilevel ). eq . 0 ) then S_ij = 0.0D0 beta_ij = 1.0D0 goto 2 endif TPOP = ( s_pop ( jlevel ) * WEIGHTS ( ilevel )) / ( s_pop ( ilevel ) * WEIGHTS ( jlevel )) - 1.0D0 IF ( abs ( TPOP ). lt . 1.0D-50 ) then S_ij = HP * FREQUENCIES ( ilevel , jlevel ) * s_pop ( ilevel ) * A_COEFFS ( ilevel , jlevel ) / 4. / pi beta_ij = 1.0D0 goto 1 else !calculation of source function (taken from UCL_PDR) S_ij = TMP2 / TPOP endif #ifdef RAYTHEIA_MO do j = 0 , nrays - 1 do i = 1 , s_jjr ( j ) frac3 = ( s_evalpop ( j , i , jlevel ) * weights ( ilevel ) - s_evalpop ( j , i , ilevel ) * weights ( jlevel )) / weights ( jlevel ) rhs2 = length ( j , i ) tau_increment = frac1 * frac2 * frac3 * rhs2 * PC tau_ij ( j ) = tau_ij ( j ) + tau_increment !optical depth enddo if ( tau_ij ( j ). lt . - 5.0D0 ) then beta_ij_ray ( j ) = ( 1.0D0 - EXP ( 5.0D0 )) / ( - 5.0D0 ) else if ( tau_ij ( j ). lt . 0.0D0 ) then beta_ij_ray ( j ) = ( 1.0D0 - EXP ( - tau_ij ( j ))) / tau_ij ( j ) else if ( abs ( tau_ij ( j )). lt . 1.0D-8 ) then !was D-6 beta_ij_ray ( j ) = 1.0D0 else beta_ij_ray ( j ) = ( 1.0D0 - EXP ( - tau_ij ( j ))) / tau_ij ( j ) endif enddo #else #ifdef RAYTHEIA do j = 0 , nrays - 1 do i = 1 , s_jjr ( j ) frac3 = ( s_evalpop ( j , i , jlevel ) * weights ( ilevel ) - s_evalpop ( j , i , ilevel ) * weights ( jlevel )) / weights ( jlevel ) rhs2 = length ( j , i ) tau_increment = frac1 * frac2 * frac3 * rhs2 * PC tau_ij ( j ) = tau_ij ( j ) + tau_increment !optical depth enddo if ( tau_ij ( j ). lt . - 5.0D0 ) then beta_ij_ray ( j ) = ( 1.0D0 - EXP ( 5.0D0 )) / ( - 5.0D0 ) else if ( tau_ij ( j ). lt . 0.0D0 ) then beta_ij_ray ( j ) = ( 1.0D0 - EXP ( - tau_ij ( j ))) / tau_ij ( j ) else if ( abs ( tau_ij ( j )). lt . 1.0D-8 ) then !was D-6 beta_ij_ray ( j ) = 1.0D0 else beta_ij_ray ( j ) = ( 1.0D0 - EXP ( - tau_ij ( j ))) / tau_ij ( j ) endif enddo #else do j = 0 , nrays - 1 #ifdef ONEDIMENSIONAL if ( j . ne . 6 ) then tau_ij ( j ) = 1.0D50 else #endif do i = 1 , s_jjr ( j ) !calculations of tau_ij frac3 = (( s_evalpop ( j , i - 1 , jlevel ) * weights ( ilevel ) - s_evalpop ( j , i - 1 , ilevel ) * weights ( jlevel )) + & &( s_evalpop ( j , i , jlevel ) * weights ( ilevel ) - s_evalpop ( j , i , ilevel ) * weights ( jlevel ))) / 2. / weights ( jlevel ) rhs2 = sqrt (( s_evalpoint ( 1 , j , i - 1 ) - s_evalpoint ( 1 , j , i )) ** 2 + & &( s_evalpoint ( 2 , j , i - 1 ) - s_evalpoint ( 2 , j , i )) ** 2 + & &( s_evalpoint ( 3 , j , i - 1 ) - s_evalpoint ( 3 , j , i )) ** 2 ) !adaptive step tau_increment = frac1 * frac2 * frac3 * rhs2 * PC tau_ij ( j ) = tau_ij ( j ) + tau_increment !optical depth enddo !i=1,jr(j) #ifdef ONEDIMENSIONAL endif #endif !Original version ! Prevent exploding beta values caused by strong masing (tau < -10) ! Assume tau = -10 and calculate the escape probability accordingly if ( tau_ij ( j ). lt . - 5.0D0 ) then beta_ij_ray ( j ) = ( 1.0D0 - EXP ( 5.0D0 )) / ( - 5.0D0 ) ! Treat weak masing using the standard escape probability formalism else if ( tau_ij ( j ). lt . 0.0D0 ) then beta_ij_ray ( j ) = ( 1.0D0 - EXP ( - tau_ij ( j ))) / tau_ij ( j ) ! Prevent floating point overflow caused by very low opacity (tau < 1e-6) else if ( abs ( tau_ij ( j )). lt . 1.0D-8 ) then !was D-6 beta_ij_ray ( j ) = 1.0D0 ! For all other cases use the standard escape probability formalism else beta_ij_ray ( j ) = ( 1.0D0 - EXP ( - tau_ij ( j ))) / tau_ij ( j ) endif !---------------- !from UCL_PDR !           if (tau_ij(j).lt.0) then !              beta_ij_ray(j) = 1.0D0 !           elseif (abs(tau_ij(j)).lt.1.0d-8) then !              beta_ij_ray(j) = 1.0D0 !           else !              beta_ij_ray(j) = (1.0D0-dexp(-tau_ij(j)))/tau_ij(j) !           endif !------------ enddo !j=0,nrays-1 !ENDIF RAYTHEIA #endif !ENDIF RAYTHEIA_MO #endif beta_ij_sum = sum ( beta_ij_ray ) !calculation of average beta_ij in the origin grid point #ifdef ONEDIMENSIONAL beta_ij = beta_ij_sum !<---Original !         beta_ij = beta_ij_sum / 2. !<----UCL_PDR #else beta_ij = beta_ij_sum / real ( nrays , kind = DP ) #endif 1 continue line ( ilevel , jlevel ) = A_COEFFS ( ilevel , jlevel ) * HP * frequencies ( ilevel , jlevel ) * & & s_pop ( ilevel ) * beta_ij * ( S_ij - BB_ij ) / S_ij cooling_rate = cooling_rate + line ( ilevel , jlevel ) 2 continue !<J_ij> field ( ilevel , jlevel ) = ( 1.0D0 - beta_ij ) * S_ij + beta_ij * BB_ij field ( jlevel , ilevel ) = field ( ilevel , jlevel ) enddo !jlevel=1,nlev enddo !ilevel=1,nlev !R_IJ CALCULATIONS !Update the transition matrix: Rij = Aij + Bij.<J> + Cij DO ilevel = 1 , NLEV DO jlevel = 1 , NLEV TRANSITION ( ilevel , jlevel ) = A_COEFFS ( ilevel , jlevel )& & + B_COEFFS ( ilevel , jlevel ) * FIELD ( ilevel , jlevel )& & + C_COEFFS ( ilevel , jlevel ) IF ( ABS ( TRANSITION ( ilevel , jlevel )). LT . 1.0D-50 ) TRANSITION ( ilevel , jlevel ) = 0.0D0 ENDDO !jlevel=1,nlev ENDDO !ilevel=1,nlev deallocate ( tau_ij ) deallocate ( field ) return end subroutine escape_probability","tags":"","url":"sourcefile/escape_probability.f90.html"},{"title":"healpix.F90 – 3D-PDR","text":"This file depends on sourcefile~~healpix.f90~~EfferentGraph sourcefile~healpix.f90 healpix.F90 sourcefile~definitions.f90 definitions.F90 sourcefile~healpix.f90->sourcefile~definitions.f90 sourcefile~healpix_types.f90 healpix_types.F90 sourcefile~healpix.f90->sourcefile~healpix_types.f90 sourcefile~modules.f90 modules.F90 sourcefile~healpix.f90->sourcefile~modules.f90 sourcefile~healpix_types.f90->sourcefile~definitions.f90 sourcefile~modules.f90->sourcefile~definitions.f90 sourcefile~modules.f90->sourcefile~healpix_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !#include \"macros.h\" subroutine mk_xy2pix !======================================================================= !     sets the array giving the number of the pixel lying in (x,y) !     x and y are in {1,128} !     the pixel number is in {0,128**2-1} ! !     if  i-1 = sum_p=0  b_p * 2&#94;p !     then ix = sum_p=0  b_p * 4&#94;p !          iy = 2*ix !     ix + iy in {0, 128**2 -1} !======================================================================= use definitions use healpix_types use healpix_module , only : x2pix , y2pix implicit none !    REAL(KIND=DP), INTENT(INOUT) :: x2pix(0:1023),y2pix(0:1023) INTEGER ( KIND = I4B ) :: kk , ipp , ii , jj , idd !======================================================================= do ii = 1 , 128 !for converting x,y into jj = ii - 1 !pixel numbers kk = 0 ipp = 1 do if ( jj == 0 ) then x2pix ( ii ) = kk y2pix ( ii ) = 2 * kk exit else idd = MODULO ( JJ , 2 ) jj = jj / 2 kk = ipp * idd + kk ipp = ipp * 4 endif enddo enddo RETURN END subroutine mk_xy2pix ! ============================================================================ subroutine pix2vec_nest ( nside , ipix , pix2x , pix2y , vector , vertex ) use definitions use healpix_types use healpix_module , only : ns_max implicit none !======================================================================= !     renders vector (x,y,z) coordinates of the nominal pixel center !     for the pixel number ipix (NESTED scheme) !     given the map resolution parameter nside !     also returns the (x,y,z) position of the 4 pixel vertices (=corners) !     in the order N,W,S,E !======================================================================= INTEGER ( KIND = I4B ), INTENT ( IN ) :: nside , ipix REAL ( KIND = DP ), INTENT ( OUT ) :: vector ( 1 : 3 ) REAL ( KIND = DP ), INTENT ( OUT ) :: vertex ( 1 : 3 , 1 : 4 ) integer ( kind = i4b ), intent ( in ) :: pix2x ( 0 : 1023 ), pix2y ( 0 : 1023 ) INTEGER ( KIND = I4B ) :: npix , npface , & & ipf , ip_low , ip_trunc , ip_med , ip_hi , & & jrt , jr , nr , jpt , jp , kshift , nl4 REAL ( KIND = DP ) :: z , fn , fact1 , fact2 , sth , phi INTEGER ( KIND = I4B ) :: ix , iy , face_num !     common /xy_nest/ ix, iy, face_num ! can be useful to calling routine ! coordinate of the lowest corner of each face INTEGER ( KIND = I4B ), dimension ( 1 : 12 ) :: jrll = ( / 2 , 2 , 2 , 2 , 3 , 3 , 3 , 3 , 4 , 4 , 4 , 4 / ) ! in unit of nside INTEGER ( KIND = I4B ), dimension ( 1 : 12 ) :: jpll = ( / 1 , 3 , 5 , 7 , 0 , 2 , 4 , 6 , 1 , 3 , 5 , 7 / ) ! in unit of nside/2 real ( kind = DP ) :: phi_nv , phi_wv , phi_sv , phi_ev , phi_up , phi_dn real ( kind = DP ) :: z_nv , z_sv , sth_nv , sth_sv real ( kind = DP ) :: hdelta_phi integer ( kind = I4B ) :: iphi_mod , iphi_rat logical ( kind = LGT ) :: do_vertex !----------------------------------------------------------------------- ns_max = 8192 if ( nside < 1 . or . nside > ns_max ) stop 'a' npix = 12 * nside ** 2 if ( ipix < 0 . or . ipix > npix - 1 ) stop 'b' !     initiates the array for the pixel number -> (x,y) mapping if ( pix2x ( 1023 ) <= 0 ) call mk_pix2xy () fn = real ( nside , kind = dp ) fact1 = 1.0_dp / ( 3.0_dp * fn * fn ) fact2 = 2.0_dp / ( 3.0_dp * fn ) nl4 = 4 * nside !     finds the face, and the number in the face npface = nside ** 2 face_num = ipix / npface ! face number in {0,11} ipf = MODULO ( ipix , npface ) ! pixel number in the face {0,npface-1} !     finds the x,y on the face (starting from the lowest corner) !     from the pixel number ip_low = MODULO ( ipf , 1024 ) ! content of the last 10 bits ip_trunc = ipf / 1024 ! truncation of the last 10 bits ip_med = MODULO ( ip_trunc , 1024 ) ! content of the next 10 bits ip_hi = ip_trunc / 1024 ! content of the high weight 10 bits ix = 1024 * pix2x ( ip_hi ) + 32 * pix2x ( ip_med ) + pix2x ( ip_low ) iy = 1024 * pix2y ( ip_hi ) + 32 * pix2y ( ip_med ) + pix2y ( ip_low ) !     transforms this in (horizontal, vertical) coordinates jrt = ix + iy ! 'vertical' in {0,2*(nside-1)} jpt = ix - iy ! 'horizontal' in {-nside+1,nside-1} !     computes the z coordinate on the sphere jr = jrll ( face_num + 1 ) * nside - jrt - 1 ! ring number in    !deallocate(ra) !deallocate(rb) !deallocate(dis) !write(7,*) ifront(1:3),evalpoint(1:3,id) !write(4,*) ifront(1:3) {1,4*nside-1} nr = nside ! equatorial region (the most frequent) z = ( 2 * nside - jr ) * fact2 kshift = MODULO ( jr - nside , 2 ) do_vertex = . false . if ( do_vertex ) then z_nv = ( 2 * nside - jr + 1 ) * fact2 z_sv = ( 2 * nside - jr - 1 ) * fact2 if ( jr == nside ) then ! northern transition z_nv = 1.0_dp - ( nside - 1 ) ** 2 * fact1 elseif ( jr == 3 * nside ) then ! southern transition z_sv = - 1.0_dp + ( nside - 1 ) ** 2 * fact1 !pix2ang endif endif if ( jr < nside ) then ! north pole region nr = jr z = 1.0_dp - nr * nr * fact1 kshift = 0 if ( do_vertex ) then z_nv = 1.0_dp - ( nr - 1 ) ** 2 * fact1 z_sv = 1.0_dp - ( nr + 1 ) ** 2 * fact1 endif else if ( jr > 3 * nside ) then ! south pole region nr = nl4 - jr z = - 1.0_dp + nr * nr * fact1 kshift = 0 if ( do_vertex ) then z_nv = - 1.0_dp + ( nr + 1 ) ** 2 * fact1 z_sv = - 1.0_dp + ( nr - 1 ) ** 2 * fact1 endif endif !     computes the phi coordinate on the sphere, in [0,2Pi] jp = ( jpll ( face_num + 1 ) * nr + jpt + 1 + kshift ) / 2 ! 'phi' number in the ring in {1,4*nr} if ( jp > nl4 ) jp = jp - nl4 if ( jp < 1 ) jp = jp + nl4 phi = ( jp - ( kshift + 1 ) * 0.5_dp ) * ( halfpi / nr ) sth = SQRT (( 1.0_dp - z ) * ( 1.0_dp + z )) vector ( 1 ) = sth * COS ( phi ) vector ( 2 ) = sth * SIN ( phi ) vector ( 3 ) = z !two lines added by T.Bisbas due to a problem with precision. if ( abs ( vector ( 2 )). lt . 1 d - 10 ) vector ( 2 ) = 0.0_dp if ( abs ( vector ( 1 )). lt . 1 d - 10 ) vector ( 1 ) = 0.0_dp if ( do_vertex ) then phi_nv = phi phi_sv = phi phi_up = 0.0_dp iphi_mod = MODULO ( jp - 1 , nr ) ! in {0,1,... nr-1} iphi_rat = ( jp - 1 ) / nr ! in {0,1,2,3} if ( nr > 1 ) phi_up = HALFPI * ( iphi_rat + iphi_mod / real ( nr - 1 , kind = dp )) phi_dn = HALFPI * ( iphi_rat + ( iphi_mod + 1 ) / real ( nr + 1 , kind = dp )) if ( jr < nside ) then ! North polar cap phi_nv = phi_up phi_sv = phi_dn else if ( jr > 3 * nside ) then ! South polar cap phi_nv = phi_dn phi_sv = phi_up else if ( jr == nside ) then ! North transition phi_nv = phi_up else if ( jr == 3 * nside ) then ! South transition phi_sv = phi_up endif hdelta_phi = PI / ( 4.0_dp * nr ) ! west vertex phi_wv = phi - hdelta_phi vertex ( 1 , 2 ) = sth * COS ( phi_wv ) vertex ( 2 , 2 ) = sth * SIN ( phi_wv ) vertex ( 3 , 2 ) = z ! east vertex phi_ev = phi + hdelta_phi vertex ( 1 , 4 ) = sth * COS ( phi_ev ) vertex ( 2 , 4 ) = sth * SIN ( phi_ev ) vertex ( 3 , 4 ) = z ! north vertex sth_nv = SQRT (( 1.0_dp - z_nv ) * ( 1.0_dp + z_nv )) vertex ( 1 , 1 ) = sth_nv * COS ( phi_nv ) vertex ( 2 , 1 ) = sth_nv * SIN ( phi_nv ) vertex ( 3 , 1 ) = z_nv ! south vertex sth_sv = SQRT (( 1.0_dp - z_sv ) * ( 1.0_dp + z_sv )) vertex ( 1 , 3 ) = sth_sv * COS ( phi_sv ) vertex ( 2 , 3 ) = sth_sv * SIN ( phi_sv ) vertex ( 3 , 3 ) = z_sv endif return end subroutine pix2vec_nest subroutine mk_pix2xy () use definitions use healpix_types use healpix_module implicit none !======================================================================= !     constructs the array giving x and y in the face from pixel number !     for the nested (quad-cube like) ordering of pixels    ! !     the bits corresponding to x and y are interleaved in the pixel number !     one breaks up the pixel number by even and odd bits !======================================================================= INTEGER :: kpix , jpix , ix , iy , ip , id !cc cf block data      data      pix2x(1023) /0/ !----------------------------------------------------------------------- !      print *, 'initiate pix2xy' do kpix = 0 , 1023 ! pixel number jpix = kpix IX = 0 IY = 0 IP = 1 ! bit position (in x and y) !        do while (jpix/=0) ! go through all the bits do if ( jpix == 0 ) exit ! go through all the bits ID = MODULO ( jpix , 2 ) ! bit value (in kpix), goes in ix jpix = jpix / 2 IX = ID * IP + IX ID = MODULO ( jpix , 2 ) ! bit value (in kpix), goes in iy jpix = jpix / 2 IY = ID * IP + IY IP = 2 * IP ! next bit (in x and y) enddo pix2x ( kpix ) = IX ! in 0,31 pix2y ( kpix ) = IY ! in 0,31 enddo return end subroutine mk_pix2xy ! ============================================================================ subroutine vec2ang ( rvec , theta , phi ) !======================================================================= !     renders the angles theta, phi corresponding to vector (x,y,z) (rvec) !     theta (co-latitude measured from North pole, in [0,Pi] radians) !     and phi (longitude measured eastward, in [0,2Pi[ radians) !     North pole is (x,y,z)=(0,0,1) !     added by EH, Feb 2000 !======================================================================= use definitions use healpix_types implicit none REAL ( KIND = DP ), INTENT ( IN ) :: rvec ( 1 : 3 ) REAL ( KIND = DP ), INTENT ( OUT ) :: theta , phi REAL ( KIND = DP ) :: dnorm , z !======================================================================= dnorm = SQRT ( rvec ( 1 ) ** 2 + rvec ( 2 ) ** 2 + rvec ( 3 ) ** 2 ) if ( dnorm . eq . 0 ) then phi = 0 theta = 0 z = 0 !       write(6,*) 'found dnorm = 0' return end if z = rvec ( 3 ) / dnorm theta = ACOS ( z ) phi = 0.0_dp if ( rvec ( 1 ) /= 0.0_dp . or . rvec ( 2 ) /= 0.0_dp ) & & phi = ATAN2 ( rvec ( 2 ), rvec ( 1 )) ! phi in ]-pi,pi] if ( phi < 0.0 ) phi = phi + twopi ! phi in [0,2pi[ return end subroutine vec2ang ! ============================================================================ subroutine ang2pix_nest_id ( nside , theta , phi , ipix ) !======================================================================= !     renders the pixel number ipix (NESTED scheme) for a pixel which contains !     a point on a sphere at coordinates theta and phi, given the map !     resolution parametr nside ! !     the computation is made to the highest resolution available (nside=8192) !     and then degraded to that required (by integer division) !     this doesn't cost more, and it makes sure !     that the treatement of round-off will be consistent !     for every resolution !======================================================================= use definitions use healpix_types use healpix_module , only : x2pix , y2pix , ns_max implicit none INTEGER ( KIND = I4B ), INTENT ( IN ) :: nside INTEGER ( KIND = I4B ), INTENT ( OUT ) :: ipix REAL ( KIND = DP ), INTENT ( IN ) :: theta , phi REAL ( KIND = DP ) :: z , za , tt , tp , tmp INTEGER ( KIND = I4B ) :: jp , jm , ifp , ifm , face_num , & & ix , iy , ix_low , ix_hi , iy_low , iy_hi , ipf , ntt !----------------------------------------------------------------------- if ( x2pix ( 128 ) <= 0 ) call mk_xy2pix () z = COS ( theta ) za = ABS ( z ) tt = MODULO ( phi , twopi ) / halfpi ! in [0,4[ if ( za <= twothird ) then ! equatorial region !        (the index of edge lines increase when the longitude=phi goes up) jp = INT ( ns_max * ( 0.5_dp + tt - z * 0.75_dp )) !  ascending edge line index jm = INT ( ns_max * ( 0.5_dp + tt + z * 0.75_dp )) ! descending edge line index !        finds the face if ( ns_max . eq . 0 ) stop 'insane ns_max @ _IF' ifp = jp / ns_max ! in {0,4} ifm = jm / ns_max if ( ifp == ifm ) then ! faces 4 to 7 face_num = MODULO ( ifp , 4 ) + 4 else if ( ifp < ifm ) then ! (half-)faces 0 to 3 face_num = MODULO ( ifp , 4 ) else ! (half-)faces 8 to 11 face_num = MODULO ( ifm , 4 ) + 8 endif ix = MODULO ( jm , ns_max ) iy = ns_max - MODULO ( jp , ns_max ) - 1 else ! polar region, za > 2/3 ntt = INT ( tt ) if ( ntt >= 4 ) ntt = 3 tp = tt - ntt tmp = SQRT ( 3.0_dp * ( 1.0_dp - za ) ) ! in ]0,1] !        (the index of edge lines increase when distance from the closest pole goes up) jp = INT ( ns_max * tp * tmp ) ! line going toward the pole as phi increases jm = INT ( ns_max * ( 1.0_dp - tp ) * tmp ) ! that one goes away of the closest pole jp = MIN ( ns_max - 1 , jp ) ! for points too close to the boundary jm = MIN ( ns_max - 1 , jm ) !        finds the face and pixel's (x,y) if ( z >= 0 ) then face_num = ntt ! in {0,3} ix = ns_max - jm - 1 iy = ns_max - jp - 1 else face_num = ntt + 8 ! in {8,11} ix = jp iy = jm endif !         print*,z,face_num,ix,iy endif ix_low = MODULO ( ix , 128 ) ix_hi = ix / 128 iy_low = MODULO ( iy , 128 ) iy_hi = iy / 128 ipf = ( x2pix ( ix_hi + 1 ) + y2pix ( iy_hi + 1 )) * ( 128 * 128 ) & & + ( x2pix ( ix_low + 1 ) + y2pix ( iy_low + 1 )) if ( ns_max . eq . 0. or . nside . eq . 0 ) stop 'insane ns_max and/or nside @ _IF' !ipf = (ipf / ( ns_max/nside ))/(ns_max/nside)  ! in {0, nside**2 - 1} ipf = ipf / ( ns_max / nside ) ** 2 ipix = ipf + face_num * nside ** 2 ! in {0, 12*nside**2 - 1} return end subroutine ang2pix_nest_id !======================================================================= !     pix2ang_nest ! !     renders theta and phi coordinates of the nominal pixel center !     for the pixel number ipix (NESTED scheme) !     given the map resolution parameter nside !======================================================================= subroutine pix2ang_nest ( nside , ipix , theta , phi ) use definitions use healpix_types use healpix_module implicit none integer ( i4b ), parameter :: MKD = I4B INTEGER ( KIND = I4B ), INTENT ( IN ) :: nside INTEGER ( KIND = MKD ), INTENT ( IN ) :: ipix REAL ( KIND = DP ), INTENT ( OUT ) :: theta , phi INTEGER ( KIND = MKD ) :: npix , npface , ipf INTEGER ( KIND = I4B ) :: ip_low , ip_trunc , ip_med , ip_hi , & & jrt , jr , nr , jpt , jp , kshift , nl4 , scale , i , ismax INTEGER ( KIND = I4B ) :: ix , iy , face_num REAL ( KIND = DP ) :: z , fn , fact1 , fact2 ! coordinate of the lowest corner of each face INTEGER ( KIND = I4B ), dimension ( 1 : 12 ) :: jrll = ( / 2 , 2 , 2 , 2 , 3 , 3 , 3 , 3 , 4 , 4 , 4 , 4 / ) ! in unit of nside INTEGER ( KIND = I4B ), dimension ( 1 : 12 ) :: jpll = ( / 1 , 3 , 5 , 7 , 0 , 2 , 4 , 6 , 1 , 3 , 5 , 7 / ) ! in unit of nside/2 character ( len =* ), parameter :: code = \"pix2ang_nest\" !----------------------------------------------------------------------- if ( nside < 1 . or . nside > ns_max ) then print * , \"nside out of range\" stop end if !npix = nside2npix(nside)       ! total number of points npix = 12 * nside ** 2 ! total number of points !print *, \"P2A: \", nside, ipix, theta, phi, npix if ( ipix < 0 . or . ipix > npix - 1 ) then print * , \"ipix out of range\" stop end if !     initiates the array for the pixel number -> (x,y) mapping if ( pix2x ( 1023 ) <= 0 ) call mk_pix2xy () npface = nside * int ( nside , kind = MKD ) nl4 = 4_MKD * nside !     finds the face, and the number in the face face_num = ipix / npface ! face number in {0,11} ipf = MODULO ( ipix , npface ) ! pixel number in the face {0,npface-1} fn = real ( nside , kind = dp ) !fact1 = 1.0_dp/(3.0_dp*fn*fn) !     finds the x,y on the face (starting from the lowest corner) !     from the pixel number if ( nside <= ns_max ) then ip_low = iand ( ipf , 1023_MKD ) ! content of the last 10 bits ip_trunc = ipf / 1024 ! truncation of the last 10 bits ip_med = iand ( ip_trunc , 1023 ) ! content of the next 10 bits ip_hi = ip_trunc / 1024 ! content of the high weight 10 bits ix = 1024 * pix2x ( ip_hi ) + 32 * pix2x ( ip_med ) + pix2x ( ip_low ) iy = 1024 * pix2y ( ip_hi ) + 32 * pix2y ( ip_med ) + pix2y ( ip_low ) else ix = 0 iy = 0 scale = 1 ismax = 4 do i = 0 , ismax ip_low = iand ( ipf , 1023_MKD ) ix = ix + scale * pix2x ( ip_low ) iy = iy + scale * pix2y ( ip_low ) scale = scale * 32 ipf = ipf / 1024 enddo ix = ix + scale * pix2x ( ipf ) iy = iy + scale * pix2y ( ipf ) endif !     transforms this in (horizontal, vertical) coordinates jrt = ix + iy ! 'vertical' in {0,2*(nside-1)} jpt = ix - iy ! 'horizontal' in {-nside+1,nside-1} !     computes the z coordinate on the sphere jr = jrll ( face_num + 1 ) * nside - jrt - 1 ! ring number in {1,4*nside-1} if ( jr < nside ) then ! north pole region nr = jr !z = 1.0_dp - nr * fact1 * nr theta = 2.0_dp * asin ( nr / ( sqrt ( 6.0_dp ) * fn ) ) !kshift = 0 else if ( jr <= 3 * nside ) then ! equatorial region !fact2 = 2.0_dp/(3.0_dp*fn) nr = nside theta = ACOS (( 2 * nside - jr ) * 2.0_dp / ( 3.0_dp * fn ) ) !kshift = iand(jr - nside, 1) else if ( jr > 3 * nside ) then ! south pole region nr = nl4 - jr !z = - 1.0_dp + nr * fact1 * nr theta = PI - 2.0_dp * asin ( nr / ( sqrt ( 6.0_dp ) * fn ) ) !kshift = 0 endif !     !     computes the phi coordinate on the sphere, in [0,2Pi] !     jp = (jpll(face_num+1)*nr + jpt + 1_MKD + kshift)/2  ! 'phi' number in the ring in {1,4*nr} !     if (jp > nl4) jp = jp - nl4 !     if (jp < 1)   jp = jp + nl4 !     phi = (jp - (kshift+1)*0.5_dp) * (halfpi / nr) !     computes the phi coordinate on the sphere, in [0,2Pi] jp = jpll ( face_num + 1 ) * nr + jpt ! 'phi' number in the ring in {0,8*nr-1} if ( jp < 0 ) jp = jp + 2_MKD * nl4 phi = jp * ( quartpi / nr ) return end subroutine pix2ang_nest","tags":"","url":"sourcefile/healpix.f90.html"},{"title":"analyse_chem.F90 – 3D-PDR","text":"This file depends on sourcefile~~analyse_chem.f90~~EfferentGraph sourcefile~analyse_chem.f90 analyse_chem.F90 sourcefile~definitions.f90 definitions.F90 sourcefile~analyse_chem.f90->sourcefile~definitions.f90 sourcefile~healpix_types.f90 healpix_types.F90 sourcefile~analyse_chem.f90->sourcefile~healpix_types.f90 sourcefile~modules.f90 modules.F90 sourcefile~analyse_chem.f90->sourcefile~modules.f90 sourcefile~healpix_types.f90->sourcefile~definitions.f90 sourcefile~modules.f90->sourcefile~definitions.f90 sourcefile~modules.f90->sourcefile~healpix_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !======================================================================= SUBROUTINE ANALYSE_CHEMISTRY ( GRIDPOINT , TIME , DENSITY , TEMPERATURE , & & NRAYS , AV , NSPEC , SPECIES , ABUNDANCE , & & NREAC , REACTANT , PRODUCT , RATE ) !T.Bell USE DEFINITIONS USE HEALPIX_TYPES USE GLOBAL_MODULE IMPLICIT NONE INTEGER ( KIND = I4B ), INTENT ( IN ) :: GRIDPOINT , NRAYS , NSPEC , NREAC REAL ( KIND = DP ), INTENT ( IN ) :: TIME , DENSITY , TEMPERATURE !REAL(KIND=DP),     INTENT(IN) :: AV(0:NRAYS-1),ABUNDANCE(1:NSPEC),RATE(1:NREAC) REAL ( KIND = DP ), INTENT ( IN ) :: AV , ABUNDANCE ( 1 : NSPEC ), RATE ( 1 : NREAC ) CHARACTER ( LEN = 10 ), INTENT ( IN ) :: SPECIES ( 1 : NSPEC ), REACTANT ( 1 : NREAC , 1 : 3 ), PRODUCT ( 1 : NREAC , 1 : 4 ) INTEGER ( KIND = I4B ) :: I , J , L , M , N , IP , ID INTEGER ( KIND = I4B ) :: NPR ( 1 : NREAC ), NDR ( 1 : NREAC ) INTEGER ( KIND = I4B ) :: NMAX ( 1 ), TOTAL REAL ( KIND = DP ) :: X1 , X2 , RMULT , PERCENT REAL ( KIND = DP ) :: P ( 1 : NREAC ), PTOT REAL ( KIND = DP ) :: D ( 1 : NREAC ), DTOT !     Specify the number of species to examine and their names INTEGER ( KIND = I4B ), SAVE :: NLIST = 6 !      CHARACTER(LEN=10), SAVE :: SPECLIST(1:7)=& !     &      (/\"H2        \",\"CO        \",\"C         \",& !     & \"C+        \",\"CH        \",\"OH        \",\"e-        \"/) CHARACTER ( LEN = 10 ), SAVE :: SPECLIST ( 1 : 6 ) = & & ( / \"H3+       \" , \"C         \" , \"CO        \" , \"C+        \" , & & \"He+       \" , \"e-        \" / ) WRITE ( 98 , 6 ) DO L = 1 , NLIST !        Find index I of the species that corresponds !        to the current entry in the SPECLIST array DO I = 1 , NSPEC IF ( SPECIES ( I ). EQ . SPECLIST ( L )) EXIT ENDDO !        Check that species I corresponds to the desired species !        Continue to the next entry in SPECLIST if it does not IF ( SPECIES ( I ). NE . SPECLIST ( L )) CYCLE !WRITE(98,4) GRIDPOINT,TIME,MINVAL(AV),DENSITY,TEMPERATURE,SPECIES(I) WRITE ( 98 , 4 ) GRIDPOINT , TIME , AV , DENSITY , TEMPERATURE , SPECIES ( I ) !        Reset the formation/destruction rate counters IP = 0 ID = 0 !        Reset the total formation/destruction rates PTOT = 0.0D0 DTOT = 0.0D0 !        Check all reactions to find relevant ones DO J = 1 , NREAC !           Reset the reactant abundances X1 = 0.0D0 X2 = 0.0D0 !----------------------------------------------------------------------- !           Formation routes for species I !----------------------------------------------------------------------- IF ( PRODUCT ( J , 1 ). EQ . SPECIES ( I ) . OR . PRODUCT ( J , 2 ). EQ . SPECIES ( I ) . OR . & & PRODUCT ( J , 3 ). EQ . SPECIES ( I ) . OR . PRODUCT ( J , 4 ). EQ . SPECIES ( I )) THEN IP = IP + 1 !              Store the reactant abundances DO N = 1 , NSPEC IF ( SPECIES ( N ). EQ . REACTANT ( J , 1 )) X1 = ABUNDANCE ( N ) IF ( SPECIES ( N ). EQ . REACTANT ( J , 2 )) X2 = ABUNDANCE ( N ) ENDDO RMULT = 0.0D0 IF ( PRODUCT ( J , 1 ). EQ . SPECIES ( I )) RMULT = RMULT + 1.0D0 IF ( PRODUCT ( J , 2 ). EQ . SPECIES ( I )) RMULT = RMULT + 1.0D0 IF ( PRODUCT ( J , 3 ). EQ . SPECIES ( I )) RMULT = RMULT + 1.0D0 IF ( PRODUCT ( J , 4 ). EQ . SPECIES ( I )) RMULT = RMULT + 1.0D0 !              Calculate the reaction rate IF ( REACTANT ( J , 2 ). EQ . \"PHOTON\" . OR . & & REACTANT ( J , 2 ). EQ . \"CRP   \" . OR . & & REACTANT ( J , 2 ). EQ . \"CRPHOT\" . OR . & & REACTANT ( J , 2 ). EQ . \"FREEZE\" . OR . & & REACTANT ( J , 2 ). EQ . \"ELFRZE\" . OR . & & REACTANT ( J , 2 ). EQ . \"CRH   \" . OR . & & REACTANT ( J , 2 ). EQ . \"PHOTD \" . OR . & & REACTANT ( J , 2 ). EQ . \"THERM \" ) THEN P ( IP ) = RATE ( J ) * X1 * RMULT ELSE P ( IP ) = RATE ( J ) * X1 * X2 * DENSITY * RMULT ENDIF PTOT = PTOT + P ( IP ) NPR ( IP ) = J ENDIF !----------------------------------------------------------------------- !           Destruction routes for species I !----------------------------------------------------------------------- IF ( REACTANT ( J , 1 ). EQ . SPECIES ( I ) . OR . REACTANT ( J , 2 ). EQ . SPECIES ( I )) THEN ID = ID + 1 !              Store the reactant abundances DO N = 1 , NSPEC IF ( SPECIES ( N ). EQ . REACTANT ( J , 1 )) X1 = ABUNDANCE ( N ) IF ( SPECIES ( N ). EQ . REACTANT ( J , 2 )) X2 = ABUNDANCE ( N ) ENDDO RMULT = 0.0D0 IF ( REACTANT ( J , 1 ). EQ . SPECIES ( I )) RMULT = RMULT + 1.0D0 IF ( REACTANT ( J , 2 ). EQ . SPECIES ( I )) RMULT = RMULT + 1.0D0 !              Calculate the reaction rate IF ( REACTANT ( J , 2 ). EQ . \"PHOTON\" . OR . & & REACTANT ( J , 2 ). EQ . \"CRP   \" . OR . & & REACTANT ( J , 2 ). EQ . \"CRPHOT\" . OR . & & REACTANT ( J , 2 ). EQ . \"FREEZE\" . OR . & & REACTANT ( J , 2 ). EQ . \"ELFRZE\" . OR . & & REACTANT ( J , 2 ). EQ . \"CRH   \" . OR . & & REACTANT ( J , 2 ). EQ . \"PHOTD \" . OR . & & REACTANT ( J , 2 ). EQ . \"THERM \" ) THEN D ( ID ) = RATE ( J ) * X1 * RMULT ELSE D ( ID ) = RATE ( J ) * X1 * X2 * DENSITY * RMULT ENDIF DTOT = DTOT + D ( ID ) NDR ( ID ) = J ENDIF !        End of loop over all reactions ENDDO !        Prevent divide-by-zero errors by setting minimum finite !        values for the total formation and destruction rates IF ( PTOT . LT . 1.0D-99 ) PTOT = 1.0D-99 IF ( DTOT . LT . 1.0D-99 ) DTOT = 1.0D-99 !----------------------------------------------------------------------- !        Output the formation reactions and their rates !----------------------------------------------------------------------- NMAX = 0 TOTAL = 0 !        List the formation reactions in order of decreasing importance DO M = 1 , IP !           Find the location of the maximum value NMAX = MAXLOC ( P ( 1 : IP )) N = NMAX ( 1 ) !           Exit the loop once the reaction rates reach zero IF ( P ( N ). EQ . 0.0D0 ) EXIT !           Calculate the percentage of the total formation !           rate that is contributed by the current reaction PERCENT = 1.0D2 * ( P ( N ) / PTOT ) IF ( PERCENT . LT . 0.5D0 ) PERCENT = 1.0D0 TOTAL = TOTAL + NINT ( PERCENT ) IF ( PRODUCT ( NPR ( N ), 3 ). EQ . \" \" ) THEN WRITE ( 98 , 1 ) ( REACTANT ( NPR ( N ), J ), J = 1 , 2 ),( PRODUCT ( NPR ( N ), J ), J = 1 , 2 ), NINT ( PERCENT ) ELSE IF ( PRODUCT ( NPR ( N ), 4 ). EQ . \" \" ) THEN WRITE ( 98 , 2 ) ( REACTANT ( NPR ( N ), J ), J = 1 , 2 ),( PRODUCT ( NPR ( N ), J ), J = 1 , 3 ), NINT ( PERCENT ) ELSE WRITE ( 98 , 3 ) ( REACTANT ( NPR ( N ), J ), J = 1 , 2 ),( PRODUCT ( NPR ( N ), J ), J = 1 , 4 ), NINT ( PERCENT ) ENDIF !           Exit the loop once the sum of the reaction rates reaches 100% IF ( TOTAL . GE . 100 ) EXIT !           Set the formation rate of this reaction to zero !           to prevent it from being included more than once P ( N ) = 0.0D0 !        End of loop over formation reactions ENDDO WRITE ( 98 , * ) !----------------------------------------------------------------------- !        Output the destruction reactions and their rates !----------------------------------------------------------------------- NMAX = 0 TOTAL = 0 !        List the destruction reactions in order of decreasing importance DO M = 1 , ID !           Find the location of the maximum value NMAX = MAXLOC ( D ( 1 : ID )) N = NMAX ( 1 ) !           Exit the loop once the reaction rates reach zero IF ( D ( N ). EQ . 0.0D0 ) EXIT !           Calculate the percentage of the total destruction !           rate that is contributed by the current reaction PERCENT = 1.0D2 * ( D ( N ) / DTOT ) IF ( PERCENT . LT . 0.5D0 ) PERCENT = 1.0D0 TOTAL = TOTAL + NINT ( PERCENT ) IF ( PRODUCT ( NDR ( N ), 3 ). EQ . \" \" ) THEN WRITE ( 98 , 1 ) ( REACTANT ( NDR ( N ), J ), J = 1 , 2 ),( PRODUCT ( NDR ( N ), J ), J = 1 , 2 ), - NINT ( PERCENT ) ELSE IF ( PRODUCT ( NDR ( N ), 4 ). EQ . \" \" ) THEN WRITE ( 98 , 2 ) ( REACTANT ( NDR ( N ), J ), J = 1 , 2 ),( PRODUCT ( NDR ( N ), J ), J = 1 , 3 ), - NINT ( PERCENT ) ELSE WRITE ( 98 , 3 ) ( REACTANT ( NDR ( N ), J ), J = 1 , 2 ),( PRODUCT ( NDR ( N ), J ), J = 1 , 4 ), - NINT ( PERCENT ) ENDIF !           Exit the loop once the sum of the reaction rates reaches 100% IF ( TOTAL . GE . 100 ) EXIT !           Set the destruction rate of this reaction to zero !           to prevent it from being included more than once D ( N ) = 0.0D0 !        End of loop over destruction reactions ENDDO WRITE ( 98 , * ) !----------------------------------------------------------------------- !        Output the abundance and total formation/destruction rates WRITE ( 98 , 5 ) ABUNDANCE ( I ), PTOT , DTOT WRITE ( 98 , 6 ) !        End of loop over SPECLIST array ENDDO WRITE ( 98 , 7 ) 1 FORMAT ( 3 X , A10 , '+' , 3 X , A10 , '-->' , 3 X , A10 , '+' , 3 X , A10 , 12 X , 'Rate:' , I4 , '%' ) 2 FORMAT ( 3 X , A10 , '+' , 3 X , A10 , '-->' , 3 X , A10 , '+' , 3 X , A10 , '+' , 3 X , A5 , 3 X , 'Rate:' , I4 , '%' ) 3 FORMAT ( 3 X , A10 , '+' , 3 X , A10 , '-->' , 3 X , A10 , '+' , 3 X , A10 , '+' , 3 X , A5 , 3 X , '+' , 3 X , A5 , 3 X , 'Rate:' , I4 , '%' ) 4 FORMAT ( 'Gridpoint =' , I7 , ', t =' , 1 PE7 . 1E1 , ' yr, Av =' , 1 PE7 . 1E1 , ' mag' , / , & & 'n_H =' , 1 PE7 . 1E1 , ' cm-3, T_gas =' , 1 PE7 . 1E1 , ' K' , / , & & 'Species = ' , A10 , / ) 5 FORMAT ( 'Abundance        =' , 1 PE10 . 3 , / , & & 'Formation Rate   =' , 1 PE10 . 3 , ' s-1' , / , & & 'Destruction Rate =' , 1 PE10 . 3 , ' s-1' , / ) 6 FORMAT ( 80 ( '-' ), / ) 7 FORMAT ( 80 ( '=' ), / ) RETURN END SUBROUTINE ANALYSE_CHEMISTRY !=======================================================================","tags":"","url":"sourcefile/analyse_chem.f90.html"},{"title":"partition_function.F90 – 3D-PDR","text":"This file depends on sourcefile~~partition_function.f90~~EfferentGraph sourcefile~partition_function.f90 partition_function.F90 sourcefile~healpix_types.f90 healpix_types.F90 sourcefile~partition_function.f90->sourcefile~healpix_types.f90 sourcefile~definitions.f90 definitions.F90 sourcefile~healpix_types.f90->sourcefile~definitions.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Calculate the partition function for the given species SUBROUTINE CALCULATE_PARTITION_FUNCTION ( PARTITION_FUNCTION , NLEV , ENERGIES , WEIGHTS , TEMPERATURE ) USE HEALPIX_TYPES IMPLICIT NONE INTEGER ( KIND = I4B ), INTENT ( IN ) :: NLEV REAL ( KIND = DP ), INTENT ( IN ) :: ENERGIES ( 1 : NLEV ), WEIGHTS ( 1 : NLEV ) REAL ( KIND = DP ), INTENT ( IN ) :: TEMPERATURE REAL ( KIND = DP ), INTENT ( OUT ) :: PARTITION_FUNCTION INTEGER ( KIND = I4B ) :: ILEVEL PARTITION_FUNCTION = 0.0D0 DO ILEVEL = 1 , NLEV PARTITION_FUNCTION = PARTITION_FUNCTION + WEIGHTS ( ILEVEL ) * EXP ( - ENERGIES ( ILEVEL ) / KB / TEMPERATURE ) ENDDO RETURN END SUBROUTINE CALCULATE_PARTITION_FUNCTION","tags":"","url":"sourcefile/partition_function.f90.html"},{"title":"heapsort.F90 – 3D-PDR","text":"This file depends on sourcefile~~heapsort.f90~~EfferentGraph sourcefile~heapsort.f90 heapsort.F90 sourcefile~definitions.f90 definitions.F90 sourcefile~heapsort.f90->sourcefile~definitions.f90 sourcefile~healpix_types.f90 healpix_types.F90 sourcefile~heapsort.f90->sourcefile~healpix_types.f90 sourcefile~healpix_types.f90->sourcefile~definitions.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !#include \"macros.h\" ! ============================================================================ ! ! HEAPSORT.F90 ! TAKEN FROM SEREN SPH CODE ! C. P. Batty - 16/5/2006 ! Sorts a list of values (and its identifiers) using heapsort (bottom-up) ! ---------------------------------------------------------------------------- SUBROUTINE heapsort ( pp_pot , plist , rlist ) use definitions use healpix_types implicit none integer ( kind = i4b ), intent ( in ) :: pp_pot ! number of potential neighbours found integer ( kind = i4b ), dimension ( 1 : pp_pot + 1 ), intent ( inout ) :: plist ! list of potential neighbours real ( kind = dp ), dimension ( 0 : pp_pot + 1 ), intent ( inout ) :: rlist ! list of drsqd values for reference integer :: start integer :: end integer :: sift_start integer :: sift_end ! limit of how far down the heap to sift integer :: root integer :: child integer :: swapi ! storage for array element swap real ( kind = PR ) :: swapr ! storage for array element swap !  integer::pp_limit ! Place array(s) in max-heap order start = pp_pot / 2 ! assign index in array of last parent node do while ( start > 0 ) ! Sift down the node at index start to place such that all nodes below ! start index are in heap order sift_start = start sift_end = pp_pot - 1 root = sift_start do child = root * 2 ! ...point to the left child if ( child > sift_end ) exit ! if root has no children then exit ! If child has greater sibling then point to right child instead if (( child < sift_end ) . and . ( rlist ( child ) < rlist ( child + 1 ))) child = child + 1 if ( rlist ( root ) < rlist ( child )) then ! out of max-heap order swapr = rlist ( root ); rlist ( root ) = rlist ( child ); rlist ( child ) = swapr swapi = plist ( root ); plist ( root ) = plist ( child ); plist ( child ) = swapi root = child ! repeat to continue sifting down child else exit end if end do start = start - 1 ! After sifting down root, all elements/nodes are in heap order end do end = pp_pot do while ( end > 1 ) ! Swap root of heap (maximum value) with last element of heap swapr = rlist ( end ); rlist ( end ) = rlist ( 1 ); rlist ( 1 ) = swapr swapi = plist ( end ); plist ( end ) = plist ( 1 ); plist ( 1 ) = swapi ! Decrease size of heap by one (previous max value stays in proper place) end = end - 1 ! Put the heap back in max-heap order sift_start = 1 sift_end = end root = sift_start do child = root * 2 ! ...point to the left child if ( child > sift_end ) exit ! if root has no children then exit ! If child has greater sibling then point to right child instead if (( child < sift_end ) . and . ( rlist ( child ) < rlist ( child + 1 ))) child = child + 1 if ( rlist ( root ) < rlist ( child )) then ! out of max-heap order swapr = rlist ( root ); rlist ( root ) = rlist ( child ); rlist ( child ) = swapr swapi = plist ( root ); plist ( root ) = plist ( child ); plist ( child ) = swapi root = child ! repeat to continue sifting down child else exit end if end do end do return END SUBROUTINE heapsort","tags":"","url":"sourcefile/heapsort.f90.html"},{"title":"read_species.F90 – 3D-PDR","text":"This file depends on sourcefile~~read_species.f90~~EfferentGraph sourcefile~read_species.f90 read_species.F90 sourcefile~definitions.f90 definitions.F90 sourcefile~read_species.f90->sourcefile~definitions.f90 sourcefile~healpix_types.f90 healpix_types.F90 sourcefile~read_species.f90->sourcefile~healpix_types.f90 sourcefile~modules.f90 modules.F90 sourcefile~read_species.f90->sourcefile~modules.f90 sourcefile~healpix_types.f90->sourcefile~definitions.f90 sourcefile~modules.f90->sourcefile~definitions.f90 sourcefile~modules.f90->sourcefile~healpix_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !C*********************************************************************** !C     Read in the chemical reaction rates and the species, masses and !C     initial abundances (if specified). The  rates and species files !C     are assumed to have comma separated values (CSV) format. This is !C     in line with the Rate05 formatting, removing the need for file- !C     dependent FORMAT statements. !C*********************************************************************** ! !C----------------------------------------------------------------------- !C     Read in the species data, including initial fractional abundances !C     (3rd column) and their masses (4th column). Check that the value !C     of NSPEC agrees with the number of species in the file and produce !C     an error message if not. !C----------------------------------------------------------------------- SUBROUTINE READ_SPECIES ( NSPEC , SPECIES , ABUNDANCE , MASS ) !T.Bell use definitions use healpix_types use global_module use maincode_module , only : coolant , coo IMPLICIT NONE INTEGER ( kind = i4b ), intent ( in ) :: NSPEC real ( kind = dp ), intent ( out ) :: ABUNDANCE ( 1 : nspec ), MASS ( 1 : nspec ) CHARACTER ( len = 10 ), intent ( out ) :: SPECIES ( 1 : nspec ) character ( len = 50 ) :: suffix INTEGER ( kind = i4b ) :: I , INDEX , SPECIESFILE , J SPECIESFILE = 3 !C     Initialize the variables and read in the species data. Check that !C     the value of NSPEC agrees with the number of species in the file !C     and produce an error message if not. SPECIES = \"          \" ABUNDANCE = 0.0D0 MASS = 0.0D0 !C     Initialize all the species index labels. If they are not assigned !C     subsequently, any attempt to access that species will generate an !C     error and the code will crash. This is a useful bug catch. NH = 0 ND = 0 NH2 = 0 NHD = 0 NH2x = 0 NPROTON = 0 NC = 0 NCx = 0 NO = 0 NOx = 0 NN = 0 NNx = 0 NS = 0 NSx = 0 NHE = 0 NHEx = 0 NNA = 0 NNAx = 0 NN2Hx = 0 NMG = 0 NMGx = 0 NSI = 0 NSIx = 0 NFE = 0 NFEx = 0 NCL = 0 NCLx = 0 NCA = 0 NCAx = 0 NCAxx = 0 NCO = 0 NCH = 0 NCH2 = 0 NOH = 0 NO2 = 0 NCS = 0 NH2O = 0 NELECT = 0 NH3x = 0 NH3Ox = 0 NHCOx = 0 NCHx = 0 NCN = 0 NOHx = 0 NSiO = 0 NC2H = 0 NHCN = 0 NHNC = 0 #ifdef REDUCED suffix = 'reduced.d' #elif MEDIUM suffix = 'medium.d' #elif FULL suffix = 'full.d' #elif MYNETWORK suffix = 'mynetwork.d' #endif OPEN ( SPECIESFILE , FILE = \"chemfiles/species_\" // trim ( adjustl ( suffix )), STATUS = \"OLD\" ) REWIND ( SPECIESFILE ) DO I = 1 , NSPEC READ ( SPECIESFILE , * , END = 1 ) INDEX , SPECIES ( I ), ABUNDANCE ( I ), MASS ( I ) !C        Assign the various index labels to their correct species. IF ( SPECIES ( I ). EQ . \"H         \" ) NH = I IF ( SPECIES ( I ). EQ . \"D         \" ) ND = I IF ( SPECIES ( I ). EQ . \"H2        \" ) NH2 = I IF ( SPECIES ( I ). EQ . \"HD        \" ) NHD = I IF ( SPECIES ( I ). EQ . \"H2+       \" ) NH2x = I IF ( SPECIES ( I ). EQ . \"H3+       \" ) NH3x = I IF ( SPECIES ( I ). EQ . \"H+        \" ) NPROTON = I IF ( SPECIES ( I ). EQ . \"C         \" ) NC = I IF ( SPECIES ( I ). EQ . \"C+        \" ) NCx = I IF ( SPECIES ( I ). EQ . \"O         \" ) NO = I IF ( SPECIES ( I ). EQ . \"O+        \" ) NOx = I IF ( SPECIES ( I ). EQ . \"N         \" ) NN = I IF ( SPECIES ( I ). EQ . \"N+        \" ) NNx = I IF ( SPECIES ( I ). EQ . \"S         \" ) NS = I IF ( SPECIES ( I ). EQ . \"S+        \" ) NSx = I IF ( SPECIES ( I ). EQ . \"He        \" ) NHE = I IF ( SPECIES ( I ). EQ . \"HE        \" ) NHE = I IF ( SPECIES ( I ). EQ . \"He+       \" ) NHEx = I IF ( SPECIES ( I ). EQ . \"HE+       \" ) NHEx = I IF ( SPECIES ( I ). EQ . \"Na        \" ) NNA = I IF ( SPECIES ( I ). EQ . \"NA        \" ) NNA = I IF ( SPECIES ( I ). EQ . \"Na+       \" ) NNAx = I IF ( SPECIES ( I ). EQ . \"NA+       \" ) NNAx = I IF ( SPECIES ( I ). EQ . \"N2H+      \" ) NN2Hx = I IF ( SPECIES ( I ). EQ . \"Mg        \" ) NMG = I IF ( SPECIES ( I ). EQ . \"MG        \" ) NMG = I IF ( SPECIES ( I ). EQ . \"Mg+       \" ) NMGx = I IF ( SPECIES ( I ). EQ . \"MG+       \" ) NMGx = I IF ( SPECIES ( I ). EQ . \"Si        \" ) NSI = I IF ( SPECIES ( I ). EQ . \"SI        \" ) NSI = I IF ( SPECIES ( I ). EQ . \"Si+       \" ) NSIx = I IF ( SPECIES ( I ). EQ . \"SI+       \" ) NSIx = I IF ( SPECIES ( I ). EQ . \"SiO       \" ) NSIO = I IF ( SPECIES ( I ). EQ . \"Fe        \" ) NFE = I IF ( SPECIES ( I ). EQ . \"FE        \" ) NFE = I IF ( SPECIES ( I ). EQ . \"Fe+       \" ) NFEx = I IF ( SPECIES ( I ). EQ . \"FE+       \" ) NFEx = I IF ( SPECIES ( I ). EQ . \"Cl        \" ) NCL = I IF ( SPECIES ( I ). EQ . \"CL        \" ) NCL = I IF ( SPECIES ( I ). EQ . \"Cl+       \" ) NCLx = I IF ( SPECIES ( I ). EQ . \"CL+       \" ) NCLx = I IF ( SPECIES ( I ). EQ . \"Ca        \" ) NCA = I IF ( SPECIES ( I ). EQ . \"CA        \" ) NCA = I IF ( SPECIES ( I ). EQ . \"Ca+       \" ) NCAx = I IF ( SPECIES ( I ). EQ . \"CA+       \" ) NCAx = I IF ( SPECIES ( I ). EQ . \"Ca++      \" ) NCAxx = I IF ( SPECIES ( I ). EQ . \"CA++      \" ) NCAxx = I IF ( SPECIES ( I ). EQ . \"CO        \" ) NCO = I IF ( SPECIES ( I ). EQ . \"CH        \" ) NCH = I IF ( SPECIES ( I ). EQ . \"CH+       \" ) NCHx = I IF ( SPECIES ( I ). EQ . \"CH2       \" ) NCH2 = I IF ( SPECIES ( I ). EQ . \"CN        \" ) NCN = I IF ( SPECIES ( I ). EQ . \"C2H       \" ) NC2H = I IF ( SPECIES ( I ). EQ . \"OH        \" ) NOH = I IF ( SPECIES ( I ). EQ . \"OH+       \" ) NOHx = I IF ( SPECIES ( I ). EQ . \"O2        \" ) NO2 = I IF ( SPECIES ( I ). EQ . \"CS        \" ) NCS = I IF ( SPECIES ( I ). EQ . \"H2O       \" ) NH2O = I IF ( SPECIES ( I ). EQ . \"H3O+      \" ) NH3Ox = I IF ( SPECIES ( I ). EQ . \"HCO+      \" ) NHCOx = I IF ( SPECIES ( I ). EQ . \"HCN       \" ) NHCN = I IF ( SPECIES ( I ). EQ . \"HNC       \" ) NHNC = I IF ( SPECIES ( I ). EQ . \"e-        \" ) NELECT = I IF ( SPECIES ( I ). EQ . \"ELECTR    \" ) NELECT = I DO J = 1 , COO IF ( coolant ( j )% cname . EQ . SPECIES ( I )) coolant ( j )% cspec = I ENDDO ENDDO I = I - 1 READ ( SPECIESFILE , * , END = 1 ) I = I + 1 1 IF ( I . NE . NSPEC ) THEN write ( 6 , * ) 'ERROR! Number of species (NSPEC) does not match ' ,& & 'the number of entries in the species file' STOP ENDIF !C     Check that the final species in the file is e-. Print a warning !C     message to screen and logfile if not. IF ( SPECIES ( NSPEC ). NE . \"e-\" ) THEN write ( 6 , * ) 'WARNING! Last entry in species file is not e-' WRITE ( 10 , * ) 'WARNING! Last entry in species file is not e-' ENDIF !C     Check that the total hydrogen nuclei abundance adds up to 1. !C     If not, modify the abundance of H2 (only consider H, H+ & H2) IF (( ABUNDANCE ( NH ) + ABUNDANCE ( NPROTON ) + 2.0D0 * ABUNDANCE ( NH2 )). NE . 1.0D0 ) THEN ABUNDANCE ( NH2 ) = 0.5D0 * ( 1.0D0 - ABUNDANCE ( NH ) - ABUNDANCE ( NPROTON )) ENDIF !C     Calculate the intial electron abundance, if not !C     specified, as the sum of the metal ion abundances IF ( ABUNDANCE ( NELECT ). LE . 0.0D0 ) THEN ABUNDANCE ( NELECT ) = 0.0D0 IF ( NCx . NE . 0 ) ABUNDANCE ( NELECT ) = ABUNDANCE ( NELECT ) + ABUNDANCE ( NCx ) IF ( NSx . NE . 0 ) ABUNDANCE ( NELECT ) = ABUNDANCE ( NELECT ) + ABUNDANCE ( NSx ) IF ( NNx . NE . 0 ) ABUNDANCE ( NELECT ) = ABUNDANCE ( NELECT ) + ABUNDANCE ( NNx ) IF ( NNAx . NE . 0 ) ABUNDANCE ( NELECT ) = ABUNDANCE ( NELECT ) + ABUNDANCE ( NNAx ) IF ( NMGx . NE . 0 ) ABUNDANCE ( NELECT ) = ABUNDANCE ( NELECT ) + ABUNDANCE ( NMGx ) IF ( NSIx . NE . 0 ) ABUNDANCE ( NELECT ) = ABUNDANCE ( NELECT ) + ABUNDANCE ( NSIx ) IF ( NFEx . NE . 0 ) ABUNDANCE ( NELECT ) = ABUNDANCE ( NELECT ) + ABUNDANCE ( NFEx ) IF ( NCLx . NE . 0 ) ABUNDANCE ( NELECT ) = ABUNDANCE ( NELECT ) + ABUNDANCE ( NCLx ) IF ( NCAx . NE . 0 ) ABUNDANCE ( NELECT ) = ABUNDANCE ( NELECT ) + ABUNDANCE ( NCAx ) IF ( NCAxx . NE . 0 ) ABUNDANCE ( NELECT ) = ABUNDANCE ( NELECT ) + 2.0D0 * ABUNDANCE ( NCAxx ) IF ( NPROTON . NE . 0 ) ABUNDANCE ( NELECT ) = ABUNDANCE ( NELECT ) + ABUNDANCE ( NPROTON ) ENDIF CLOSE ( SPECIESFILE ) RETURN END SUBROUTINE","tags":"","url":"sourcefile/read_species.f90.html"},{"title":"initialization.F90 – 3D-PDR","text":"This file depends on sourcefile~~initialization.f90~~EfferentGraph sourcefile~initialization.f90 initialization.F90 sourcefile~modules.f90 modules.F90 sourcefile~initialization.f90->sourcefile~modules.f90 sourcefile~definitions.f90 definitions.F90 sourcefile~modules.f90->sourcefile~definitions.f90 sourcefile~healpix_types.f90 healpix_types.F90 sourcefile~modules.f90->sourcefile~healpix_types.f90 sourcefile~healpix_types.f90->sourcefile~definitions.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code subroutine initialization use maincode_module do p = 1 , pdr_ptot allocate ( pdr ( p )% abundance ( 1 : nspec )) pdr ( p )% abundance = init_abundance #ifdef THERMALBALANCE pdr ( p )% dobinarychop = . false . #endif #ifdef RESTART pdr ( p )% restconverged = . false . #endif enddo write ( 6 , * ) 'Initialization' #ifdef RAYTHEIA_MO allocate ( epray ( 0 : nrays - 1 )) allocate ( plength ( 0 : nrays - 1 , 0 : maxpoints )) allocate ( projected ( 0 : nrays - 1 , 0 : maxpoints )) #endif do p = 1 , pdr_ptot allocate ( pdr ( p )% coolant ( 1 : coo )) do i = 1 , coo allocate ( pdr ( p )% coolant ( i )% pop ( coolant ( i )% cnlev )) allocate ( pdr ( p )% coolant ( i )% line ( coolant ( i )% cnlev , coolant ( i )% cnlev )) allocate ( pdr ( p )% coolant ( i )% solution ( coolant ( i )% cnlev )) allocate ( pdr ( p )% coolant ( i )% relativechange ( coolant ( i )% cnlev )) enddo #ifndef RAYTHEIA_MO allocate ( pdr ( p )% epray ( 0 : nrays - 1 )) #ifndef RAYTHEIA allocate ( pdr ( p )% epoint ( 1 : 3 , 0 : nrays - 1 , 0 : maxpoints )) #else allocate ( pdr ( p )% length ( 0 : nrays - 1 , 0 : maxpoints )) #endif allocate ( pdr ( p )% projected ( 0 : nrays - 1 , 0 : maxpoints )) #endif allocate ( pdr ( p )% raytype ( 0 : nrays - 1 )) allocate ( pdr ( p )% AV ( 0 : nrays - 1 )) allocate ( pdr ( p )% rad_surface ( 0 : nrays - 1 )) allocate ( pdr ( p )% column_NH2 ( 0 : nrays - 1 )) allocate ( pdr ( p )% column_NHD ( 0 : nrays - 1 )) allocate ( pdr ( p )% column_NCO ( 0 : nrays - 1 )) allocate ( pdr ( p )% column_NC ( 0 : nrays - 1 )) allocate ( pdr ( p )% column_NS ( 0 : nrays - 1 )) enddo #ifndef GUESS_TEMP do p = 1 , pdr_ptot pdr ( p )% nTgas = Tguess pdr ( p )% Tgas = Tguess #ifdef THERMALBALANCE pdr ( p )% Tlow = Tlow0 pdr ( p )% Thigh = Thigh0 #endif enddo #endif return end subroutine","tags":"","url":"sourcefile/initialization.f90.html"},{"title":"dust_t.F90 – 3D-PDR","text":"This file depends on sourcefile~~dust_t.f90~~EfferentGraph sourcefile~dust_t.f90 dust_t.F90 sourcefile~healpix_types.f90 healpix_types.F90 sourcefile~dust_t.f90->sourcefile~healpix_types.f90 sourcefile~modules.f90 modules.F90 sourcefile~dust_t.f90->sourcefile~modules.f90 sourcefile~definitions.f90 definitions.F90 sourcefile~healpix_types.f90->sourcefile~definitions.f90 sourcefile~modules.f90->sourcefile~healpix_types.f90 sourcefile~modules.f90->sourcefile~definitions.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !======================================================================= ! !  Calculate the dust temperature for each particle using the treatment !  of Hollenbach, Takahashi & Tielens (1991, ApJ, 377, 192, eqns 5 & 6) !  for the heating due to the incident FUV photons and the treatment of !  Meijerink & Spaans (2005, A&A, 436, 397, eqn B.6) for heating due to !  the incident flux of X-ray photons. ! !  Among other things, the dust temperature can influence: ! !     1) Cooling budget by emitting FIR photons that !        interact with the line radiative transfer; !     2) Gas-grain collisional heating or cooling rate; !     3) H2 formation by changing the sticking probability; !     4) Evaporation and condensation of molecules on grains. ! !  The formula derived by Hollenbach, Takahashi & Tielens (1991) has !  been modified to include the attenuation of the IR radiation. The !  incident FUV radiation is absorbed and re-emitted in the infrared !  by dust at the surface of the cloud (up to Av ~ 1mag). In the HTT !  derivation, this IR radiation then serves as a second heat source !  for dust deeper into the cloud. However, in their treatment, this !  second re-radiated component is not attenuated with distance into !  the cloud so it is *undiluted* with depth, leading to higher dust !  temperatures deep within the cloud which in turn heat the gas via !  collisions to unrealistically high temperatures. Models with high !  gas densities and high incident FUV fluxes (e.g. n_H = 10&#94;5 cm-3, !  X_0 = 10&#94;8 Draine) can produce T_gas ~ 100 K at Av ~ 50 mag! ! !  Attenuation of the FIR radiation has therefore been introduced by !  using an approximation for the infrared-only dust temperature from !  Rowan-Robinson (1980, eqn 30b): ! !  T_dust = T_0*(r/r_0)&#94;(-0.4) ! !  where r_0 is the cloud depth at which T_dust = T_0, corresponding !  to an A_V of ~ 1 mag, the assumed size of the outer region of the !  cloud that processes the incident FUV radiation and then re-emits !  it in the FIR (see the original HTT 1991 paper for details). This !  should prevent the dust temperature from dropping off too rapidly !  with distance and maintain a larger warm dust region (~50-100 K). ! !----------------------------------------------------------------------- SUBROUTINE CALCULATE_DUST_TEMPERATURES USE HEALPIX_TYPES USE MAINCODE_MODULE IMPLICIT NONE INTEGER ( KIND = I4B ) :: J REAL ( KIND = DP ) :: NU_0 , R_0 , T_0 , TAU_100 !  Parameters used in the HHT equations (see their paper for details) NU_0 = 2.65D15 TAU_100 = 1.0D-3 R_0 = 1.0D0 / AV_FAC DO P = 1 , pdr_ptot ! Loop over particles !     Calculate the contribution to the dust temperature from the local FUV flux and the CMB background PDR ( P )% Tdust = 8.9D-11 * NU_0 * ( 1.71D0 * PDR ( P )% UVfield ) + Tcmb ** 5 DO J = 0 , NRAYS - 1 ! Loop over rays !        The minimum dust temperature is related to the incident FUV flux along each ray !        Convert the incident FUV flux from Draine to Habing units by multiplying by 1.7 T_0 = 1 2.2 * ( 1.71D0 * PDR ( P )% RAD_SURFACE ( J )) ** 0.2 IF ( PDR ( P )% AV ( J ) > 1.0D0 ) T_0 = T_0 * PDR ( P )% AV ( J ) ** ( - 0.4 ) !        Add the contribution to the dust temperature from the FUV flux incident along this ray IF ( T_0 . GT . 0 ) PDR ( P )% Tdust = PDR ( P )% Tdust & & + ( 0.42 - LOG ( 3.45D-2 * TAU_100 * T_0 )) * ( 3.45D-2 * TAU_100 * T_0 ) * T_0 ** 5 END DO ! End of loop over rays !     Convert from total dust emission intensity to dust temperature PDR ( P )% Tdust = PDR ( P )% Tdust ** 0.2 !     Impose a lower limit on the dust temperature, since values below 10 K can dramatically !     limit the rate of H2 formation on grains (the molecule cannot desorb from the surface) IF ( PDR ( P )% Tdust . LT . 1 0.0D0 ) THEN PDR ( P )% Tdust = 1 0.0D0 END IF !     Check that the dust temperature is physical IF ( PDR ( P )% Tdust . GT . 1000 ) THEN WRITE ( 6 , * ) 'ERROR! Calculated dust temperature exceeds 1000 K' STOP END IF !PDR(P)%Tdust=20.0D0 END DO ! End of loop over particles RETURN END SUBROUTINE CALCULATE_DUST_TEMPERATURES !=======================================================================","tags":"","url":"sourcefile/dust_t.f90.html"},{"title":"checkconvergence.F90 – 3D-PDR","text":"This file depends on sourcefile~~checkconvergence.f90~~EfferentGraph sourcefile~checkconvergence.f90 checkconvergence.F90 sourcefile~healpix_types.f90 healpix_types.F90 sourcefile~checkconvergence.f90->sourcefile~healpix_types.f90 sourcefile~modules.f90 modules.F90 sourcefile~checkconvergence.f90->sourcefile~modules.f90 sourcefile~definitions.f90 definitions.F90 sourcefile~healpix_types.f90->sourcefile~definitions.f90 sourcefile~modules.f90->sourcefile~healpix_types.f90 sourcefile~modules.f90->sourcefile~definitions.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code subroutine checkconvergence use healpix_types use maincode_module use global_module #ifdef OPENMP !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(p,ilevel,k,RELCH) #endif do p = 1 , pdr_ptot pdr ( p )% coolant (:)% isconverged = . true . do k = 1 , coo DO ilevel = 1 , coolant ( k )% cnlev IF ( pdr ( p )% coolant ( k )% solution ( ilevel ). GE . pdr ( p )% abundance ( coolant ( k )% cspec ) * 1.0D-10 ) THEN IF ( pdr ( p )% coolant ( k )% solution ( ilevel ). EQ . 0.0D0 . AND . pdr ( p )% coolant ( k )% pop ( ilevel ). EQ . 0.0D0 ) THEN RELCH = 0.0D0 ELSE RELCH = 2.0D0 * ABS (( pdr ( p )% coolant ( k )% solution ( ilevel ) - pdr ( p )% coolant ( k )% pop ( ilevel ))& & / ( pdr ( p )% coolant ( k )% solution ( ilevel ) + pdr ( p )% coolant ( k )% pop ( ilevel ))) ENDIF IF ( RELCH . GT . 1.0D-2 ) then RELCH_conv = . false . pdr ( p )% coolant ( k )% isconverged = . false . ENDIF ENDIF ENDDO enddo pdr ( p )% levelconverged = all ([( pdr ( p )% coolant ( k )% isconverged , k = 1 , coo )]) enddo !p=1,pdr_ptot #ifdef OPENMP !$OMP END PARALLEL DO #endif return end subroutine","tags":"","url":"sourcefile/checkconvergence.f90.html"},{"title":"spline.F90 – 3D-PDR","text":"This file depends on sourcefile~~spline.f90~~EfferentGraph sourcefile~spline.f90 spline.F90 sourcefile~definitions.f90 definitions.F90 sourcefile~spline.f90->sourcefile~definitions.f90 sourcefile~healpix_types.f90 healpix_types.F90 sourcefile~spline.f90->sourcefile~healpix_types.f90 sourcefile~healpix_types.f90->sourcefile~definitions.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !======================================================================= ! !     Copied from Numerical Recipes ! ! Given a tabulated function YA (of size MxN) and tabulated independent ! variables X1A (M values) and X2A (N values), this routine constructs ! one-dimensional natural cubic splines of the rows of YA and returns ! the second derivatives in the array Y2A. ! !----------------------------------------------------------------------- SUBROUTINE SPLIE2 ( X1A , X2A , YA , M , N , Y2A ) USE DEFINITIONS USE HEALPIX_TYPES IMPLICIT NONE INTEGER ( KIND = I4B ), INTENT ( IN ) :: M , N REAL ( KIND = DP ), INTENT ( IN ) :: X1A ( 1 : M ), X2A ( 1 : N ), YA ( 1 : M , 1 : N ) REAL ( KIND = DP ), INTENT ( OUT ) :: Y2A ( 1 : M , 1 : N ) INTEGER ( KIND = I4B ) :: I , J REAL ( KIND = DP ) :: YTMP ( 1 : N ), Y2TMP ( 1 : N ) DO I = 1 , M DO J = 1 , N YTMP ( J ) = YA ( I , J ) ENDDO !        Values of 1.0D30 indicate a natural spline CALL SPLINE ( X2A , YTMP , N , 1.0D30 , 1.0D30 , Y2TMP ) DO J = 1 , N Y2A ( I , J ) = Y2TMP ( J ) ENDDO ENDDO RETURN END !======================================================================= !======================================================================= ! !     Calculate the cubic spline for a set of points (X,Y) !     (c.f. Numerical Recipes, Chapter 3.3: Spline Routine) ! !     Given the arrays X and Y (size N) containing a tabulated !     function, i.e., Y(I)=f(X(I)), with X(1) < X(2) < ... < X(N), !     and given values YP1 and YPN for the first derivative of the !     interpolating function at points 1 and N, respectively, this !     routine returns an array Y2 of length N, which contains the !     second derivatives of the interpolating function at the !     tabulated points X(I). If YP1 and/or YPN are equal to 1.0E+30 !     or larger, the routine is signalled to set the corresponding !     boundary condition for a natural spline, with zero second !     derivative at that boundary. ! !     I/O parameters: !     Input   X   = vector for independent variable; dimension X(1:N) !     Input   Y   = vector for x-dependent variable; dimension Y(1:N) !     Input   N   = dimension of vectors containing tabulated function !     Input   YP1 = 1st derivative of the function at point 1 !     Input   YPN = 1st derivative of the function at point N !     Output  Y2  = 2nd derivative of the function; dimension Y2(1:N) ! !----------------------------------------------------------------------- SUBROUTINE SPLINE ( X , Y , N , YP1 , YPN , Y2 ) USE DEFINITIONS USE HEALPIX_TYPES IMPLICIT NONE INTEGER ( KIND = I4B ), INTENT ( IN ) :: N REAL ( KIND = DP ), INTENT ( IN ) :: X ( 1 : N ), Y ( 1 : N ) REAL ( KIND = DP ), INTENT ( IN ) :: YP1 , YPN REAL ( KIND = DP ), INTENT ( OUT ) :: Y2 ( 1 : N ) INTEGER ( KIND = I4B ) :: I REAL ( KIND = DP ) :: P , QN , SIG , U ( 1 : N ), UN IF ( YP1 . GE . 1.0D30 ) THEN !        The lower boundary condition is either set to be \"natural\" Y2 ( 1 ) = 0.0D0 U ( 1 ) = 0.0D0 ELSE !        or to have a specified first derivative Y2 ( 1 ) =- 0.5D0 U ( 1 ) = ( 3.0D0 / ( X ( 2 ) - X ( 1 ))) * (( Y ( 2 ) - Y ( 1 )) / ( X ( 2 ) - X ( 1 )) - YP1 ) ENDIF !     This is the decomposition loop of the tridiagonal algorithm !     Y2 and U are used for temporary storage of the decomposed factors DO I = 2 , N - 1 SIG = ( X ( I ) - X ( I - 1 )) / ( X ( I + 1 ) - X ( I - 1 )) P = SIG * Y2 ( I - 1 ) + 2.0D0 Y2 ( I ) = ( SIG - 1.0D0 ) / P U ( I ) = ( 6.0D0 * (( Y ( I + 1 ) - Y ( I )) / ( X ( I + 1 ) - X ( I )) - ( Y ( I ) - Y ( I - 1 ))& & / ( X ( I ) - X ( I - 1 ))) / ( X ( I + 1 ) - X ( I - 1 )) - SIG * U ( I - 1 )) / P ENDDO IF ( YPN . GE . 1.0D30 ) THEN !        The upper boundary condition is either set to be \"natural\" QN = 0.0D0 UN = 0.0D0 ELSE !        or to have a specified first derivative QN = 0.5D0 UN = ( 3.0D0 / ( X ( N ) - X ( N - 1 ))) * ( YPN - ( Y ( N ) - Y ( N - 1 )) / ( X ( N ) - X ( N - 1 ))) ENDIF Y2 ( N ) = ( UN - QN * U ( N - 1 )) / ( QN * Y2 ( N - 1 ) + 1.0D0 ) !     This is the back-substitution loop of the tridiagonal algorithm DO I = N - 1 , 1 , - 1 Y2 ( I ) = Y2 ( I ) * Y2 ( I + 1 ) + U ( I ) ENDDO RETURN END !======================================================================= !======================================================================= ! !     Given X1A, X2A, YA, M, N (as described in SPLIE2) and Y2A (as !     produced by that routine), and given a desired interpolating !     point (X1,X2), this routine returns an interpolated function !     value Y by performing a bicubic spline interpolation. ! !----------------------------------------------------------------------- SUBROUTINE SPLIN2 ( X1A , X2A , YA , Y2A , M , N , X1 , X2 , Y ) USE DEFINITIONS USE HEALPIX_TYPES IMPLICIT NONE INTEGER ( KIND = I4B ), INTENT ( IN ) :: M , N REAL ( KIND = DP ), INTENT ( IN ) :: X1A ( 1 : M ), X2A ( 1 : N ), YA ( 1 : M , 1 : N ), Y2A ( 1 : M , 1 : N ) REAL ( KIND = DP ), INTENT ( IN ) :: X1 , X2 REAL ( KIND = DP ), INTENT ( OUT ) :: Y INTEGER ( KIND = I4B ) :: I , J REAL ( KIND = DP ) :: YTMP ( 1 : N ), Y2TMP ( 1 : N ), YYTMP ( 1 : M ), YY2TMP ( 1 : M ) !     Perform M evaluations of the row splines constructed by !     SPLIE2 using the one-dimensional spline evaluator SPLINT DO I = 1 , M DO J = 1 , N YTMP ( J ) = YA ( I , J ) Y2TMP ( J ) = Y2A ( I , J ) ENDDO CALL SPLINT ( X2A , YTMP , Y2TMP , N , X2 , YYTMP ( I )) ENDDO !     Construct the one-dimensional column spline and evaluate it !     Values of 1.0D30 indicate a natural spline CALL SPLINE ( X1A , YYTMP , M , 1.0D30 , 1.0D30 , YY2TMP ) CALL SPLINT ( X1A , YYTMP , YY2TMP , M , X1 , Y ) RETURN END !======================================================================= !======================================================================= ! !     Perform a cubic spline interpolation evaluated at the point X !     (c.f. Numerical Recipes, Chapter 3.3: Splint Routine, !           Numerical Recipes, Chapter 3.4: Hunt Routine) ! !     Given the arrays XA and YA (size N) containing a tabulated !     function, i.e., YA(I) = f(XA(I)), with the XA(I)'s in order, !     and given the array Y2A produced by the SPLINE routine, this !     routine returns a cubic spline interpolated value Y. ! !     I/O parameters: !     Input   XA  = vector for independent variable; dimension XA(1:N) !     Input   YA  = vector for x-dependent variable; dimension YA(1:N) !     Input   Y2A = 2nd derivative of the function; dimension Y2A(1:N) !     Input   N   = dimension of input vectors !     Input   X   = x-value at which Y is to be interpolated !     Output  Y   = result of interpolation ! !----------------------------------------------------------------------- SUBROUTINE SPLINT ( XA , YA , Y2A , N , X , Y ) USE DEFINITIONS USE HEALPIX_TYPES IMPLICIT NONE INTEGER ( KIND = I4B ), INTENT ( IN ) :: N REAL ( KIND = DP ), INTENT ( IN ) :: XA ( 1 : N ), YA ( 1 : N ), Y2A ( 1 : N ) REAL ( KIND = DP ), INTENT ( IN ) :: X REAL ( KIND = DP ), INTENT ( OUT ) :: Y LOGICAL :: ASCND INTEGER ( KIND = I4B ) :: JLO , JHI , JMID , INC REAL ( KIND = DP ) :: A , B JLO = 0 JHI = 0 !     ASCND is TRUE if the table values are in ascending order, FALSE otherwise ASCND = XA ( N ). GT . XA ( 1 ) !     Find the interval XA(JLO) <= X <= XA(JLO+1) = XA(JHI) IF ( JLO . LE . 0 . OR . JLO . GT . N ) THEN !        Input guess not useful, go immediately to bisection JLO = 0 JHI = N + 1 GOTO 300 ENDIF !     Set the hunting increment INC = 1 IF ( X . GE . XA ( JLO ) . EQV . ASCND ) THEN !        Hunt up: 100 JHI = JLO + INC IF ( JHI . GT . N ) THEN !           Done hunting, since off the end of the table JHI = N + 1 ELSE IF ( X . GE . XA ( JHI ) . EQV . ASCND ) THEN !           Not done hunting... JLO = JHI !           ...so double the increment... INC = INC + INC !           ...and try again GOTO 100 ENDIF !     Done hunting, value bracketed ELSE JHI = JLO !        Hunt down: 200 JLO = JHI - INC IF ( JLO . LT . 1 ) THEN !           Done hunting, since off the end of the table JLO = 0 ELSE IF ( X . LT . XA ( JLO ) . EQV . ASCND ) THEN !           Not done hunting... JHI = JLO !           ...so double the increment... INC = INC + INC !           ...and try again GOTO 200 ENDIF !     Done hunting, value bracketed ENDIF 300 IF (( JHI - JLO ). NE . 1 ) THEN !        Hunt is done, so begin the final bisection phase JMID = ( JHI + JLO ) / 2 IF ( X . GT . XA ( JMID ) . EQV . ASCND ) THEN JLO = JMID ELSE JHI = JMID ENDIF GOTO 300 ENDIF IF ( JLO . EQ . 0 ) THEN JLO = 1 JHI = 2 ENDIF IF ( JLO . EQ . N ) THEN JLO = N - 1 JHI = N ENDIF !     JLO and JHI now bracket the input value X !     The cubic spline polynomial is now evaluated A = ( XA ( JHI ) - X ) / ( XA ( JHI ) - XA ( JLO )) B = ( X - XA ( JLO )) / ( XA ( JHI ) - XA ( JLO )) Y = A * YA ( JLO ) + B * YA ( JHI ) + (( A ** 3 - A ) * Y2A ( JLO ) + ( B ** 3 - B ) * Y2A ( JHI ))& & * (( XA ( JHI ) - XA ( JLO )) ** 2 ) / 6.0D0 RETURN END !=======================================================================","tags":"","url":"sourcefile/spline.f90.html"},{"title":"eval_points.F90 – 3D-PDR","text":"This file depends on sourcefile~~eval_points.f90~~EfferentGraph sourcefile~eval_points.f90 eval_points.F90 sourcefile~definitions.f90 definitions.F90 sourcefile~eval_points.f90->sourcefile~definitions.f90 sourcefile~healpix_types.f90 healpix_types.F90 sourcefile~eval_points.f90->sourcefile~healpix_types.f90 sourcefile~m_mesh.f90 m_Mesh.F90 sourcefile~eval_points.f90->sourcefile~m_mesh.f90 sourcefile~m_ray_box.f90 m_Ray_box.F90 sourcefile~eval_points.f90->sourcefile~m_ray_box.f90 sourcefile~modules.f90 modules.F90 sourcefile~eval_points.f90->sourcefile~modules.f90 sourcefile~healpix_types.f90->sourcefile~definitions.f90 sourcefile~m_ray_box.f90->sourcefile~m_mesh.f90 sourcefile~modules.f90->sourcefile~definitions.f90 sourcefile~modules.f90->sourcefile~healpix_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code subroutine evaluation_points !calculation of evaluation points !T.Bisbas use definitions use healpix_types use healpix_module use maincode_module use m_Mesh use m_Ray_box #ifdef OPENMP use omp_lib #endif double precision :: adaptivemin logical :: killray ( 0 : nrays - 1 ) integer :: j #ifndef RAYTHEIA_MO #ifdef RAYTHEIA #ifdef OPENMP !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(p, j, box1, thfpix, phfpix, ray) #endif do p = 1 , pdr_ptot box1 % min = corner_min box1 % max = corner_max pdr ( p )% epray = 0 do j = 0 , nrays - 1 call pix2ang_nest ( nside , j , thfpix , phfpix ) ray % origin = [ pdr ( p )% x , pdr ( p )% y , pdr ( p )% z ] ray % angle = [ thfpix , phfpix ] call raytheia_table ( ray , box1 , levels - 1 , p , j ) enddo enddo #ifdef OPENMP !$OMP END PARALLEL DO #endif #else !BUILDING HEALPIX VECTORS FOR ALL PDR ELEMENTS. !PARALLEL PROCESS----------------------------- #ifdef OPENMP !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(origin, p, ra, rb, ep) & !$OMP PRIVATE(i, rvec, theta, phi, ipix, ktot, radius) & !$OMP PRIVATE(j, healpixvector, angle_los, id, killray) REDUCTION (+ : kk) #endif do p = 1 , pdr_ptot !defines the origin to transfer all the domain in the original co-ordinate system killray = . false . origin ( 1 : 3 ) = pdrpoint ( 1 : 3 , p ) allocate ( ra ( 0 : pdr_ptot - 1 )) !needs one extra place for sorting in heapsort allocate ( rb ( 1 : pdr_ptot - 1 )) !-1 to avoid overlapping origin & pdrpoint allocate ( ep ( 1 : 3 , 0 : nrays - 1 )) !calculating distances from the origin(1:3) kk = 0 pdr ( p )% epray = 0 do i = 1 , pdr_ptot if ( i . eq . p ) cycle kk = kk + 1 !locates the grid point in the new computational domain rvec ( 1 ) = pdr ( i )% x - origin ( 1 ) rvec ( 2 ) = pdr ( i )% y - origin ( 2 ) rvec ( 3 ) = pdr ( i )% z - origin ( 3 ) !next two lines return the ipix ray that the rvec(1:3) point belongs to. call vec2ang ( rvec , theta , phi ) call ang2pix_nest_id ( nside , theta , phi , ipix ) ra ( kk ) = sqrt ( rvec ( 1 ) ** 2 + rvec ( 2 ) ** 2 + rvec ( 3 ) ** 2 ) rb ( kk ) = i !stores the identifier of each grid point enddo ktot = kk !ktot should be pdr_ptot-1 if ( ktot . ne .( pdr_ptot - 1 )) then write ( 6 , * ) 'ktot = ' , ktot , ' pdr_ptot-1 = ' , pdr_ptot - 1 stop 'ktot is not equal to pdr_ptot-1 !!' endif !calling heapsort and sorting with increasing the distance from the origin(1:3) call heapsort ( ktot , rb , ra ) !maximum distance from origin(1:3). This is the radius at !which the HEALPix vectors should expand. radius = ra ( ktot ) !gives values for the first evaluation point which is the origin (1:3) ep = 0. do j = 0 , nrays - 1 pdr ( p )% epoint ( 1 : 3 , j , 0 ) = origin ( 1 : 3 ) end do !loops over all the domain and finds evaluation points. [straight N loop] do k = 1 , ktot !locates the grid point in the new computational domain rvec ( 1 ) = pdr ( rb ( k ))% x - origin ( 1 ) rvec ( 2 ) = pdr ( rb ( k ))% y - origin ( 2 ) rvec ( 3 ) = pdr ( rb ( k ))% z - origin ( 3 ) !next two lines return the ipix ray that the rvec(1:3) point belongs to. call vec2ang ( rvec , theta , phi ) call ang2pix_nest_id ( nside , theta , phi , ipix ) if ( killray ( ipix )) cycle healpixvector ( 1 : 3 ) = 1.1_DP * radius * vectors ( 1 : 3 , ipix ) !expand unit healpix vectors !calculates the angle along the line of sight of EVALUATION POINT -- HEALPIXVECTOR angle_los = acos ( dot_product ( rvec ( 1 : 3 ) - ep ( 1 : 3 , ipix ), healpixvector ( 1 : 3 ) - ep ( 1 : 3 , ipix )) / & &( sqrt (( rvec ( 1 ) - ep ( 1 , ipix )) ** 2 + ( rvec ( 2 ) - ep ( 2 , ipix )) ** 2 + ( rvec ( 3 ) - ep ( 3 , ipix )) ** 2 ) * & & sqrt (( healpixvector ( 1 ) - ep ( 1 , ipix )) ** 2 + ( healpixvector ( 2 ) - ep ( 2 , ipix )) ** 2 + & &( healpixvector ( 3 ) - ep ( 3 , ipix )) ** 2 ))) !if the angle is less than the critical theta (user defined), then we have a new !evaluation point. This point is the projection of the grid point in the above line of sight. !if ((angle_los.le.theta_crit).and.(angle_los.ge.0D0)) then if ( angle_los . le . theta_crit ) then !All next if-statements are conditions to avoid division by zero (i.e. x-plane, y-plane, z-plane) if ( healpixvector ( 3 ). ne . 0.0_dp ) then ep ( 3 , ipix ) = ( healpixvector ( 1 ) * healpixvector ( 3 ) * rvec ( 1 ) + healpixvector ( 2 ) * healpixvector ( 3 ) * & & rvec ( 2 ) + ( healpixvector ( 3 ) ** 2 ) * rvec ( 3 )) / ( healpixvector ( 1 ) ** 2 + healpixvector ( 2 ) ** 2 + & & healpixvector ( 3 ) ** 2 ) ep ( 2 , ipix ) = ep ( 3 , ipix ) * healpixvector ( 2 ) / healpixvector ( 3 ) ep ( 1 , ipix ) = ep ( 3 , ipix ) * healpixvector ( 1 ) / healpixvector ( 3 ) else if ( healpixvector ( 1 ). eq . 0.0_dp ) then ep ( 1 , ipix ) = 0.0_dp ep ( 2 , ipix ) = rvec ( 2 ) ep ( 3 , ipix ) = 0.0_dp else if ( healpixvector ( 2 ). eq . 0.0_dp ) then ep ( 1 , ipix ) = rvec ( 1 ) ep ( 2 , ipix ) = 0.0_dp ep ( 3 , ipix ) = 0.0_dp else ep ( 3 , ipix ) = 0.0_dp ep ( 1 , ipix ) = (( healpixvector ( 1 ) ** 2 ) * rvec ( 1 ) + healpixvector ( 1 ) * healpixvector ( 2 ) * rvec ( 2 )) / & &( healpixvector ( 1 ) ** 2 + healpixvector ( 2 ) ** 2 ) ep ( 2 , ipix ) = ep ( 1 , ipix ) * healpixvector ( 2 ) / healpixvector ( 1 ) endif endif !healpixvector(3) !       !updates memory and stores the evaluation point in the original computational domain (so evaluation point + origin) pdr ( p )% epray ( ipix ) = pdr ( p )% epray ( ipix ) + 1 id = pdr ( p )% epray ( ipix ) if ( pdr ( p )% epray ( ipix ). gt . maxpoints ) STOP 'Increase maxpoints!' pdr ( p )% epoint ( 1 : 3 , ipix , id ) = ep ( 1 : 3 , ipix ) + origin ( 1 : 3 ) pdr ( p )% projected ( ipix , id ) = rb ( k ) if ( pdr ( rb ( k ))% etype . eq . 2 ) killray ( ipix ) = . true . endif !angle_los enddo !k=1,ktot deallocate ( ra ) deallocate ( rb ) deallocate ( ep ) enddo !p/p=1,pdr_ptot #ifdef OPENMP !$OMP END PARALLEL DO #endif suma = 0 do p = 1 , pdr_ptot suma = suma + sum ( pdr ( p )% epray (:)) enddo write ( 6 , * ) 'No. evaluation points:' , suma #ifndef ONEDIMENSIONAL write ( 6 , * ) 'Checking for negative steps...' adaptivemin = 10 0.0D0 do p = 1 , pdr_ptot do j = 0 , nrays - 1 if ( pdr ( p )% epray ( j ). gt . 0 ) then do i = 1 , pdr ( p )% epray ( j ) adaptive_step = sqrt (( pdr ( p )% epoint ( 1 , j , 0 ) - pdr ( p )% epoint ( 1 , j , i )) ** 2 + & &( pdr ( p )% epoint ( 2 , j , 0 ) - pdr ( p )% epoint ( 2 , j , i )) ** 2 + & &( pdr ( p )% epoint ( 3 , j , 0 ) - pdr ( p )% epoint ( 3 , j , i )) ** 2 ) - & & sqrt (( pdr ( p )% epoint ( 1 , j , 0 ) - pdr ( p )% epoint ( 1 , j , i - 1 )) ** 2 + & &( pdr ( p )% epoint ( 2 , j , 0 ) - pdr ( p )% epoint ( 2 , j , i - 1 )) ** 2 + & &( pdr ( p )% epoint ( 3 , j , 0 ) - pdr ( p )% epoint ( 3 , j , i - 1 )) ** 2 ) if ( adaptive_step . lt . 0 ) stop 'found negative adaptive step!' if ( adaptive_step . lt . adaptivemin ) adaptivemin = adaptive_step enddo endif enddo enddo #endif write ( 6 , * ) 'No negative steps found' !write(6,*) 'Minimum adaptive step = ',adaptivemin write ( 6 , * ) 'Assigning raytypes' do p = 1 , pdr_ptot allocate ( pdr ( p )% raytype ( 0 : nrays - 1 )) do j = 0 , nrays - 1 if ( pdr ( p )% epray ( j ). gt . 0 ) then pdr ( p )% raytype ( j ) = - pdr ( pdr ( p )% projected ( j , pdr ( p )% epray ( j )))% etype else pdr ( p )% raytype ( j ) = - pdr ( p )% etype endif enddo enddo !ENDIF RAYTHEIA #endif #endif return end subroutine evaluation_points","tags":"","url":"sourcefile/eval_points.f90.html"},{"title":"read_rates.F90 – 3D-PDR","text":"This file depends on sourcefile~~read_rates.f90~~EfferentGraph sourcefile~read_rates.f90 read_rates.F90 sourcefile~definitions.f90 definitions.F90 sourcefile~read_rates.f90->sourcefile~definitions.f90 sourcefile~healpix_types.f90 healpix_types.F90 sourcefile~read_rates.f90->sourcefile~healpix_types.f90 sourcefile~modules.f90 modules.F90 sourcefile~read_rates.f90->sourcefile~modules.f90 sourcefile~healpix_types.f90->sourcefile~definitions.f90 sourcefile~modules.f90->sourcefile~definitions.f90 sourcefile~modules.f90->sourcefile~healpix_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !C*********************************************************************** !C     Read in the chemical reaction rates and the species, masses and !C     initial abundances (if specified). The  rates and species files !C     are assumed to have comma separated values (CSV) format. This is !C     in line with the Rate05 formatting, removing the need for file- !C     dependent FORMAT statements. !C*********************************************************************** ! SUBROUTINE READ_RATES ( NREAC , REAC , PROD , ALPHA , BETA , GAMMA , RATE ,& & DUPLICATE , RTMIN , RTMAX ) !T.Bell use definitions use healpix_types use global_module IMPLICIT NONE INTEGER ( kind = i4b ), intent ( in ) :: NREAC integer ( kind = i4b ), intent ( out ) :: DUPLICATE ( 1 : nreac ) real ( kind = dp ), intent ( out ) :: ALPHA ( 1 : nreac ), BETA ( 1 : nreac ),& & GAMMA ( 1 : nreac ), RATE ( 1 : nreac ), RTMIN ( 1 : nreac ), RTMAX ( 1 : nreac ) CHARACTER ( len = 10 ), intent ( out ) :: REAC ( 1 : nreac , 1 : 3 ), PROD ( 1 : nreac , 1 : 4 ) INTEGER ( kind = i4b ) :: I , J , N , RATEFILE CHARACTER ( len = 1 ) :: CLEM character ( len = 50 ) :: suffix RATEFILE = 2 !C     Initialize the variables and read in the ratefile data. Check that !C     the value of NREAC agrees with the number of reactions in the file !C     and produce an error message if not. REAC = \"          \" PROD = \"          \" ALPHA = 0.0D0 BETA = 0.0D0 GAMMA = 0.0D0 RTMIN = 0.0D0 RTMAX = 0.0D0 DUPLICATE = 0 RATE = 0.0D0 #ifdef REDUCED suffix = 'reduced.d' #elif MEDIUM suffix = 'medium.d' #elif FULL suffix = 'full.d' #elif MYNETWORK suffix = 'mynetwork.d' #endif OPEN ( RATEFILE , FILE = \"chemfiles/rates_\" // trim ( adjustl ( suffix )), STATUS = \"OLD\" ) REWIND ( RATEFILE ) DO I = 1 , NREAC READ ( RATEFILE , * , END = 1 ) N ,( REAC ( I , J ), J = 1 , 3 ),( PROD ( I , J ), J = 1 , 4 ),& & ALPHA ( I ), BETA ( I ), GAMMA ( I ), & & CLEM , RTMIN ( I ), RTMAX ( I ) IF ( CLEM . NE . \"\" ) CLEM = \"\" !C     Check for duplicate reactions and set the DUPLICATE counter to the !C     appropriate value. Adjust their minimum temperatures so that the !C     temperature ranges are adjacent. IF ( I . GT . 1 ) THEN IF ( REAC ( I , 1 ). EQ . REAC ( I - 1 , 1 ) . AND . & & REAC ( I , 2 ). EQ . REAC ( I - 1 , 2 ) . AND . REAC ( I , 3 ). EQ . REAC ( I - 1 , 3 ) . AND . & & PROD ( I , 1 ). EQ . PROD ( I - 1 , 1 ) . AND . PROD ( I , 2 ). EQ . PROD ( I - 1 , 2 ) . AND . & & PROD ( I , 3 ). EQ . PROD ( I - 1 , 3 ) . AND . PROD ( I , 4 ). EQ . PROD ( I - 1 , 4 )) THEN IF ( DUPLICATE ( I - 1 ). EQ . 0 ) DUPLICATE ( I - 1 ) = 1 DUPLICATE ( I ) = DUPLICATE ( I - 1 ) + 1 RTMIN ( I ) = RTMAX ( I - 1 ) ELSE DUPLICATE ( I ) = 0 ENDIF ELSE DUPLICATE ( I ) = 0 ENDIF !C     Check for negative gamma values as they could cause problems when !C     calculating abundances. Produce a warning message if they occur. IF ( GAMMA ( I ). LT . 0.0D0 ) THEN write ( 6 , * ) 'Negative gamma factor in rate' , N !WRITE(10,\"('Negative gamma factor in rate',I5,' (',F8.1,')')\")& !&         N,GAMMA(I) ENDIF ENDDO I = I - 1 READ ( RATEFILE , * , END = 1 ) I = I + 1 1 IF ( I . NE . NREAC ) THEN write ( 6 , * ) 'ERROR! Number of reactions (NREAC) does not match ' , & & 'the number of entries in the ratefile' STOP ENDIF CLOSE ( RATEFILE ) RETURN END SUBROUTINE !C-----------------------------------------------------------------------","tags":"","url":"sourcefile/read_rates.f90.html"},{"title":"coolingfunctions.F90 – 3D-PDR","text":"This file depends on sourcefile~~coolingfunctions.f90~~EfferentGraph sourcefile~coolingfunctions.f90 coolingfunctions.F90 sourcefile~healpix_types.f90 healpix_types.F90 sourcefile~coolingfunctions.f90->sourcefile~healpix_types.f90 sourcefile~m_ray_box.f90 m_Ray_box.F90 sourcefile~coolingfunctions.f90->sourcefile~m_ray_box.f90 sourcefile~modules.f90 modules.F90 sourcefile~coolingfunctions.f90->sourcefile~modules.f90 sourcefile~definitions.f90 definitions.F90 sourcefile~healpix_types.f90->sourcefile~definitions.f90 sourcefile~m_mesh.f90 m_Mesh.F90 sourcefile~m_ray_box.f90->sourcefile~m_mesh.f90 sourcefile~modules.f90->sourcefile~healpix_types.f90 sourcefile~modules.f90->sourcefile~definitions.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code subroutine coolingfunctions use healpix_types use maincode_module use global_module use m_Ray_box #ifdef RAYTHEIA_MO #ifdef OPENMP !$OMP PARALLEL DO SCHEDULE(GUIDED) DEFAULT(SHARED) PRIVATE(cpop,temp_line,p,j,i,k,ilevel) & !$OMP PRIVATE(temp_C_COEFFS, temp_transition, temp_solution) & !$OMP PRIVATE(thfpix,phfpix,ray,box1,epray,projected,plength) #endif #else #ifdef OPENMP !$OMP PARALLEL DO SCHEDULE(GUIDED) DEFAULT(SHARED) PRIVATE(cpop,temp_line,p,j,i,k,ilevel) & !$OMP PRIVATE(temp_C_COEFFS, temp_transition, temp_solution) #endif #endif do p = 1 , pdr_ptot !---------------------------------------------- #ifdef THERMALBALANCE if ( pdr ( p )% levelconverged . or . pdr ( p )% fullyconverged ) cycle #else if ( pdr ( p )% levelconverged ) cycle #endif !---------------------------------------------- #ifdef RAYTHEIA_MO box1 % min = corner_min box1 % max = corner_max epray = 0 projected = p plength = 0.D0 do j = 0 , nrays - 1 call pix2ang_nest ( nside , j , thfpix , phfpix ) ray % origin = [ pdr ( p )% x , pdr ( p )% y , pdr ( p )% z ] ray % angle = [ thfpix , phfpix ] call raytheia ( ray , box1 , levels - 1 , j , epray , projected , plength ) enddo #else pdr ( p )% projected (:, 0 ) = p #endif ! Specify the evaluation points along each ray from the current pdrpoint allocate ( cpop ( 1 : coo )) do k = 1 , coo allocate ( cpop ( k )% evalpop ( 0 : nrays - 1 , 0 : maxpoints , 1 : coolant ( k )% cnlev )) cpop ( k )% evalpop = 0.0D0 do j = 0 , nrays - 1 #ifdef RAYTHEIA_MO do i = 0 , epray ( j ) do ilevel = 1 , coolant ( k )% cnlev cpop ( k )% evalpop ( j , i , ilevel ) = pdr ( int ( projected ( j , i )))% coolant ( k )% pop ( ilevel ) enddo enddo enddo #else do i = 0 , pdr ( p )% epray ( j ) do ilevel = 1 , coolant ( k )% cnlev cpop ( k )% evalpop ( j , i , ilevel ) = pdr ( int ( pdr ( p )% projected ( j , i )))% coolant ( k )% pop ( ilevel ) enddo enddo enddo #endif ! Use the LVG (escape probability) method to determine the transition matrices and solve for the level populations allocate ( temp_C_COEFFS ( 1 : coolant ( k )% cnlev , 1 : coolant ( k )% cnlev )) allocate ( temp_line ( 1 : coolant ( k )% cnlev , 1 : coolant ( k )% cnlev )) allocate ( temp_transition ( 1 : coolant ( k )% cnlev , 1 : coolant ( k )% cnlev )) allocate ( temp_solution ( 1 : coolant ( k )% cnlev )) CALL FIND_CCOEFF ( coolant ( k )% cntemp , coolant ( k )% cnlev , pdr ( p )% nTgas , coolant ( k )% temperatures ,& & coolant ( k )% H_COL , coolant ( k )% HP_COL , coolant ( k )% EL_COL , coolant ( k )% HE_COL , coolant ( k )% H2_COL ,& & coolant ( k )% PH2_COL , coolant ( k )% OH2_COL , temp_C_COEFFS , pdr ( p )% abundance ( NH ) * pdr ( p )% rho ,& & pdr ( p )% abundance ( NPROTON ) * pdr ( p )% rho , pdr ( p )% abundance ( NELECT ) * pdr ( p )% rho , & & pdr ( p )% abundance ( NHE ) * pdr ( p )% rho , pdr ( p )% abundance ( NH2 ) * pdr ( p )% rho ) #ifdef RAYTHEIA_MO call escape_probability ( temp_transition , pdr ( p )% Tdust , nrays , coolant ( k )% cnlev , & & coolant ( k )% A_COEFFS , coolant ( k )% B_COEFFS , temp_C_COEFFS , & & coolant ( k )% frequencies , cpop ( k )% evalpop , maxpoints , & & pdr ( p )% nTgas , v_turb , epray , pdr ( p )% coolant ( k )% pop , & & coolant ( k )% weights , pdr ( p )% cooling ( k ), temp_line ,& & pdr ( p )% rho , metallicity , coolant ( k )% molweight , plength ) #else #ifdef RAYTHEIA call escape_probability ( temp_transition , pdr ( p )% Tdust , nrays , coolant ( k )% cnlev , & & coolant ( k )% A_COEFFS , coolant ( k )% B_COEFFS , temp_C_COEFFS , & & coolant ( k )% frequencies , cpop ( k )% evalpop , maxpoints , & & pdr ( p )% nTgas , v_turb , pdr ( p )% epray , pdr ( p )% coolant ( k )% pop , & & coolant ( k )% weights , pdr ( p )% cooling ( k ), temp_line ,& & pdr ( p )% rho , metallicity , coolant ( k )% molweight , pdr ( p )% length ) #else call escape_probability ( temp_transition , pdr ( p )% Tdust , nrays , coolant ( k )% cnlev , & & coolant ( k )% A_COEFFS , coolant ( k )% B_COEFFS , temp_C_COEFFS , & & coolant ( k )% frequencies , cpop ( k )% evalpop , maxpoints , & & pdr ( p )% nTgas , v_turb , pdr ( p )% epray , pdr ( p )% coolant ( k )% pop , & & pdr ( p )% epoint , coolant ( k )% weights , pdr ( p )% cooling ( k ), temp_line ,& & pdr ( p )% rho , metallicity , coolant ( k )% molweight ) #endif #endif pdr ( p )% coolant ( k )% line = temp_line call solvlevpop ( coolant ( k )% cnlev , temp_transition , pdr ( p )% abundance ( coolant ( k )% cspec ) * pdr ( p )% rho ,& temp_solution ) pdr ( p )% coolant ( k )% solution = temp_solution deallocate ( temp_C_COEFFS ) deallocate ( temp_line ) deallocate ( temp_transition ) deallocate ( temp_solution ) deallocate ( cpop ( k )% evalpop ) enddo deallocate ( cpop ) #ifdef FORCECONVERGENCE ! If the level populations are oscillating and not converging, try to suppress the oscillations ! by taking the average of the level populations from this iteration and the previous iteration if ( all ([( int ( coolant ( k )% percentage ) == 100 , k = 2 , 4 )])) then !special treatment of coolants other than C+,C,O if ( levpop_iteration . ge . 120 ) then pdr ( p )% coolant ( 1 )% solution = pdr ( p )% coolant ( 1 )% pop else if ( levpop_iteration . ge . 75 ) then pdr ( p )% coolant ( 1 )% solution = 0.5 * ( pdr ( p )% coolant ( 1 )% solution + pdr ( p )% coolant ( 1 )% pop ) endif endif do k = 2 , coo if ( levpop_iteration . ge . 120 ) then pdr ( p )% coolant ( k )% solution = pdr ( p )% coolant ( k )% pop else if ( levpop_iteration . ge . 75 ) then pdr ( p )% coolant ( k )% solution = 0.5 * ( pdr ( p )% coolant ( k )% solution + pdr ( p )% coolant ( k )% pop ) endif enddo #endif !------------------------------------------------------------------- pdr ( p )% totalcooling = sum ( pdr ( p )% cooling (:)) enddo !particles #ifdef OPENMP !$OMP END PARALLEL DO #endif return end subroutine","tags":"","url":"sourcefile/coolingfunctions.f90.html"},{"title":"chemicaliterations.F90 – 3D-PDR","text":"This file depends on sourcefile~~chemicaliterations.f90~~EfferentGraph sourcefile~chemicaliterations.f90 chemicaliterations.F90 sourcefile~healpix_types.f90 healpix_types.F90 sourcefile~chemicaliterations.f90->sourcefile~healpix_types.f90 sourcefile~modules.f90 modules.F90 sourcefile~chemicaliterations.f90->sourcefile~modules.f90 sourcefile~definitions.f90 definitions.F90 sourcefile~healpix_types.f90->sourcefile~definitions.f90 sourcefile~modules.f90->sourcefile~healpix_types.f90 sourcefile~modules.f90->sourcefile~definitions.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code subroutine chemicaliterations ( iw , ichem ) use healpix_types use maincode_module use global_module use maincode_local integer , intent ( in ) :: iw , ichem integer , parameter :: npart = 1 DO II = 1 , ichem write ( 6 , '(\" Chemical iteration = \",I2)' ) ii #ifdef OPENMP !$OMP PARALLEL DO SCHEDULE(GUIDED) DEFAULT(SHARED) PRIVATE (p,rate,NRGR,NRH2,NRHD,NRCO,NRCI,NRSI) #endif do p = 1 , pdr_ptot #ifdef THERMALBALANCE if ( iw . eq . 2. and . pdr ( p )% fullyconverged ) cycle #endif CALL CALCULATE_REACTION_RATES ( pdr ( p )% nTgas , pdr ( p )% Tdust , nrays , pdr ( p )% rad_surface ( 0 : nrays - 1 ), pdr ( p )% AV ( 0 : nrays - 1 ),& & pdr ( p )% column_NH2 ( 0 : nrays - 1 ), pdr ( p )% column_NHD ( 0 : nrays - 1 ), pdr ( p )% column_NCO ( 0 : nrays - 1 ),& & pdr ( p )% column_NC ( 0 : nrays - 1 ), pdr ( p )% column_NS ( 0 : nrays - 1 ),& & nreac , reactant , product , alpha , beta , gamma , rate , rtmin , rtmax , duplicate , nspec ,& & NRGR , NRH2 , NRHD , NRCO , NRCI , NRSI , pdr ( p )% abundance ( NELECT ) * pdr ( p )% rho , pdr ( p )% rho , pdr ( p )% zetalocal ) call calculate_abundances ( pdr ( p )% abundance , rate , pdr ( p )% rho , pdr ( p )% nTgas , npart , nspec , nreac ) #ifdef CHEMANALYSIS temp_rate (:, p ) = rate #endif enddo #ifdef OPENMP !$OMP END PARALLEL DO #endif call calc_columndens ENDDO #ifdef OPENMP !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(p,i,temp_Z_function) #endif do p = 1 , pdr_ptot do i = 1 , coo call calculate_partition_function ( temp_Z_function , coolant ( i )% cnlev ,& coolant ( i )% energies , coolant ( i )% weights , pdr ( p )% nTgas ) call calculate_lte_populations ( coolant ( i )% cnlev , pdr ( p )% coolant ( i )% pop , coolant ( i )% energies ,& coolant ( i )% weights , temp_Z_function , pdr ( p )% abundance ( coolant ( i )% cspec ) * pdr ( p )% rho ,& pdr ( p )% nTgas ) enddo enddo #ifdef OPENMP !$OMP END PARALLEL DO #endif return end subroutine","tags":"","url":"sourcefile/chemicaliterations.f90.html"},{"title":"changetemperature.F90 – 3D-PDR","text":"This file depends on sourcefile~~changetemperature.f90~~EfferentGraph sourcefile~changetemperature.f90 changetemperature.F90 sourcefile~modules.f90 modules.F90 sourcefile~changetemperature.f90->sourcefile~modules.f90 sourcefile~definitions.f90 definitions.F90 sourcefile~modules.f90->sourcefile~definitions.f90 sourcefile~healpix_types.f90 healpix_types.F90 sourcefile~modules.f90->sourcefile~healpix_types.f90 sourcefile~healpix_types.f90->sourcefile~definitions.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code subroutine changetemperature use maincode_module use maincode_local use global_module #ifdef OPENMP #ifdef THERMALBALANCE !$OMP PARALLEL DO DEFAULT(SHARED) SCHEDULE(GUIDED) PRIVATE(p,allheating,temp_Tgas,rate) & #else !$OMP PARALLEL DO DEFAULT(SHARED) SCHEDULE(GUIDED) PRIVATE(p,allheating,rate)& #endif !$OMP PRIVATE(NRGR,NRH2,NRHD,NRCO,NRCI,NRSI) #endif do p = 1 , pdr_ptot #ifdef THERMALBALANCE ! Skip this pdrpoint if the temperature has already converged if ( pdr ( p )% fullyconverged ) cycle #endif if ( allocated ( allheating )) deallocate ( allheating ); allocate ( allheating ( 1 : 12 )) CALL CALCULATE_REACTION_RATES ( pdr ( p )% nTgas , pdr ( p )% Tdust , nrays , pdr ( p )% rad_surface ( 0 : nrays - 1 ), pdr ( p )% AV ( 0 : nrays - 1 ),& & pdr ( p )% column_NH2 ( 0 : nrays - 1 ), pdr ( p )% column_NHD ( 0 : nrays - 1 ), pdr ( p )% column_NCO ( 0 : nrays - 1 ),& & pdr ( p )% column_NC ( 0 : nrays - 1 ), pdr ( p )% column_NS ( 0 : nrays - 1 ),& & nreac , reactant , product , alpha , beta , gamma , rate , rtmin , rtmax , duplicate , nspec ,& & NRGR , NRH2 , NRHD , NRCO , NRCI , NRSI , pdr ( p )% abundance ( NELECT ) * pdr ( p )% rho , pdr ( p )% rho , pdr ( p )% zetalocal ) call calc_heating ( pdr ( p )% rho , pdr ( p )% nTgas , pdr ( p )% Tdust , pdr ( p )% UVfield , & & v_turb , nspec , pdr ( p )% abundance (:), nreac , rate , allheating ,& & NRGR , NRH2 , NRHD , NRCO , NRCI , NRSI , pdr ( p )% zetalocal ) pdr ( p )% heating = allheating #ifdef THERMALBALANCE ! Calculate the difference between the total heating and total cooling rates (Fmean) ! and the absolute value of the relative difference between the two rates (Fratio) pdr ( p )% Fmean = pdr ( p )% heating ( 12 ) - sum ( pdr ( p )% cooling (:)) pdr ( p )% Fratio = 2.0D0 * abs ( pdr ( p )% Fmean ) / abs ( pdr ( p )% heating ( 12 ) + sum ( pdr ( p )% cooling (:))) ! Store the current temperature in a dummy variable ! Do not start testing the thermal balance until enough iterations have passed for the level populations to begin to converge... if ( level_conv . and . first_time ) then temp_Tgas = pdr ( p )% nTgas ! Determine the temperature bracket to begin searching within... if ( pdr ( p )% Fmean . eq . 0 ) then ! Handle the (very rare) case when the initial guess temperature is the correct value pdr ( p )% Tlow = pdr ( p )% nTgas ! Update the value of Tlow pdr ( p )% Thigh = pdr ( p )% nTgas ! Update the value of Thigh else if ( pdr ( p )% Fmean . gt . 0 ) then !---> HEATING pdr ( p )% Tlow = pdr ( p )% nTgas ! Update the value of Tlow pdr ( p )% nTgas = 1.3D0 * pdr ( p )% nTgas !increase 30% pdr ( p )% previouschange = \"H\" !we increased else if ( pdr ( p )% Fmean . lt . 0 ) then !---> COOLING pdr ( p )% Thigh = pdr ( p )% nTgas ! Update the value of Thigh pdr ( p )% nTgas = 0.7D0 * pdr ( p )% nTgas !decrease 30% if ( pdr ( p )% nTgas . lt . Tmin ) pdr ( p )% nTgas = Tmin pdr ( p )% previouschange = \"C\" !we decreased endif !(Fmean.eq.0) pdr ( p )% Tgas = temp_Tgas if ( pdr ( p )% Tgas . lt . Tmin ) pdr ( p )% Tgas = Tmin else if ( level_conv . and .. not . first_time ) then temp_Tgas = pdr ( p )% nTgas ! Check for convergence in both the heating-cooling imbalance and the temperature difference between iterations if ( pdr ( p )% Fratio . le . Fcrit ) pdr ( p )% fullyconverged = . true . if (. not . pdr ( p )% dobinarychop ) then !if we *still* need to heat, increase by 30% if ( pdr ( p )% Fmean . gt . 0. and . pdr ( p )% previouschange . eq . \"H\" ) then pdr ( p )% Tlow = pdr ( p )% nTgas pdr ( p )% nTgas = 1.3D0 * pdr ( p )% nTgas pdr ( p )% Thigh = pdr ( p )% nTgas pdr ( p )% previouschange = \"H\" endif !if we *still* need to cool, decrease by 30% if ( pdr ( p )% Fmean . lt . 0. and . pdr ( p )% previouschange . eq . \"C\" ) then pdr ( p )% Thigh = pdr ( p )% nTgas pdr ( p )% nTgas = 0.7D0 * pdr ( p )% nTgas pdr ( p )% Tlow = pdr ( p )% nTgas pdr ( p )% previouschange = \"C\" if ( pdr ( p )% nTgas . lt . Tmin ) then pdr ( p )% nTgas = Tmin pdr ( p )% Tlow = Tmin pdr ( p )% Thigh = Tmin endif endif !(Fmean.lt.0.and.pdr(p)%previouschange.eq.\"C\") !For all other cases do binary chop and flag the process as .true. !Needs heating but previously it was decreased by 30%. if ( pdr ( p )% Fmean . gt . 0. and . pdr ( p )% previouschange . eq . \"C\" ) then pdr ( p )% nTgas = ( pdr ( p )% Thigh + pdr ( p )% Tlow ) / 2.0D0 pdr ( p )% dobinarychop = . true . !from now on endif !Needs cooling but previously it was increased by 30%. Now do binary chop if ( pdr ( p )% Fmean . lt . 0. and . pdr ( p )% previouschange . eq . \"H\" ) then pdr ( p )% nTgas = ( pdr ( p )% Thigh + pdr ( p )% Tlow ) / 2.0D0 pdr ( p )% dobinarychop = . true . !from now on endif else !from now on only binary chop (we found the min-max by the 30% increase/decrease) if ( pdr ( p )% Fmean . gt . 0 ) then pdr ( p )% Tlow = pdr ( p )% nTgas pdr ( p )% nTgas = ( pdr ( p )% nTgas + pdr ( p )% Thigh ) / 2.0D0 endif if ( pdr ( p )% Fmean . lt . 0 ) then pdr ( p )% Thigh = pdr ( p )% nTgas pdr ( p )% nTgas = ( pdr ( p )% nTgas + pdr ( p )% Tlow ) / 2.0D0 endif endif !dobinarychop ! If the temperatures are converging in a value that thermal balance can't be reached ! double the high temperature and half the low one. If the temperatures are still not converging, force convergence. if (( abs ( pdr ( p )% nTgas - pdr ( p )% Tgas ). le . Tdiff ). and .( pdr ( p )% Fratio . gt . Fcrit )) pdr ( p )% fullyconverged = . true . ! Replace the previous temperature with the current value pdr ( p )% Tgas = temp_Tgas if (( temp_Tgas . lt . Tmin ). and .( pdr ( p )% Fmean . lt . 0 )) pdr ( p )% fullyconverged = . true . if (( temp_Tgas . gt . Tmax ). and .( pdr ( p )% Fmean . gt . 0 )) pdr ( p )% fullyconverged = . true . if ( pdr ( p )% fullyconverged ) then if ( temp_Tgas . lt . Tmin ) then pdr ( p )% Tgas = Tmin pdr ( p )% nTgas = Tmin if ( pdr ( p )% doleveltmin ) then pdr ( p )% fullyconverged = . true . else pdr ( p )% fullyconverged = . false . pdr ( p )% levelconverged = . false . temp_Tgas = Tmin endif pdr ( p )% doleveltmin = . true . endif !(temp_Tgas.lt.Tmin) if ( temp_Tgas . gt . Tmax ) then pdr ( p )% Tgas = Tmax pdr ( p )% nTgas = Tmax endif !(temp_Tgas.gt.Tmax) endif !(pdr(p)%fullyconverged) endif !(level_conv.and.first_time) #endif enddo !1,pdr_ptot #ifdef OPENMP !$OMP END PARALLEL DO #endif return end subroutine","tags":"","url":"sourcefile/changetemperature.f90.html"},{"title":"init3DPDR.F90 – 3D-PDR","text":"This file depends on sourcefile~~init3dpdr.f90~~EfferentGraph sourcefile~init3dpdr.f90 init3DPDR.F90 sourcefile~m_mesh.f90 m_Mesh.F90 sourcefile~init3dpdr.f90->sourcefile~m_mesh.f90 sourcefile~m_ray_box.f90 m_Ray_box.F90 sourcefile~init3dpdr.f90->sourcefile~m_ray_box.f90 sourcefile~m_ray_box.f90->sourcefile~m_mesh.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program init3DPDR use m_Mesh use m_Ray_box implicit none real * 8 , parameter :: Pi = 3.141592653589793238462643383279502884 integer :: i , j , k , p , nunit real * 8 :: x , y , z , xc , yc , zc , r , rr , n real ( 8 ), allocatable , dimension (:,:,:) :: density_3D real ( 8 ), allocatable , dimension (:) :: density_1D ! locals real ( RK ) :: xs , ys , zs integer :: levels type ( box ) :: box1 type ( HEALPix_ray ) :: ray real ( RK ) :: thfpix , phfpix , contribution , contribution_1D real ( RK ) :: corner_min ( 3 ), corner_max ( 3 ) xlx = 3.D0 yly = 3.D0 zlz = 3.D0 nxc = 32 nyc = 32 nzc = 32 dx = xlx / real ( nxc , kind = RK ) dy = yly / real ( nyc , kind = RK ) dz = zlz / real ( nzc , kind = RK ) xc = 1.5D0 yc = 1.5D0 zc = 1.5D0 r = 1.D0 allocate ( density_3D ( nxc , nyc , nzc )) allocate ( density_1D ( nxc * nyc * nzc )) open ( nunit , file = '3Dsphere.dat' ) do k = 1 , nzc do j = 1 , nyc do i = 1 , nxc x = ( DBLE ( i ) - 0.5D0 ) * dx y = ( DBLE ( j ) - 0.5D0 ) * dy z = ( DBLE ( k ) - 0.5D0 ) * dz rr = sqrt (( x - xc ) ** 2.D0 + ( y - yc ) ** 2.D0 + ( z - zc ) ** 2.D0 ) if ( rr . le . r ) then n = 10 0.D0 else n = 0.D0 endif write ( nUnit , * ) x , y , z , n p = I + ( J - 1 ) * nxc + ( K - 1 ) * ( nxc * nyc ) density_3D ( i , j , k ) = n density_1D ( p ) = n enddo enddo enddo close ( nUnit ) levels = nint ( log ( DBLE ( nxc )) / log ( 2.D0 )) + 1 corner_min = [ 0.D0 , 0.D0 , 0.D0 ] corner_max = [ xlx , yly , zlz ] box1 % min = corner_min box1 % max = corner_max xs = 1.5D0 - 0.5D0 * dx ys = 1.5D0 - 0.5D0 * dy zs = 1.5D0 - 0.5D0 * dz thfpix = 1.5707963267948966D0 phfpix = 4.7123889803846897D0 ray % origin = [ xs , ys , zs ] ray % angle = [ thfpix , phfpix ] print * , thfpix * 18 0.D0 / pi , phfpix * 18 0.D0 / pi contribution = 0.D0 contribution_1D = 0.D0 call octree ( ray , box1 , levels - 1 , contribution , contribution_1D , density_3D , density_1D ) print * , '3D' , contribution print * , '1D' , contribution_1D print * , 'size' , dx end program","tags":"","url":"sourcefile/init3dpdr.f90.html"},{"title":"input_parameters.F90 – 3D-PDR","text":"This file depends on sourcefile~~input_parameters.f90~~EfferentGraph sourcefile~input_parameters.f90 input_parameters.F90 sourcefile~definitions.f90 definitions.F90 sourcefile~input_parameters.f90->sourcefile~definitions.f90 sourcefile~healpix_types.f90 healpix_types.F90 sourcefile~input_parameters.f90->sourcefile~healpix_types.f90 sourcefile~m_mesh.f90 m_Mesh.F90 sourcefile~input_parameters.f90->sourcefile~m_mesh.f90 sourcefile~modules.f90 modules.F90 sourcefile~input_parameters.f90->sourcefile~modules.f90 sourcefile~healpix_types.f90->sourcefile~definitions.f90 sourcefile~modules.f90->sourcefile~definitions.f90 sourcefile~modules.f90->sourcefile~healpix_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code SUBROUTINE readparams !T.Bisbas, T.Bell use definitions use healpix_types use maincode_module , only : input , level , Tguess , v_turb_inp , & & theta_crit , ITERTOT , output , & & Gext , AV_fac , UV_fac , nspec , nreac , maxpoints ,& & Tlow0 , Thigh0 , Tmin , Tmax , Fcrit , Tdiff , dust_temperature ,& & chemiterations , zeta , end_time , Av_crit , v_alfv , & & indir , outdir , coolfile , coo , redshift , Tcmb , crfieldchoice , & & paramFile , crattennorm , crattenslope , crattenn0 , UVdirchoice , & & user_UVAngle , UVdir use global_module , only : metallicity , omega , grain_radius use chemistry_module use m_Mesh real ( kind = dp ) :: dummy character ( len = 50 ) :: coolin , suffix open ( unit = 12 , file = paramFile , status = 'old' ) read ( 12 , * ); read ( 12 , * ); read ( 12 , * ) read ( 12 , * ) indir read ( 12 , * ) input read ( 12 , * ) outdir read ( 12 , * ) output input = trim ( adjustl ( indir )) // '/' // trim ( adjustl ( input )) output = trim ( adjustl ( outdir )) // '/' // trim ( adjustl ( output )) #ifdef RAYTHEIA open ( unit = 2 , file = input , status = 'old' ) read ( 2 , * ) nxc , nyc , nzc read ( 2 , * ) xlx , yly , zlz close ( 2 ) #endif read ( 12 , * ); read ( 12 , * ); read ( 12 , * ) Gext = 0 read ( 12 , * ) Gext ( 1 ) #ifdef CRATTENUATION #if CRATTENUATION == 1 read ( 12 , * ) crfieldchoice !L or H select case ( crfieldchoice ) case ( 'L' , 'l' , 'H' , 'h' ) continue case default STOP 'Invalid crfieldchoice' end select #elif CRATTENUATION == 2 read ( 12 , * ) crattennorm read ( 12 , * ) crattenn0 read ( 12 , * ) crattenslope #else write ( 6 , * ) \"Invalid CRATTENUATION Flag. Must be 1 or 2\" stop #endif #else read ( 12 , * ) zeta zeta = zeta / 1.3d-17 #endif read ( 12 , * ) metallicity read ( 12 , * ) v_turb_inp read ( 12 , * ) end_time read ( 12 , * ) grain_radius omega = 0.42 read ( 12 , * ) Av_fac AV_fac = AV_fac * metallicity read ( 12 , * ) UV_fac read ( 12 , * ) redshift Tcmb = 2.725 * ( 1. + redshift ) read ( 12 , * ) Av_crit read ( 12 , * ) v_alfv v_alfv = ( v_alfv ** 2 ) * 4 0.382518 !K --> protonmass * (1 km/s)&#94;2 / 3 / k_boltzmann read ( 12 , * ); read ( 12 , * ); read ( 12 , * ) read ( 12 , * ) level read ( 12 , * ) theta_crit read ( 12 , * ); read ( 12 , * ); read ( 12 , * ) read ( 12 , * ) relative_abundance_tolerance read ( 12 , * ) absolute_abundance_tolerance read ( 12 , * ); read ( 12 , * ); read ( 12 , * ) read ( 12 , * ) chemiterations read ( 12 , * ) ITERTOT read ( 12 , * ); read ( 12 , * ); read ( 12 , * ) read ( 12 , * ) Tguess read ( 12 , * ) Tmin if ( Tmin < Tcmb ) Tmin = Tcmb read ( 12 , * ) Tmax read ( 12 , * ) dust_temperature read ( 12 , * ) Fcrit read ( 12 , * ) Tdiff Tlow0 = 1 0.0 Thigh0 = 800 0.0 read ( 12 , * ); read ( 12 , * ); read ( 12 , * ) coo = 0 do read ( 12 , * , end = 99 ) coolin coo = coo + 1 coolfile ( coo ) = coolin enddo 99 continue coolfile = 'chemfiles/' // coolfile #ifdef REDUCED suffix = 'reduced.d' #elif MEDIUM suffix = 'medium.d' #elif FULL suffix = 'full.d' #elif MYNETWORK suffix = 'mynetwork.d' #endif close ( 1 ) open ( unit = 1 , file = 'chemfiles/species_' // trim ( adjustl ( suffix )), status = 'old' ) nspec = 0 do read ( 1 , * , end = 100 ) dummy nspec = nspec + 1 enddo 100 continue close ( 1 ) open ( unit = 1 , file = 'chemfiles/rates_' // trim ( adjustl ( suffix )), status = 'old' ) nreac = 0 do read ( 1 , * , end = 101 ) dummy nreac = nreac + 1 enddo 101 continue close ( 1 ) #ifdef RAYTHEIA call Mesh #endif close ( 12 ) return END SUBROUTINE readparams","tags":"","url":"sourcefile/input_parameters.f90.html"},{"title":"definitions.F90 – 3D-PDR","text":"Files dependent on this one sourcefile~~definitions.f90~~AfferentGraph sourcefile~definitions.f90 definitions.F90 sourcefile~3dpdr.f90 3DPDR.F90 sourcefile~3dpdr.f90->sourcefile~definitions.f90 sourcefile~healpix_types.f90 healpix_types.F90 sourcefile~3dpdr.f90->sourcefile~healpix_types.f90 sourcefile~modules.f90 modules.F90 sourcefile~3dpdr.f90->sourcefile~modules.f90 sourcefile~analyse_chem.f90 analyse_chem.F90 sourcefile~analyse_chem.f90->sourcefile~definitions.f90 sourcefile~analyse_chem.f90->sourcefile~healpix_types.f90 sourcefile~analyse_chem.f90->sourcefile~modules.f90 sourcefile~calc_reac_rates.f90 calc_reac_rates.F90 sourcefile~calc_reac_rates.f90->sourcefile~definitions.f90 sourcefile~calc_reac_rates.f90->sourcefile~healpix_types.f90 sourcefile~calc_reac_rates.f90->sourcefile~modules.f90 sourcefile~crattenuation.f90 CRattenuation.F90 sourcefile~crattenuation.f90->sourcefile~definitions.f90 sourcefile~crattenuation.f90->sourcefile~healpix_types.f90 sourcefile~crattenuation.f90->sourcefile~modules.f90 sourcefile~escape_probability.f90 escape_probability.F90 sourcefile~escape_probability.f90->sourcefile~definitions.f90 sourcefile~escape_probability.f90->sourcefile~healpix_types.f90 sourcefile~escape_probability.f90->sourcefile~modules.f90 sourcefile~eval_points.f90 eval_points.F90 sourcefile~eval_points.f90->sourcefile~definitions.f90 sourcefile~eval_points.f90->sourcefile~healpix_types.f90 sourcefile~eval_points.f90->sourcefile~modules.f90 sourcefile~h2_form.f90 h2_form.F90 sourcefile~h2_form.f90->sourcefile~definitions.f90 sourcefile~h2_form.f90->sourcefile~healpix_types.f90 sourcefile~h2_form.f90->sourcefile~modules.f90 sourcefile~healpix.f90 healpix.F90 sourcefile~healpix.f90->sourcefile~definitions.f90 sourcefile~healpix.f90->sourcefile~healpix_types.f90 sourcefile~healpix.f90->sourcefile~modules.f90 sourcefile~healpix_types.f90->sourcefile~definitions.f90 sourcefile~heapsort.f90 heapsort.F90 sourcefile~heapsort.f90->sourcefile~definitions.f90 sourcefile~heapsort.f90->sourcefile~healpix_types.f90 sourcefile~input_parameters.f90 input_parameters.F90 sourcefile~input_parameters.f90->sourcefile~definitions.f90 sourcefile~input_parameters.f90->sourcefile~healpix_types.f90 sourcefile~input_parameters.f90->sourcefile~modules.f90 sourcefile~modules.f90->sourcefile~definitions.f90 sourcefile~modules.f90->sourcefile~healpix_types.f90 sourcefile~read_command_line.f90 read_command_line.F90 sourcefile~read_command_line.f90->sourcefile~definitions.f90 sourcefile~read_command_line.f90->sourcefile~modules.f90 sourcefile~read_rates.f90 read_rates.F90 sourcefile~read_rates.f90->sourcefile~definitions.f90 sourcefile~read_rates.f90->sourcefile~healpix_types.f90 sourcefile~read_rates.f90->sourcefile~modules.f90 sourcefile~read_species.f90 read_species.F90 sourcefile~read_species.f90->sourcefile~definitions.f90 sourcefile~read_species.f90->sourcefile~healpix_types.f90 sourcefile~read_species.f90->sourcefile~modules.f90 sourcefile~readdensity.f90 readdensity.F90 sourcefile~readdensity.f90->sourcefile~definitions.f90 sourcefile~readdensity.f90->sourcefile~healpix_types.f90 sourcefile~readdensity.f90->sourcefile~modules.f90 sourcefile~shield.f90 shield.F90 sourcefile~shield.f90->sourcefile~definitions.f90 sourcefile~shield.f90->sourcefile~healpix_types.f90 sourcefile~shield.f90->sourcefile~modules.f90 sourcefile~solvlevpop.f90 solvlevpop.F90 sourcefile~solvlevpop.f90->sourcefile~definitions.f90 sourcefile~solvlevpop.f90->sourcefile~healpix_types.f90 sourcefile~solvlevpop.f90->sourcefile~modules.f90 sourcefile~spline.f90 spline.F90 sourcefile~spline.f90->sourcefile~definitions.f90 sourcefile~spline.f90->sourcefile~healpix_types.f90 sourcefile~writeparams.f90 writeparams.F90 sourcefile~writeparams.f90->sourcefile~definitions.f90 sourcefile~writeparams.f90->sourcefile~healpix_types.f90 sourcefile~writeparams.f90->sourcefile~modules.f90 sourcefile~allocations.f90 allocations.F90 sourcefile~allocations.f90->sourcefile~healpix_types.f90 sourcefile~allocations.f90->sourcefile~modules.f90 sourcefile~changetemperature.f90 changetemperature.F90 sourcefile~changetemperature.f90->sourcefile~modules.f90 sourcefile~checkconvergence.f90 checkconvergence.F90 sourcefile~checkconvergence.f90->sourcefile~healpix_types.f90 sourcefile~checkconvergence.f90->sourcefile~modules.f90 sourcefile~chemicaliterations.f90 chemicaliterations.F90 sourcefile~chemicaliterations.f90->sourcefile~healpix_types.f90 sourcefile~chemicaliterations.f90->sourcefile~modules.f90 sourcefile~columndensity.f90 columndensity.F90 sourcefile~columndensity.f90->sourcefile~healpix_types.f90 sourcefile~columndensity.f90->sourcefile~modules.f90 sourcefile~coolingfunctions.f90 coolingfunctions.F90 sourcefile~coolingfunctions.f90->sourcefile~healpix_types.f90 sourcefile~coolingfunctions.f90->sourcefile~modules.f90 sourcefile~dust_t.f90 dust_t.F90 sourcefile~dust_t.f90->sourcefile~healpix_types.f90 sourcefile~dust_t.f90->sourcefile~modules.f90 sourcefile~initialization.f90 initialization.F90 sourcefile~initialization.f90->sourcefile~modules.f90 sourcefile~lte_population.f90 lte_population.F90 sourcefile~lte_population.f90->sourcefile~healpix_types.f90 sourcefile~m_ioandvisu.f90 m_IOAndVisu.F90 sourcefile~m_ioandvisu.f90->sourcefile~modules.f90 sourcefile~m_ray_box.f90~2 m_Ray_box.F90 sourcefile~m_ray_box.f90~2->sourcefile~healpix_types.f90 sourcefile~m_ray_box.f90~2->sourcefile~modules.f90 sourcefile~partition_function.f90 partition_function.F90 sourcefile~partition_function.f90->sourcefile~healpix_types.f90 sourcefile~read_coolants.f90 read_coolants.F90 sourcefile~read_coolants.f90->sourcefile~modules.f90 sourcefile~read_input.f90 read_input.F90 sourcefile~read_input.f90->sourcefile~healpix_types.f90 sourcefile~uvfield.f90 UVfield.F90 sourcefile~uvfield.f90->sourcefile~healpix_types.f90 sourcefile~uvfield.f90->sourcefile~modules.f90 sourcefile~writeoutputs.f90 writeoutputs.F90 sourcefile~writeoutputs.f90->sourcefile~healpix_types.f90 sourcefile~writeoutputs.f90->sourcefile~modules.f90 sourcefile~writeoutputs_h5.f90 writeoutputs_h5.F90 sourcefile~writeoutputs_h5.f90->sourcefile~healpix_types.f90 sourcefile~writeoutputs_h5.f90->sourcefile~modules.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Definition of precision kind variables ! ============================================================================ !#include \"macros.h\" ! ============================================================================ !T.Bisbas -- taken from SEREN/HEALPix MODULE definitions integer , parameter :: DP = selected_real_kind ( p = 15 ) ! double precision integer , parameter :: SP = selected_real_kind ( p = 6 ) ! single precision integer , parameter :: DDP = selected_real_kind ( p = 16 ) #ifdef DOUBLE_PRECISION integer , parameter :: PR = DP ! particle precision #else integer , parameter :: PR = SP ! default = single #endif integer , parameter :: ILP = 4 ! Integer long precision END MODULE definitions ! ============================================================================","tags":"","url":"sourcefile/definitions.f90.html"},{"title":"readdensity.F90 – 3D-PDR","text":"This file depends on sourcefile~~readdensity.f90~~EfferentGraph sourcefile~readdensity.f90 readdensity.F90 sourcefile~definitions.f90 definitions.F90 sourcefile~readdensity.f90->sourcefile~definitions.f90 sourcefile~healpix_types.f90 healpix_types.F90 sourcefile~readdensity.f90->sourcefile~healpix_types.f90 sourcefile~m_mesh.f90 m_Mesh.F90 sourcefile~readdensity.f90->sourcefile~m_mesh.f90 sourcefile~m_ray_box.f90 m_Ray_box.F90 sourcefile~readdensity.f90->sourcefile~m_ray_box.f90 sourcefile~modules.f90 modules.F90 sourcefile~readdensity.f90->sourcefile~modules.f90 sourcefile~healpix_types.f90->sourcefile~definitions.f90 sourcefile~m_ray_box.f90->sourcefile~m_mesh.f90 sourcefile~modules.f90->sourcefile~definitions.f90 sourcefile~modules.f90->sourcefile~healpix_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code subroutine readdensity use definitions use healpix_types use healpix_module use maincode_module use global_module #ifdef OPENMP use omp_lib #endif use chemistry_module use maincode_local use m_Mesh use m_Ray_box integer :: temp open ( unit = 2 , file = input , status = 'old' ) #ifndef ONEDIMENSIONAL read ( 2 , '(/)' ) #endif #ifdef RAYTHEIA pdr_ptot = nxc * nyc * nzc #else pdr_ptot = 0 do read ( 2 , * , end = 100 ) xpos pdr_ptot = pdr_ptot + 1 enddo 100 continue rewind ( 2 ) #endif allocate ( pdr ( 1 : pdr_ptot )) do p = 1 , pdr_ptot read ( 2 , * ) xpos , ypos , zpos , denst pdr ( p )% etype = 1 pdr ( p )% x = xpos pdr ( p )% y = ypos pdr ( p )% z = zpos pdr ( p )% rho = denst enddo write ( 6 , * ) 'PDR elements        = ' , pdr_ptot write ( 6 , * ) 'Maximum PDR density = ' , maxval ( pdr (:)% rho ) write ( 6 , * ) 'Minimum PDR density = ' , minval ( pdr (:)% rho ) #ifdef RAYTHEIA_MO write ( 6 , * ) 'Grid resolution     = ' , nxc write ( 6 , * ) 'Domain size         = ' , real ( xlx ) nside = 2 ** level nrays = 12 * nside ** 2 ns_max = 8192 levels = nint ( log ( DBLE ( nxc )) / log ( 2.D0 )) + 1 corner_min = [ 0.D0 , 0.D0 , 0.D0 ] corner_max = [ xlx , yly , zlz ] allocate ( maxpoints_ray ( 0 : nrays - 1 )) maxpoints = 0 #ifdef OPENMP !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(p, j, box1, thfpix, phfpix, ray, maxpoints_ray) REDUCTION(MAX: maxpoints) #endif do p = 1 , pdr_ptot box1 % min = corner_min box1 % max = corner_max maxpoints_ray = 0 do j = 0 , nrays - 1 call pix2ang_nest ( nside , j , thfpix , phfpix ) ray % origin = [ pdr ( p )% x , pdr ( p )% y , pdr ( p )% z ] ray % angle = [ thfpix , phfpix ] call raytheia_maxpoints ( ray , box1 , levels - 1 , j , maxpoints_ray ) enddo temp = maxval ( maxpoints_ray ) if ( temp . gt . maxpoints ) maxpoints = temp enddo #ifdef OPENMP !$OMP END PARALLEL DO #endif print * , 'Maxpoints           = ' , maxpoints #else #ifdef RAYTHEIA write ( 6 , * ) 'Grid resolution     = ' , nxc write ( 6 , * ) 'Domain size         = ' , real ( xlx ) levels = nint ( log ( DBLE ( nxc )) / log ( 2.D0 )) + 1 corner_min = [ 0.D0 , 0.D0 , 0.D0 ] corner_max = [ xlx , yly , zlz ] maxpoints = 3 * nxc - 2 #else maxpoints = 1000 allocate ( rra ( 0 : pdr_ptot )) allocate ( rrb ( 1 : pdr_ptot )) allocate ( pdrpoint ( 1 : 3 , 1 : pdr_ptot )) close ( 2 ) do p = 1 , pdr_ptot rra ( p ) = sqrt ( pdr ( p )% x ** 2 + pdr ( p )% y ** 2 + pdr ( p )% z ** 2 ) rrb ( p ) = p pdrpoint ( 1 , p ) = pdr ( p )% x pdrpoint ( 2 , p ) = pdr ( p )% y pdrpoint ( 3 , p ) = pdr ( p )% z enddo #endif #endif return end subroutine","tags":"","url":"sourcefile/readdensity.f90.html"},{"title":"logo.F90 – 3D-PDR","text":"Source Code subroutine logo write ( 6 , * ) '==============================================================================' write ( 6 , * ) '*********     *********             *********     *********      *********' write ( 6 , * ) '        **    **       **           **       **   **       **    **       **' write ( 6 , * ) '         **   **        **          **        **  **        **   **        **' write ( 6 , * ) '        **    **         **         **       **   **         **  **       **' write ( 6 , * ) '  *******     **         **  *****  *********     **         **  *********' write ( 6 , * ) '        **    **         **         **            **         **  **     **' write ( 6 , * ) '         **   **        **          **            **        **   **      **' write ( 6 , * ) '        **    **       **           **            **       **    **       **' write ( 6 , * ) '*********     *********             **            *********      **        **' write ( 6 , * ) '==============================================================================' write ( 6 , * ) '********************   Coders:   T.G.Bisbas, T.A.Bell   **********************' write ( 6 , * ) '*************   Collaborators:   S.Viti, J.Yates, M.Barlow   *****************' write ( 6 , * ) '*************************        Version 1.0          ************************' write ( 6 , * ) '==============================================================================' write ( 6 , * ) '' return end subroutine","tags":"","url":"sourcefile/logo.f90.html"},{"title":"m_Ray_box.F90 – 3D-PDR","text":"This file depends on sourcefile~~m_ray_box.f90~2~~EfferentGraph sourcefile~m_ray_box.f90~2 m_Ray_box.F90 sourcefile~healpix_types.f90 healpix_types.F90 sourcefile~m_ray_box.f90~2->sourcefile~healpix_types.f90 sourcefile~m_mesh.f90 m_Mesh.F90 sourcefile~m_ray_box.f90~2->sourcefile~m_mesh.f90 sourcefile~modules.f90 modules.F90 sourcefile~m_ray_box.f90~2->sourcefile~modules.f90 sourcefile~definitions.f90 definitions.F90 sourcefile~healpix_types.f90->sourcefile~definitions.f90 sourcefile~modules.f90->sourcefile~healpix_types.f90 sourcefile~modules.f90->sourcefile~definitions.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !Written by Zhengping Zhu module m_Ray_box use m_Mesh use healpix_types use maincode_module , only : pdr , nrays , maxpoints implicit none private type , public :: box real ( RK ) :: min ( 3 ), max ( 3 ) end type box type :: slab real ( RK ) :: origin ( 3 ), dir ( 3 ), dir_inv ( 3 ) end type slab type , public :: HEALPix_ray integer :: eval real ( RK ) :: length real ( RK ) :: origin ( 3 ), angle ( 2 ) end type HEALPix_ray integer , public :: levels integer , public , allocatable :: maxpoints_ray (:) type ( box ), public :: box1 type ( HEALPix_ray ), public :: ray real ( kind = dp ), public :: thfpix , phfpix , contribution real ( kind = dp ), public :: corner_min ( 3 ), corner_max ( 3 ) #ifdef RAYTHEIA_MO public :: raytheia , raytheia_maxpoints #else public :: raytheia_table #endif contains logical function isfinite ( x ) real ( RK ), intent ( in ) :: x isfinite = ( abs ( x ) < huge ( x ) . and . x == x ) end function isfinite subroutine intersections ( ray_xyz , box_in , length ) implicit none type ( slab ), intent ( in ) :: ray_xyz type ( box ), intent ( in ) :: box_in real ( RK ), intent ( inout ) :: length integer :: i , d real ( RK ) :: tmin , tmax , t1 , t2 real ( RK ) :: Pmin ( 3 ), Pmax ( 3 ) real ( RK ) :: distance , diff real ( RK ) :: temp ! 初始化 tmin 和 tmax tmin = 0.0 tmax = huge ( 0.0 ) ! 设置 tmax 为无穷大 ! 遍历 x, y, z 三个维度 do d = 1 , 3 if ( isfinite ( ray_xyz % dir_inv ( d ))) then ! 计算 t1 和 t2 t1 = ( box_in % min ( d ) - ray_xyz % origin ( d )) * ray_xyz % dir_inv ( d ) t2 = ( box_in % max ( d ) - ray_xyz % origin ( d )) * ray_xyz % dir_inv ( d ) ! 确保 t1 是较小值，t2 是较大值 if ( t1 > t2 ) then temp = t1 t1 = t2 t2 = temp end if ! 更新 tmin 和 tmax tmin = max ( tmin , t1 ) tmax = min ( tmax , t2 ) else if ( ray_xyz % origin ( d ) < box_in % min ( d ) . or . ray_xyz % origin ( d ) > box_in % max ( d )) then ! 射线与某个维度的边界盒平行且射线起点不在盒子内 tmin = huge ( 0.0 ) exit end if end do ! 判断射线是否与盒子相交 if ( tmin <= tmax ) then ! 计算交点坐标 do d = 1 , 3 Pmin ( d ) = ray_xyz % origin ( d ) + tmin / ray_xyz % dir_inv ( d ) Pmax ( d ) = ray_xyz % origin ( d ) + tmax / ray_xyz % dir_inv ( d ) end do ! 计算欧几里得距离 distance = 0.0 do d = 1 , 3 diff = Pmax ( d ) - Pmin ( d ) distance = distance + diff ** 2 end do length = sqrt ( distance ) ! 射线穿过盒子的欧几里得距离 else length = 0.0 ! 如果不相交，长度为 0 end if end subroutine intersections #ifdef RAYTHEIA_MO recursive subroutine raytheia ( ray , parent , level , ipix , epray , projected , plength ) type ( HEALPix_ray ), intent ( in ) :: ray type ( slab ) :: ray_xyz type ( box ), intent ( in ) :: parent type ( box ) :: children ( 0 : 7 ) integer , intent ( in ) :: level , ipix integer :: epray ( 0 : nrays - 1 ) integer :: projected ( 0 : nrays - 1 , 0 : maxpoints ) real ( RK ) :: plength ( 0 : nrays - 1 , 0 : maxpoints ) integer :: i , j , k , d , m , parent_index , ir , node_count , start_index , cI , id real ( RK ) :: mid ( 3 ), extent ( 3 ), center ( 3 ) logical :: intersect real ( RK ) :: x , y , z , r , xnode , ynode , znode !        real(RK) :: Aij,c,nu,pc2cm,f,g_i,g_j,thfpix,phfpix,length real ( RK ) :: thfpix , phfpix , length if ( level > 0 ) then ray_xyz % origin = ray % origin thfpix = ray % angle ( 1 ) phfpix = ray % angle ( 2 ) ray_xyz % dir ( 1 ) = sin ( thfpix ) * cos ( phfpix ) ray_xyz % dir ( 2 ) = sin ( thfpix ) * sin ( phfpix ) ray_xyz % dir ( 3 ) = cos ( thfpix ) do m = 1 , 3 if ( abs ( ray_xyz % dir ( m )) > 1.0e-6 ) then ray_xyz % dir_inv ( m ) = 1.0 / ray_xyz % dir ( m ) else ray_xyz % dir_inv ( m ) = huge ( 0.D0 ) ! 避免除以零 end if end do length = 0.0 call intersections ( ray_xyz , parent , length ) intersect = . false . if ( length > 0.0 ) then intersect = . true . endif if ( intersect ) then ! generate eight child boxes start_index = 0 do i = 0 , 7 do d = 1 , 3 mid ( d ) = ( parent % min ( d ) + parent % max ( d )) / 2.0 if ( btest ( i , d - 1 )) then children ( start_index )% min ( d ) = mid ( d ) children ( start_index )% max ( d ) = parent % max ( d ) else children ( start_index )% min ( d ) = parent % min ( d ) children ( start_index )% max ( d ) = mid ( d ) endif enddo start_index = start_index + 1 enddo do i = 0 , 7 call raytheia ( ray , children ( i ), level - 1 , ipix , epray , projected , plength ) enddo endif endif ! leaf nodes calculations if ( level == 0 ) then I = nint ( parent % max ( 1 ) / dx ) J = nint ( parent % max ( 2 ) / dy ) K = nint ( parent % max ( 3 ) / dz ) #ifdef XYZ cI = I + ( J - 1 ) * nxc + ( K - 1 ) * ( nxc * nyc ) #else cI = K + ( J - 1 ) * nzc + ( I - 1 ) * ( nzc * nyc ) #endif ! penetration length ray_xyz % origin = ray % origin thfpix = ray % angle ( 1 ) phfpix = ray % angle ( 2 ) ray_xyz % dir ( 1 ) = sin ( thfpix ) * cos ( phfpix ) ray_xyz % dir ( 2 ) = sin ( thfpix ) * sin ( phfpix ) ray_xyz % dir ( 3 ) = cos ( thfpix ) do m = 1 , 3 if ( abs ( ray_xyz % dir ( m )) > 1.0e-6 ) then ray_xyz % dir_inv ( m ) = 1.0 / ray_xyz % dir ( m ) else ray_xyz % dir_inv ( m ) = huge ( 0.D0 ) ! 避免除以零 end if end do length = 0.0 call intersections ( ray_xyz , parent , length ) if ( length . ne . 0.D0 ) then epray ( ipix ) = epray ( ipix ) + 1 id = epray ( ipix ) projected ( ipix , id ) = cI plength ( ipix , id ) = length endif endif end subroutine raytheia #else recursive subroutine raytheia_table ( ray , parent , level , source , ipix ) type ( HEALPix_ray ), intent ( in ) :: ray type ( slab ) :: ray_xyz type ( box ), intent ( in ) :: parent type ( box ) :: children ( 0 : 7 ) integer , intent ( in ) :: level , source , ipix integer :: i , j , k , d , m , parent_index , ir , node_count , start_index , cI , id real ( RK ) :: mid ( 3 ), extent ( 3 ), center ( 3 ) logical :: intersect real ( RK ) :: x , y , z , r , xnode , ynode , znode !        real(RK) :: Aij,c,nu,pc2cm,f,g_i,g_j,thfpix,phfpix,length real ( RK ) :: thfpix , phfpix , length if ( level > 0 ) then ray_xyz % origin = ray % origin thfpix = ray % angle ( 1 ) phfpix = ray % angle ( 2 ) ray_xyz % dir ( 1 ) = sin ( thfpix ) * cos ( phfpix ) ray_xyz % dir ( 2 ) = sin ( thfpix ) * sin ( phfpix ) ray_xyz % dir ( 3 ) = cos ( thfpix ) do m = 1 , 3 if ( abs ( ray_xyz % dir ( m )) > 1.0e-6 ) then ray_xyz % dir_inv ( m ) = 1.0 / ray_xyz % dir ( m ) else ray_xyz % dir_inv ( m ) = huge ( 0.D0 ) ! 避免除以零 end if end do length = 0.0 call intersections ( ray_xyz , parent , length ) intersect = . false . if ( length > 0.0 ) then intersect = . true . endif if ( intersect ) then ! generate eight child boxes start_index = 0 do i = 0 , 7 do d = 1 , 3 mid ( d ) = ( parent % min ( d ) + parent % max ( d )) / 2.0 if ( btest ( i , d - 1 )) then children ( start_index )% min ( d ) = mid ( d ) children ( start_index )% max ( d ) = parent % max ( d ) else children ( start_index )% min ( d ) = parent % min ( d ) children ( start_index )% max ( d ) = mid ( d ) endif enddo start_index = start_index + 1 enddo do i = 0 , 7 call raytheia_table ( ray , children ( i ), level - 1 , source , ipix ) enddo endif endif ! leaf nodes calculations if ( level == 0 ) then I = nint ( parent % max ( 1 ) / dx ) J = nint ( parent % max ( 2 ) / dy ) K = nint ( parent % max ( 3 ) / dz ) #ifdef XYZ cI = I + ( J - 1 ) * nxc + ( K - 1 ) * ( nxc * nyc ) #else cI = K + ( J - 1 ) * nzc + ( I - 1 ) * ( nzc * nyc ) #endif ! penetrate length ray_xyz % origin = ray % origin thfpix = ray % angle ( 1 ) phfpix = ray % angle ( 2 ) ray_xyz % dir ( 1 ) = sin ( thfpix ) * cos ( phfpix ) ray_xyz % dir ( 2 ) = sin ( thfpix ) * sin ( phfpix ) ray_xyz % dir ( 3 ) = cos ( thfpix ) do m = 1 , 3 if ( abs ( ray_xyz % dir ( m )) > 1.0e-6 ) then ray_xyz % dir_inv ( m ) = 1.0 / ray_xyz % dir ( m ) else ray_xyz % dir_inv ( m ) = huge ( 0.D0 ) ! 避免除以零 end if end do length = 0.0 call intersections ( ray_xyz , parent , length ) if ( length . ne . 0.D0 ) then pdr ( source )% epray ( ipix ) = pdr ( source )% epray ( ipix ) + 1 id = pdr ( source )% epray ( ipix ) pdr ( source )% projected ( ipix , id ) = cI pdr ( source )% length ( ipix , id ) = length endif endif end subroutine raytheia_table #endif recursive subroutine raytheia_maxpoints ( ray , parent , level , ipix , epray ) type ( HEALPix_ray ), intent ( in ) :: ray type ( slab ) :: ray_xyz type ( box ), intent ( in ) :: parent type ( box ) :: children ( 0 : 7 ) integer , intent ( in ) :: level , ipix integer :: epray ( 0 : nrays - 1 ) integer :: projected ( 0 : nrays - 1 , 0 : maxpoints ) real ( RK ) :: plength ( 0 : nrays - 1 , 0 : maxpoints ) integer :: i , j , k , d , m , parent_index , ir , node_count , start_index , cI , id real ( RK ) :: mid ( 3 ), extent ( 3 ), center ( 3 ) logical :: intersect real ( RK ) :: x , y , z , r , xnode , ynode , znode !        real(RK) :: Aij,c,nu,pc2cm,f,g_i,g_j,thfpix,phfpix,length real ( RK ) :: thfpix , phfpix , length if ( level > 0 ) then ray_xyz % origin = ray % origin thfpix = ray % angle ( 1 ) phfpix = ray % angle ( 2 ) ray_xyz % dir ( 1 ) = sin ( thfpix ) * cos ( phfpix ) ray_xyz % dir ( 2 ) = sin ( thfpix ) * sin ( phfpix ) ray_xyz % dir ( 3 ) = cos ( thfpix ) do m = 1 , 3 if ( abs ( ray_xyz % dir ( m )) > 1.0e-6 ) then ray_xyz % dir_inv ( m ) = 1.0 / ray_xyz % dir ( m ) else ray_xyz % dir_inv ( m ) = huge ( 0.D0 ) ! 避免除以零 end if end do length = 0.0 call intersections ( ray_xyz , parent , length ) intersect = . false . if ( length > 0.0 ) then intersect = . true . endif if ( intersect ) then ! generate eight child boxes start_index = 0 do i = 0 , 7 do d = 1 , 3 mid ( d ) = ( parent % min ( d ) + parent % max ( d )) / 2.0 if ( btest ( i , d - 1 )) then children ( start_index )% min ( d ) = mid ( d ) children ( start_index )% max ( d ) = parent % max ( d ) else children ( start_index )% min ( d ) = parent % min ( d ) children ( start_index )% max ( d ) = mid ( d ) endif enddo start_index = start_index + 1 enddo do i = 0 , 7 call raytheia_maxpoints ( ray , children ( i ), level - 1 , ipix , epray ) enddo endif endif ! leaf nodes calculations if ( level == 0 ) then I = nint ( parent % max ( 1 ) / dx ) J = nint ( parent % max ( 2 ) / dy ) K = nint ( parent % max ( 3 ) / dz ) #ifdef XYZ cI = I + ( J - 1 ) * nxc + ( K - 1 ) * ( nxc * nyc ) #else cI = K + ( J - 1 ) * nzc + ( I - 1 ) * ( nzc * nyc ) #endif ! penetration length ray_xyz % origin = ray % origin thfpix = ray % angle ( 1 ) phfpix = ray % angle ( 2 ) ray_xyz % dir ( 1 ) = sin ( thfpix ) * cos ( phfpix ) ray_xyz % dir ( 2 ) = sin ( thfpix ) * sin ( phfpix ) ray_xyz % dir ( 3 ) = cos ( thfpix ) do m = 1 , 3 if ( abs ( ray_xyz % dir ( m )) > 1.0e-6 ) then ray_xyz % dir_inv ( m ) = 1.0 / ray_xyz % dir ( m ) else ray_xyz % dir_inv ( m ) = huge ( 0.D0 ) ! 避免除以零 end if end do length = 0.0 call intersections ( ray_xyz , parent , length ) if ( length . ne . 0.D0 ) then epray ( ipix ) = epray ( ipix ) + 1 endif endif end subroutine raytheia_maxpoints end module m_Ray_box","tags":"","url":"sourcefile/m_ray_box.f90~2.html"},{"title":"solvlevpop.F90 – 3D-PDR","text":"This file depends on sourcefile~~solvlevpop.f90~~EfferentGraph sourcefile~solvlevpop.f90 solvlevpop.F90 sourcefile~definitions.f90 definitions.F90 sourcefile~solvlevpop.f90->sourcefile~definitions.f90 sourcefile~healpix_types.f90 healpix_types.F90 sourcefile~solvlevpop.f90->sourcefile~healpix_types.f90 sourcefile~modules.f90 modules.F90 sourcefile~solvlevpop.f90->sourcefile~modules.f90 sourcefile~healpix_types.f90->sourcefile~definitions.f90 sourcefile~modules.f90->sourcefile~definitions.f90 sourcefile~modules.f90->sourcefile~healpix_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code SUBROUTINE solvlevpop ( NLEV , TRANSITION , density , SOLUTION ) use definitions use healpix_types implicit none integer ( kind = i4b ), intent ( in ) :: NLEV real ( kind = dp ), intent ( in ) :: density real ( kind = dp ), intent ( in ) :: transition ( 1 : NLEV , 1 : NLEV ) real ( kind = dp ), intent ( out ) :: SOLUTION ( 1 : NLEV ) integer ( kind = i4b ) :: i , j real ( kind = dp ) :: out1 real ( kind = dp ) :: A ( 1 : NLEV , 1 : NLEV ) logical :: call_writes A = 0.0D0 !        Fill the matrix DO I = 1 , NLEV OUT1 = 0.0D0 DO J = 1 , NLEV OUT1 = OUT1 + TRANSITION ( I , J ) A ( I , J ) = TRANSITION ( J , I ) ENDDO A ( I , I ) =- OUT1 ENDDO !        Initialize the solution array before calling the solver routine DO I = 1 , NLEV SOLUTION ( I ) = 0.0D0 A ( NLEV , I ) = 1.0D-8 !non-zero starting parameter to avoid division by zero. ENDDO SOLUTION ( NLEV ) = DENSITY * 1.0D-8 CALL GAUSS_JORDAN ( A , NLEV , NLEV , SOLUTION , call_writes ) !        Replace negative level populations due to numerical noise around 0 DO I = 1 , NLEV if ( solution ( i ). lt . 0.0D0 ) solution ( i ) = 0.0D0 !1.0D-99 ENDDO return end subroutine !C----------------------------------------------------------------------- !C Standard Gauss-Jordon linear equation solver from Numerical Recipes !C A(N,N) is an input matrix stored in an array of dimensions NPxNP !C B(N,M) is an input matrix containing the M right-hand side vectors !C stored in an array of dimensions NPxMPP !C !C On output, A(N,N) is replaced by its matrix inverse and B(N,M) !C is replaced by the corresponding set of solution vectors !C !C Note: set NMAX to the maximum possible dimension (NLEVEL) !C----------------------------------------------------------------------- !   SUBROUTINE GAUSS_JORDAN(A,N,NP,B,M,MPP,coolant) !   SUBROUTINE GAUSS_JORDAN(A,N,NP,B,coolant,call_writes) SUBROUTINE GAUSS_JORDAN ( A , N , NP , B , call_writes ) use definitions use healpix_types IMPLICIT NONE INTEGER ( kind = i4b ) :: I , J , K , L , LL , IROW , ICOL INTEGER ( kind = i4b ), intent ( in ) :: N , NP !,M,MPP integer ( kind = i4b ), PARAMETER :: NMAX = 100 INTEGER ( kind = i4b ) :: IPIV ( 1 : NMAX ), INDXR ( 1 : NMAX ), INDXC ( 1 : NMAX ) real ( kind = dp ), intent ( inout ) :: A ( 1 : NP , 1 : NP ) real ( kind = dp ), intent ( inout ) :: B ( 1 : NP ) !,1:MPP) real ( kind = dp ) :: BIG , DUM , PIVINV logical , intent ( out ) :: call_writes ICOL = 0 IROW = 0 IPIV = 0 DO I = 1 , N BIG = 0.0D0 DO J = 1 , N IF ( IPIV ( J ). NE . 1 ) THEN DO K = 1 , N IF ( IPIV ( K ). EQ . 0 ) THEN IF ( ABS ( A ( J , K )). GE . BIG ) THEN BIG = ABS ( A ( J , K )) IROW = J ICOL = K ENDIF ELSE IF ( IPIV ( K ). GT . 1 ) THEN PRINT * , 'ERROR! Singular matrix in GAUSS_JORDAN' call_writes = . true . return ENDIF ENDDO ENDIF ENDDO IPIV ( ICOL ) = IPIV ( ICOL ) + 1 IF ( IROW . NE . ICOL ) THEN DO L = 1 , N DUM = A ( IROW , L ) A ( IROW , L ) = A ( ICOL , L ) A ( ICOL , L ) = DUM ENDDO DUM = B ( IROW ) B ( IROW ) = B ( ICOL ) B ( ICOL ) = DUM ENDIF INDXR ( I ) = IROW INDXC ( I ) = ICOL IF ( A ( ICOL , ICOL ). EQ . 0.0D0 ) THEN PRINT * , 'ERROR! Singular matrix found by GAUSS_JORDAN' call_writes = . true . return ENDIF PIVINV = 1.0D0 / A ( ICOL , ICOL ) A ( ICOL , ICOL ) = 1.0D0 DO L = 1 , N A ( ICOL , L ) = A ( ICOL , L ) * PIVINV ENDDO B ( ICOL ) = B ( ICOL ) * PIVINV DO LL = 1 , N IF ( LL . NE . ICOL ) THEN DUM = A ( LL , ICOL ) A ( LL , ICOL ) = 0.0D0 DO L = 1 , N A ( LL , L ) = A ( LL , L ) - A ( ICOL , L ) * DUM ENDDO B ( LL ) = B ( LL ) - B ( ICOL ) * DUM ENDIF ENDDO ENDDO DO L = N , 1 , - 1 IF ( INDXR ( L ). NE . INDXC ( L )) THEN DO K = 1 , N DUM = A ( K , INDXR ( L )) A ( K , INDXR ( L )) = A ( K , INDXC ( L )) A ( K , INDXC ( L )) = DUM ENDDO ENDIF ENDDO RETURN END subroutine !C----------------------------------------------------------------------- !C Standard Gauss-Jordon linear equation solver from Numerical Recipes !C A(N,N) is an input matrix stored in an array of dimensions NPxNP !C B(N,M) is an input matrix containing the M right-hand side vectors !C stored in an array of dimensions NPxMPP !C !C On output, A(N,N) is replaced by its matrix inverse and B(N,M) !C is replaced by the corresponding set of solution vectors !C !C Note: set NMAX to the maximum possible dimension (NLEVEL) !C----------------------------------------------------------------------- !   SUBROUTINE GAUSS_JORDAN(A,N,NP,B,M,MPP,coolant) !   SUBROUTINE GAUSS_JORDAN_writes(A,N,NP,B,coolant,ill) SUBROUTINE GAUSS_JORDAN_writes ( A , N , NP , B , ill ) use definitions use healpix_types use maincode_module , only : p , pdr IMPLICIT NONE integer ( kind = i4b ), intent ( in ) :: ill !,coolant INTEGER ( kind = i4b ) :: I , J , K , L , LL , IROW , ICOL INTEGER ( kind = i4b ), intent ( in ) :: N , NP !,M,MPP integer ( kind = i4b ), PARAMETER :: NMAX = 100 INTEGER ( kind = i4b ) :: IPIV ( 1 : NMAX ), INDXR ( 1 : NMAX ), INDXC ( 1 : NMAX ) real ( kind = dp ), intent ( inout ) :: A ( 1 : NP , 1 : NP ) real ( kind = dp ), intent ( inout ) :: B ( 1 : NP ) !,1:MPP) real ( kind = dp ) :: BIG , DUM , PIVINV write ( 6 , * ) 'b' do i = 1 , np write ( 6 , * ) b ( i ), i enddo write ( 6 , * ) 'a' do i = 1 , np do j = 1 , np write ( 6 , * ) a ( i , j ) enddo enddo ICOL = 0 IROW = 0 IPIV = 0 DO I = 1 , N BIG = 0.0D0 DO J = 1 , N IF ( IPIV ( J ). NE . 1 ) THEN DO K = 1 , N IF ( IPIV ( K ). EQ . 0 ) THEN IF ( ABS ( A ( J , K )). GE . BIG ) THEN BIG = ABS ( A ( J , K )) IROW = J ICOL = K ENDIF !ABS(A ELSE IF ( IPIV ( K ). GT . 1 ) THEN PRINT * , 'ERROR! Singular matrix in GAUSS_JORDAN' write ( 6 , * ) 'Crashed in first loop' !                     write(6,*) 'grid point = ',p, ' coolant = ',coolant write ( 6 , * ) 'gastemperature = ' , pdr ( p )% nTgas STOP ENDIF !IPIV(K).EQ.0 ENDDO !K=1,N ENDIF !IPIV(J).NE.1 ENDDO !J=1,N IPIV ( ICOL ) = IPIV ( ICOL ) + 1 IF ( IROW . NE . ICOL ) THEN DO L = 1 , N DUM = A ( IROW , L ) A ( IROW , L ) = A ( ICOL , L ) A ( ICOL , L ) = DUM ENDDO !L=1,N !            DO L=1,M !               DUM=B(IROW,L) !               B(IROW,L)=B(ICOL,L) !               B(ICOL,L)=DUM !            ENDDO !================================ DUM = B ( IROW ) if ( i . eq . ill ) write ( 6 , * ) 'dum=' , dum , 'A' !write(6,*) 'DUM=',DUM B ( IROW ) = B ( ICOL ) if ( i . eq . ill ) write ( 6 , * ) 'b(' , irow , ')=' , b ( irow ), 'B' !write(6,*) 'irow=',irow !write(6,*) 'B(irow)=',b(irow) B ( ICOL ) = DUM if ( i . eq . ill ) write ( 6 , * ) 'b(' , icol , ')=' , b ( icol ), 'C' !write(6,*) 'icol=',icol !write(6,*) 'b(icol)=',b(icol) !================================ ENDIF !IROW.NE.ICOL INDXR ( I ) = IROW INDXC ( I ) = ICOL IF ( A ( ICOL , ICOL ). EQ . 0.0D0 ) THEN PRINT * , 'ERROR! Singular matrix found by GAUSS_JORDAN' write ( 6 , * ) 'Crashed in second loop' !            write(6,*) 'grid point = ',p, ' coolant = ',coolant write ( 6 , * ) 'gastemperature = ' , pdr ( p )% nTgas STOP ENDIF PIVINV = 1.0D0 / A ( ICOL , ICOL ) A ( ICOL , ICOL ) = 1.0D0 DO L = 1 , N A ( ICOL , L ) = A ( ICOL , L ) * PIVINV ENDDO !         DO L=1,M !            B(ICOL,L)=B(ICOL,L)*PIVINV !         ENDDO !======================================= if ( i . eq . ill ) write ( 6 , * ) b ( icol ), pivinv , 'D' B ( ICOL ) = B ( ICOL ) * PIVINV if ( i . eq . ill ) write ( 6 , * ) b ( icol ), 'E' !write(6,*) 'pivinv=',pivinv !write(6,*) 'b(icol)=',b(icol) !======================================= DO LL = 1 , N IF ( LL . NE . ICOL ) THEN DUM = A ( LL , ICOL ) A ( LL , ICOL ) = 0.0D0 DO L = 1 , N A ( LL , L ) = A ( LL , L ) - A ( ICOL , L ) * DUM ENDDO !               DO L=1,M !                  B(LL,L)=B(LL,L)-B(ICOL,L)*DUM !               ENDDO !============================================= if ( i . eq . ill ) then write ( 6 , * ) 'll=' , ll , 'F' write ( 6 , * ) 'b(ll)=' , b ( ll ), 'G' write ( 6 , * ) 'b(icol)=' , b ( icol ), 'H' write ( 6 , * ) 'dum=' , dum , 'I' endif B ( LL ) = B ( LL ) - B ( ICOL ) * DUM if ( i . eq . ill ) write ( 6 , * ) 'b(ll) after=' , b ( ll ), 'J' !============================================= ENDIF !LL.NE.ICOL ENDDO !LL=1,N ENDDO ! I=1,N DO L = N , 1 , - 1 IF ( INDXR ( L ). NE . INDXC ( L )) THEN DO K = 1 , N DUM = A ( K , INDXR ( L )) A ( K , INDXR ( L )) = A ( K , INDXC ( L )) A ( K , INDXC ( L )) = DUM ENDDO !K=1,N ENDIF !INDXR(L).NE.INDXC(L) ENDDO !L=N,1,-1 do i = 1 , n write ( 6 , * ) b ( i ), i enddo RETURN END subroutine","tags":"","url":"sourcefile/solvlevpop.f90.html"},{"title":"m_visual.F90 – 3D-PDR","text":"This file depends on sourcefile~~m_visual.f90~~EfferentGraph sourcefile~m_visual.f90 m_visual.F90 sourcefile~m_paramters.f90 m_paramters.F90 sourcefile~m_visual.f90->sourcefile~m_paramters.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~m_visual.f90~~AfferentGraph sourcefile~m_visual.f90 m_visual.F90 sourcefile~convert_fin2h5.f90 convert_fin2h5.F90 sourcefile~convert_fin2h5.f90->sourcefile~m_visual.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module m_visual use m_paramters implicit none private integer , parameter :: mytype_save = KIND ( 0.0D0 ) public :: initvisual contains !****************************************************************** ! InitVisu !****************************************************************** subroutine initvisual implicit none ! locals character ( 128 ) :: XdmfFile , out_file_h5 integer :: nUnitFile , ierror ! write XDMF file write ( xdmfFile , \"(A)\" ) \"VisuFor3DPDR.xmf\" open ( newunit = nUnitFile , file = XdmfFile , status = 'replace' , form = 'formatted' , IOSTAT = ierror ) if ( ierror /= 0 ) print * , \"Cannot open xmf file\" ! XDMF/XMF Title write ( nUnitFile , '(A)' ) '<?xml version=\"1.0\" ?>' write ( nUnitFile , '(A)' ) '<!DOCTYPE Xdmf SYSTEM \"Xdmf.dtd\" []>' write ( nUnitFile , '(A)' ) '<Xdmf xmlns:xi=\"http://www.w3.org/2003/XInclude\" Version=\"2.0\">' write ( nUnitFile , '(A)' ) '  <Domain>' ! grid write ( nUnitFile , '(A)' ) '    <Grid name=\"Mesh\" GridType=\"Uniform\">' write ( nUnitFile , '(A,3I7,A)' ) '      <Topology TopologyType=\"3DCoRectMesh\" Dimensions=\"' , nxc , nyc , nzc , '\"/>' write ( nUnitFile , '(A)' ) '      <Geometry Type=\"ORIGIN_DXDYDZ\">' write ( nUnitFile , '(A,3I2,A)' ) '        <DataItem Format=\"XML\" Dimensions=\"3\">' , 0 , 0 , 0 , '</DataItem>' write ( nUnitFile , '(A,3ES15.7,A)' ) '        <DataItem Format=\"XML\" Dimensions=\"3\">' , dx , dy , dz , '</DataItem>' write ( nUnitFile , '(A)' ) '      </Geometry>' write ( nUnitFile , '(A)' ) '      <Time Value=\"0\"/>' ! add virables out_file_h5 = trim ( adjustl ( outname )) // \".pdr.h5\" call Write_XDMF_One ( nUnitFile , out_file_h5 , 'tgas' ) call Write_XDMF_One ( nUnitFile , out_file_h5 , 'rho' ) call Write_XDMF_One ( nUnitFile , out_file_h5 , 'uv' ) call Write_XDMF_One ( nUnitFile , out_file_h5 , 'abundance033' ) call Write_XDMF_One ( nUnitFile , out_file_h5 , 'av011' ) out_file_h5 = trim ( adjustl ( outname )) // \".cool.h5\" call Write_XDMF_One ( nUnitFile , out_file_h5 , 'cool004' ) call Write_XDMF_One ( nUnitFile , out_file_h5 , 'totalcool' ) out_file_h5 = trim ( adjustl ( outname )) // \".heat.h5\" call Write_XDMF_One ( nUnitFile , out_file_h5 , 'heat012' ) write ( nUnitFile , '(A)' ) '    </Grid>' write ( nUnitFile , '(A)' ) '  </Domain>' write ( nUnitFile , '(A)' ) '</Xdmf>' close ( nUnitFile , IOSTAT = ierror ) end subroutine initvisual !****************************************************************** ! Write_XDMF_One !****************************************************************** subroutine Write_XDMF_One ( nUnitFile , outname , chAttribute ) implicit none integer , intent ( in ) :: nUnitFile character ( * ), intent ( in ) :: outname , chAttribute ! locals character ( 128 ) :: chFile integer :: iprec = mytype_save write ( chFile , '(3A)' ) trim ( outname ) // ':/' // trim ( chAttribute ) write ( nUnitFile , '(A)' ) '      <Attribute Name=\"' // trim ( chAttribute ) // '\" AttributeType=\"Scalar\" Center=\"Node\">' write ( nUnitFile , '(A,I1,A,3I7,A)' ) '        <DataItem Format=\"HDF\" DataType=\"Float\" Precision=\"' ,& & iprec , '\" Dimensions=\"' , nxc , nyc , nzc , '\">' write ( nUnitFile , '(A)' ) '          ' // trim ( chFile ) write ( nUnitFile , '(A)' ) '        </DataItem>' write ( nUnitFile , '(A)' ) '      </Attribute>' end subroutine Write_XDMF_One end module m_visual","tags":"","url":"sourcefile/m_visual.f90.html"},{"title":"UVfield.F90 – 3D-PDR","text":"This file depends on sourcefile~~uvfield.f90~~EfferentGraph sourcefile~uvfield.f90 UVfield.F90 sourcefile~healpix_types.f90 healpix_types.F90 sourcefile~uvfield.f90->sourcefile~healpix_types.f90 sourcefile~modules.f90 modules.F90 sourcefile~uvfield.f90->sourcefile~modules.f90 sourcefile~definitions.f90 definitions.F90 sourcefile~healpix_types.f90->sourcefile~definitions.f90 sourcefile~modules.f90->sourcefile~healpix_types.f90 sourcefile~modules.f90->sourcefile~definitions.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! Calculation of the UVfield SUBROUTINE CALC_UVFIELD use healpix_types use maincode_module use global_module #ifdef RAYTHEIA_MO use m_Mesh use m_Ray_box #else #ifdef RAYTHEIA use m_Mesh use m_Ray_box #endif #endif real ( kind = dp ) :: UVdot real ( kind = dp ) :: UVdotsum integer ( kind = I4B ) :: UVinter do p = 1 , pdr_ptot pdr ( p )% UVfield = 0.0D0 enddo #ifdef RAYTHEIA_MO #ifdef OPENMP !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(p,adaptive_step,j,i) & !$OMP PRIVATE(thfpix,phfpix,ray,box1,epray,projected,plength,UVdot,UVdotsum,UVinter) #endif #else #ifdef OPENMP !$OMP PARALLEL DO DEFAULT(SHARED) PRIVATE(p,adaptive_step,j,i) #endif #endif DO p = 1 , pdr_ptot pdr ( p )% rad_surface = 0.0D0 pdr ( p )% AV = 0.0D0 #ifdef RAYTHEIA_MO box1 % min = corner_min box1 % max = corner_max epray = 0 projected = p plength = 0.D0 do j = 0 , nrays - 1 call pix2ang_nest ( nside , j , thfpix , phfpix ) ray % origin = [ pdr ( p )% x , pdr ( p )% y , pdr ( p )% z ] ray % angle = [ thfpix , phfpix ] call raytheia ( ray , box1 , levels - 1 , j , epray , projected , plength ) enddo #else pdr ( p )% projected (:, 0 ) = p #endif DO j = 0 , nrays - 1 #ifdef RAYTHEIA_MO IF ( epray ( j ). GT . 0 ) THEN do i = 1 , epray ( j ) adaptive_step = plength ( j , i ) pdr ( p )% AV ( j ) = pdr ( p )% AV ( j ) + & & pdr ( INT ( projected ( j , i )))% rho * adaptive_step * pc enddo ENDIF #else #ifdef RAYTHEIA IF ( pdr ( p )% epray ( j ). GT . 0 ) THEN DO i = 1 , pdr ( p )% epray ( j ) adaptive_step = pdr ( p )% length ( j , i ) pdr ( p )% AV ( j ) = pdr ( p )% AV ( j ) + & & pdr ( INT ( pdr ( p )% projected ( j , i )))% rho * adaptive_step * pc ENDDO ENDIF #else IF ( pdr ( p )% epray ( j ). GT . 0 ) THEN DO i = 1 , pdr ( p )% epray ( j ) adaptive_step = SQRT (( pdr ( p )% epoint ( 1 , j , i - 1 ) - pdr ( p )% epoint ( 1 , j , i )) ** 2 + & & ( pdr ( p )% epoint ( 2 , j , i - 1 ) - pdr ( p )% epoint ( 2 , j , i )) ** 2 + & & ( pdr ( p )% epoint ( 3 , j , i - 1 ) - pdr ( p )% epoint ( 3 , j , i )) ** 2 ) pdr ( p )% AV ( j ) = pdr ( p )% AV ( j ) + & &(( pdr ( INT ( pdr ( p )% projected ( j , i - 1 )))% rho + & & pdr ( INT ( pdr ( p )% projected ( j , i )))% rho ) / 2. ) * adaptive_step * pc ENDDO ENDIF #endif #endif pdr ( p )% AV ( j ) = pdr ( p )% AV ( j ) * AV_fac if ( pdr ( p )% AV ( j ). gt . 10 0.0 ) pdr ( p )% AV ( j ) = 10 0.0D0 !limiting AV to avoid numerical errors ENDDO #ifdef ONEDIMENSIONAL pdr ( p )% rad_surface = 0.0D0 pdr ( p )% rad_surface ( 6 ) = Gext ( 1 ) !-DOT_PRODUCT(Gext(:),vectors(:,j)) #else pdr ( p )% rad_surface = Gext ( 1 ) / real ( nrays , kind = dp ) #endif DO j = 0 , nrays - 1 pdr ( p )% UVfield = pdr ( p )% UVfield + pdr ( p )% rad_surface ( j ) * EXP ( - pdr ( p )% AV ( j ) * UV_fac ) IF ( pdr ( p )% UVfield . LT . 1.0D-50 ) pdr ( p )% UVfield = 0.0D0 ENDDO ! End of loop over rays ENDDO ! End of loop over pdr cells #ifdef OPENMP !$OMP END PARALLEL DO #endif #ifdef THERMALBALANCE #ifdef GUESS_TEMP DO p = 1 , pdr_ptot Tguess = 1 0.0D0 * ( 1.0D0 + ( 2. * pdr ( p )% UVfield ) ** ( 1.0D0 / 3.0D0 )) pdr ( p )% nTgas = Tguess pdr ( p )% Tgas = Tguess pdr ( p )% Tlow = Tguess / 2.0D0 pdr ( p )% Thigh = Tguess * 1.5D0 IF ( pdr ( p )% Tlow . LT . Tmin ) pdr ( p )% Tlow = Tmin IF ( pdr ( p )% Thigh . GT . Tmax ) pdr ( p )% Thigh = Tmax ENDDO #endif #endif RETURN END SUBROUTINE CALC_UVFIELD","tags":"","url":"sourcefile/uvfield.f90.html"},{"title":"read_coolants.F90 – 3D-PDR","text":"This file depends on sourcefile~~read_coolants.f90~~EfferentGraph sourcefile~read_coolants.f90 read_coolants.F90 sourcefile~modules.f90 modules.F90 sourcefile~read_coolants.f90->sourcefile~modules.f90 sourcefile~definitions.f90 definitions.F90 sourcefile~modules.f90->sourcefile~definitions.f90 sourcefile~healpix_types.f90 healpix_types.F90 sourcefile~modules.f90->sourcefile~healpix_types.f90 sourcefile~healpix_types.f90->sourcefile~definitions.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code subroutine readcoolants use maincode_module allocate ( coolant ( 1 : coo )) do i = 1 , coo open ( unit = 44 , file = coolfile ( i ), status = 'old' ) read ( 44 , '()' ) read ( 44 , * ) coolant ( i )% cname read ( 44 , '()' ) read ( 44 , * ) coolant ( i )% molweight read ( 44 , '()' ) read ( 44 , * ) cur_nlev , cur_ntemp close ( 44 ) coolant ( i )% cnlev = cur_nlev coolant ( i )% cntemp = cur_ntemp allocate ( coolant ( i )% energies ( 1 : cur_nlev )) allocate ( coolant ( i )% weights ( 1 : cur_nlev )) allocate ( coolant ( i )% A_COEFFS ( 1 : cur_nlev , 1 : cur_nlev )) allocate ( coolant ( i )% B_COEFFS ( 1 : cur_nlev , 1 : cur_nlev )) allocate ( coolant ( i )% frequencies ( 1 : cur_nlev , 1 : cur_nlev )) allocate ( coolant ( i )% temperatures ( 1 : 7 , 1 : cur_ntemp )) allocate ( coolant ( i )% H_COL ( 1 : cur_NLEV , 1 : cur_NLEV , 1 : cur_NTEMP )) allocate ( coolant ( i )% HP_COL ( 1 : cur_nlev , 1 : cur_nlev , 1 : cur_ntemp )) allocate ( coolant ( i )% EL_COL ( 1 : cur_NLEV , 1 : cur_NLEV , 1 : cur_NTEMP )) allocate ( coolant ( i )% HE_COL ( 1 : cur_NLEV , 1 : cur_NLEV , 1 : cur_NTEMP )) allocate ( coolant ( i )% H2_COL ( 1 : cur_NLEV , 1 : cur_NLEV , 1 : cur_NTEMP )) allocate ( coolant ( i )% PH2_COL ( 1 : cur_NLEV , 1 : cur_NLEV , 1 : cur_NTEMP )) allocate ( coolant ( i )% OH2_COL ( 1 : cur_NLEV , 1 : cur_NLEV , 1 : cur_NTEMP )) call readinput ( coolfile ( i ), cur_nlev , cur_ntemp , coolant ( i )% energies , coolant ( i )% weights ,& coolant ( i )% A_COEFFS , coolant ( i )% B_COEFFS , coolant ( i )% frequencies , coolant ( i )% temperatures ,& coolant ( i )% H_COL , coolant ( i )% HP_COL , coolant ( i )% EL_COL , coolant ( i )% HE_COL , coolant ( i )% H2_COL ,& coolant ( i )% PH2_COL , coolant ( i )% OH2_COL ) enddo return end subroutine","tags":"","url":"sourcefile/read_coolants.f90.html"}]}